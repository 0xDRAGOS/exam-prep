{
  "subjects": [
    {
      "name": "Algoritmi si programare",
      "questions": [
        {
          "id": 1,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n#include <stdio.h>\nvoid main(){\n    int a,b = 0;\n    int i;\n    for (i=0;i<10;i++){\n        b = a;\n        a = i;\n    }\nprintf(\"%d\", b);\n}",
          "options": {
            "A": "8",
            "B": "9",
            "C": "10",
            "D": "0123456789"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A. 8.\n\nExplicație: În acest program, două variabile întregi `a` și `b` sunt declarate, cu `b` inițializat la 0 și `a` lăsat neinițializat. Bucla `for` iterează de la `i = 0` la `i = 9` (deci 10 iterații în total). În fiecare iterație, valoarea curentă a lui `a` este salvată în `b`, apoi `a` este setat la valoarea curentă a lui `i`. La finalul buclei, `a` va avea valoarea 9 (ultima valoare a lui `i`), iar `b` va avea valoarea 8 (valoarea anterioară a lui `a`, adică din penultima iterație). Prin urmare, instrucțiunea `printf(\"%d\", b);` va afișa 8."
        },
        {
          "id": 2,
          "text": "Care din urmatoarele expresii sunt echivalente cu a[i]?",
          "options": {
            "A": "*(a+i)",
            "B": "i[a]",
            "C": "&a[i]",
            "D": "*(a+a)",
            "E": "*(a+i*sizeof(a[i]))"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "În programarea C și C++, tablourile și pointerii sunt strâns legate, iar expresia `a[i]` este echivalentă cu aritmetica pointerilor.\n\n- A. `*(a+i)`: Această expresie este echivalentă cu `a[i]` deoarece `a[i]` este, în esență, o formă sintactică prescurtată pentru `*(a+i)`, unde `a` este adresa de bază a tabloului, iar `i` este deplasamentul față de acea adresă. Prin adăugarea lui `i` la `a`, obții adresa elementului `i`, iar apoi dereferențierea acesteia cu `*` îți oferă elementul în sine.\n\n- B. `i[a]`: Acest lucru poate părea neobișnuit, dar este, de asemenea, valid și echivalent cu `a[i]`."
        },
        {
          "id": 3,
          "text": "Instructiunea k++ este echivalenta cu:",
          "options": {
            "A": "k = k + 1",
            "B": "k += 1",
            "C": "++k",
            "D": "k = k + k",
            "E": "k += k",
            "F": "k = k + sizeof(k)"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "Întrebarea cere care dintre opțiunile date sunt echivalente cu expresia `k++` în ceea ce privește incrementarea valorii lui `k` cu unu.\n\n- **Opțiunea A: `k = k + 1`** - Aceasta crește direct valoarea lui `k` cu 1, exact ceea ce face și `k++`.\n- **Opțiunea B: `k += 1`** - Aceasta este o formă prescurtată pentru `k = k + 1`, deci crește și ea valoarea lui `k` cu 1.\n- **Opțiunea C: `++k`** - Acesta este operatorul de pre-incrementare care crește valoarea lui `k` cu 1 înainte ca expresia curentă să fie evaluată, dar în final rezultă în aceeași incrementare a lui `k` cu 1."
        },
        {
          "id": 4,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program? \n\n#include <stdio.h>\nint a,b;\nvoid f1 (int *r, int *s){\n    int temp;\n    temp = *r;\n    *r = *s;\n    *s = temp;\n}\nvoid f2 (int *x, int *y){\n    if (*x > *y) f1(x,y);\n}\nmain(){\n    a = 64;\n    b = 42;\n    f2(&a,&b);\n    printf(\"%d,%d\\n\",a,b);\n}",
          "options": {
            "A": "42,64",
            "B": "64,42",
            "C": "64,64",
            "D": "42,42",
            "E": "eroare de compilare pentru ca lipseste void la declararea functiei main"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Programul definește două variabile globale de tip întreg, `a` și `b`, și două funcții, `f1` și `f2`. Funcția `f1` interschimbă valorile celor două numere întregi indicate de parametrii săi `r` și `s`. Funcția `f2` apelează `f1` pentru a interschimba parametrii săi doar dacă primul parametru este mai mare decât al doilea.\n\nÎn funcția `main`, `a` este inițializat cu valoarea 64 și `b` cu 42. Funcția `f2` este apoi apelată cu adresele lui `a` și `b`. Deoarece `a` (64) este mai mare decât `b` (42), `f2` apelează `f1` pentru a le interschimba."
        },
        {
          "id": 5,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program? \n\n#include <stdio.h>\nint a,b;\nvoid f1 (int r, int s){\n    int temp;\n    temp = r;\n    r = s;\n    s = temp;\n}\nvoid f2 (int x, int y){\n    if (x > y) f1(x,y);\n}\nvoid main(){\n    a = 064;\n    b = 042;\n    f2(a,b);\n    printf(\"%d,%d\\n\",a,b);\n}",
          "options": {
            "A": "52,34",
            "B": "64,42",
            "C": "42,62",
            "D": "34,52",
            "E": "0,0",
            "F": "rezultatul nu poate fi determinat avand in vedere valorile variabilelor a si b"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Programul declară două variabile globale de tip întreg, `a` și `b`. În funcția `main`, aceste variabile sunt inițializate cu valori octale `064` și `042`, care sunt echivalente cu `52` și `34` în sistemul zecimal. Funcția `f2` este apelată cu `a` și `b` ca argumente, dar apelează funcția `f1` doar dacă `x` este mai mare decât `y`. Deoarece `52` este mai mare decât `34`, `f1` este apelată. Totuși, `f1` interschimbă copiile locale ale parametrilor săi `r` și `s`, nu variabilele globale `a` și `b`. Astfel, valorile reale ale lui `a` și `b` rămân neschimbate."
        },
        {
          "id": 6,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program? \n\n#include <stdio.h>\nvoid main(){\n    int k[ ] = {100,200,300,400,500,600,700};\n    int *t=k+2;\n    printf(\"%d \",*t);\n    printf(\"%d \",*(t+2) + *t);\n    *t = *t + 10;\n    printf(\"%d \",*t);\n    t = t+3;\n    printf(\"%d \",*t);\n    *t = *t + *(t-2);\n    printf(\"%d \",*t);\n}",
          "options": {
            "A": "300 800 310 600 1000",
            "B": "200 300 110 600 1100",
            "C": "300 900 320 600 1000",
            "D": "300 800 310 600 900",
            "E": "100 900 310 600 1000",
            "F": "nici una din variante nu este corecta"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a înțelege ce va afișa programul, să parcurgem fiecare pas al execuției codului:\n\n1. **Inițializare**:\n   - Un array `k` este inițializat cu valorile `{100, 200, 300, 400, 500, 600, 700}`.\n   - Un pointer `t` este setat să indice către al treilea element al array-ului `k` (adică `k[2]`), care este `300`.\n\n2. **Primul `printf`**:\n   - `printf(\"%d \",*t);` afișează valoarea indicată de `t`, care este `300`.\n\n3. **Al doilea `printf`**:\n   - `printf(\"%d \",*(t+2) +"
        },
        {
          "id": 7,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nvoid main(){\n    int p[] = {50,60,70,80,90,100};\n    int *q[6],i;\n    for(i =0;i<6;i++)\n    q[i] = &p[i];\n    for(i=5;i>=1;i--){\n        q[i] = q[i-1];\n        *q[i] = *q[i] + *p * 2;\n    }\nfor(i=0;i<6;i++)\nprintf(\"%d \",p[i]);\n}",
          "options": {
            "A": "150 160 170 180 190 100",
            "B": "160 160 170 180 190 100",
            "C": "150 150 150 150 150 150",
            "D": "150 160 170 180 190 190",
            "E": "150 160 170 180 190 200",
            "F": "nici una din variante nu este corecta"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a înțelege ce produce programul, să descompunem codul:\n\n1. **Inițializare**: Un array `p` este declarat cu valorile `{50, 60, 70, 80, 90, 100}`. De asemenea, este declarat un array de pointeri la întregi `q`.\n\n2. **Atribuirea pointerilor**: Primul ciclu atribuie fiecărui element din `q` să pointeze către elementul corespunzător din `p`. După acest ciclu, `q[i]` pointează către `p[i]` pentru toți indicii valizi `i`.\n\n3. **Ciclul de modificare**: Al doilea ciclu iterează de la `i = 5` la `i = 1`. În fiecare iterație:\n   - `q[i]` este setat să..."
        },
        {
          "id": 8,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\n#include <stdlib.h>\nvoid f(int *x){\n    x=(int *) malloc(sizeof(int));\n    *x=12;\n}\nvoid main(){\n    int v=15/10;\n    f(&v);\n    printf(\"%d\",v);\n}",
          "options": {
            "A": "1",
            "B": "12",
            "C": "15",
            "D": "1.5",
            "E": "adresa variabilei v",
            "F": "adresa variabilei x"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Programul demonstrează cum funcționează manipularea pointerilor și alocarea memoriei în C. În funcția `main`, valoarea întreagă `v` este calculată ca `15/10`, ceea ce rezultă în `1` din cauza diviziunii întregi (deoarece atât 15, cât și 10 sunt numere întregi, partea fracționară este eliminată). Funcția `f` este apoi apelată cu adresa lui `v` ca argument. În interiorul funcției `f`, pointerul `x` primește o nouă locație de memorie folosind `malloc`, iar valoarea `12` este stocată în acel spațiu de memorie nou alocat. Totuși, aceasta nu afectează variabila originală `v` din `main`, deoarece `x` este o copie locală a pointerului și modificările aduse lui `x` nu afectează."
        },
        {
          "id": 9,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nvoid main(){\n    int i, p=0x10;\n    for(i=1;;i+=2){\n        if (i=5)\n        break;\n        p+=i;\n    }\nprintf(\"%d\",p);\n}",
          "options": {
            "A": "16",
            "B": "10",
            "C": "26",
            "D": "25",
            "E": "14",
            "F": "programul cicleaza la infinit"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Programul C dat conține o eroare logică în instrucțiunea `if` din cadrul buclei `for`. Condiția `if (i=5)` este destinată să compare `i` cu 5, dar din cauza utilizării unui singur semn egal (`=`), aceasta atribuie de fapt valoarea 5 lui `i` în loc să compare. Aceasta înseamnă că `i` va fi întotdeauna setat la 5 în timpul primei iterații a buclei, iar instrucțiunea `break` va fi executată imediat, terminând bucla.\n\nÎnainte de a intra în buclă, `p` este inițializat cu `0x10`, care este reprezentarea hexazecimală a numărului 16 în sistemul zecimal. Deoarece bucla se întrerupe înainte de a se efectua vreo adunare la `p`, valoarea lui `p`"
        },
        {
          "id": 10,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nint a = 10, b = 5;\nvoid f (int a, int t[]){\n    b = a;\n    t[2] = a % 2;\n    a = (t[0]+t[1])/2;\n    t[0]^=t[1];\n    t[1]^=t[0];\n    t[0]^=t[1];\n}\nvoid main(){\n    int t[]={4,3,1};\n    f(t[2],t);\n    printf(\"%d %d %d %d %d\",a,b,t[0],t[1],t[2]);\n}",
          "options": {
            "A": "10 1 3 4 1",
            "B": "10 5 4 3 1",
            "C": "1 5 3 4 1",
            "D": "7 5 3 4 1",
            "E": "5 5 10 4 0",
            "F": "nici una din variante nu este corecta"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Să analizăm programul pas cu pas:\n\n1. **Inițializarea variabilelor globale:**\n   - `int a = 10, b = 5;` inițializează variabilele globale `a` și `b`.\n\n2. **Funcția `f`:**\n   - Funcția `f` primește un întreg `a` și un array `t[]`.\n   - În interiorul funcției:\n     - `b = a;` atribuie valoarea lui `a` primit (care este `t[2]` sau 1) variabilei globale `b`. Astfel, `b` devine 1.\n     - `t[2] = a % 2;` calculează `1 % 2`, care este 1, și atribuie rezultatul lui `t[2]`."
        },
        {
          "id": 11,
          "text": "Consideram urmatoarea secventa de program?\n\nfloat x = 10;\nint y = 7;\nfloat t[]={3,4,1};\nfloat *q = &x;\nint *r = &y;\nvoid *p;\n\nCare din urmatoarele atribuiri sunt corecte?",
          "options": {
            "A": "q = t;",
            "B": "p = t;",
            "C": "p = &y;",
            "D": "p = r;",
            "E": "x = &t[2];",
            "F": "t = q;",
            "G": "q = r;",
            "H": "r = q;",
            "I": "r = p;"
          },
          "correct_answer": [
            "A",
            "B",
            "C",
            "D"
          ],
          "explanation": "În această întrebare, ni se cere să determinăm care atribuiri sunt valide, având în vedere declarațiile și tipurile de variabile furnizate în programarea C.\n\nSă analizăm fiecare opțiune:\n\nA. `q = t;` - Această atribuire este validă deoarece `q` este un pointer la `float`, iar `t` este un tablou de `float`. Numele tabloului `t` poate fi folosit ca un pointer către primul său element, așa că atribuirea acestuia la `q` este corectă.\n\nB. `p = t;` - Această atribuire este validă deoarece `p` este un `void *`, care este un tip de pointer generic. Un `void *` poate indica către orice tip de date, inclusiv tabloul de `float` `t`.\n\nC. `p = &y;`"
        },
        {
          "id": 12,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nvoid main(){\n    char s[]=\"abcdef\";\n    char *p,*q,c;\n    p=s;\n    q=p+4;\n    while(p < q){\n        c=*p;\n        *p=*q;\n        *q=++c;\n        p++;q--;\n    }\nprintf(\"%s\",s);\n}",
          "options": {
            "A": "edccbf",
            "B": "fedcba",
            "C": "feddca",
            "D": "edcbaf",
            "E": "bcdefg",
            "F": "nici una din variante nu este corecta"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Programul dat manipulează un șir de caractere prin operațiuni cu pointeri și afișează rezultatul final. Iată o explicație pas cu pas:\n\n1. **Inițializare**:\n   - Șirul `s` este inițializat ca `\"abcdef\"`.\n   - Pointerul `p` este setat la începutul șirului (`s`), adică indică spre `'a'`.\n   - Pointerul `q` este setat la `p + 4`, adică indică spre `'e'`.\n\n2. **Executarea buclei**:\n   - Bucle `while` continuă atâta timp cât `p < q`.\n   \n   **Prima iterație**:\n   - `c` primește valoarea indicată de `p`, care este `'a'`.\n   - `*p`"
        },
        {
          "id": 13,
          "text": "Care din urmatoarele linii vor genera eroare la compilare?\n\n1: void main() {\n2: int a[2] = {1,2};\n3: int b[3] = {3};\n4: int* x = a;\n5: int* const y = a;\n6: b = x;\n7: b = y;\n8:}",
          "options": {
            "A": "6, 7",
            "B": "3, 5, 6, 7",
            "C": "3, 4, 6, 7",
            "D": "3, 5",
            "E": "5, 6, 7",
            "F": "5",
            "G": "nici una"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În codul furnizat, liniile 6 și 7 vor genera erori de compilare din cauza operațiunilor de atribuire incorecte care implică tablouri și pointeri. Iată o analiză a liniilor:\n\n1. Linia 3 inițializează un tablou `b` cu dimensiunea 3, dar doar primul element este inițializat explicit. Acest lucru este valid, deoarece elementele rămase vor fi inițializate implicit cu zero.\n2. Linia 5 declară `y` ca un pointer constant la un întreg. Aceasta înseamnă că pointerul în sine nu poate fi schimbat pentru a indica o locație de memorie diferită după inițializare.\n3. Linia 6 încearcă să atribuie `x` lui `b`. În C++, tablourile nu pot fi atribuite direct între ele sau către pointeri. Acest lucru se datorează faptului că numele tabloului acționează ca un pointer către primul său element."
        },
        {
          "id": 14,
          "text": "Consideram urmatorul program:\n\n1: #include <stdio.h>\n2: void main(){\n3: int t[10];\n4: printf(\"sizeof(int)=%d\\n\",sizeof(int));\n5: printf(\"%p\\n\",t);\n6: printf(\"%p\\n\",t+3);\n7:}\n\nDaca in urma executiei liniilor 4 si 5 se afiseaza 2 respectiv 0xF004, ce se va afisa in urmae xecutiei liniei 6?",
          "options": {
            "A": "0xF00A",
            "B": "0xF010",
            "C": "0xF007",
            "D": "0xF006",
            "E": "0xF003"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a determina rezultatul liniei 6, trebuie să înțelegem aritmetica pointerilor în C. Iată explicația:\n\n1. Array-ul `t` este declarat ca `int t[10];`, ceea ce înseamnă că este un array de întregi cu 10 elemente.\n2. `sizeof(int)` este dat ca fiind 2, ceea ce înseamnă că fiecare întreg ocupă 2 octeți de memorie.\n3. Expresia `t` reprezintă adresa primului element al array-ului `t`. Este dată ca fiind `0xF004` din rezultatul liniei 5.\n4. Când adaugi un întreg `n` la un pointer în C (cum ar fi `t + 3`), de fapt deplasezi pointerul cu `n` elemente,"
        },
        {
          "id": 15,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nvoid main(){\n    int x=7;\n    x = 1,2,3;\n    printf(\"%d\",x);\n}\n\nSolution: Operatorul virgula se evalueaza de la stanga la dreapta. Rezultatul este dat de\nultima valoare a expresiei. Insa, deoarce operatorul = are prioritatea mai mare decat a\noperatorului virgula mai intai se atribuie lui x valoarea 1 si apoi se evalueaza expresia x,2,3,\nrezultat care nu este memorat in nicio variabila.",
          "options": {
            "A": "1",
            "B": "7",
            "C": "2",
            "D": "3",
            "E": "6",
            "F": "nimic (programul nu se compileaza)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În programul C dat, expresia `x = 1,2,3;` este esențială pentru a înțelege ce va fi afișat. Operatorul virgulă în C evaluează expresiile de la stânga la dreapta și returnează valoarea ultimei expresii. Totuși, în instrucțiunea `x = 1,2,3;`, operatorul de atribuire `=` are o prioritate mai mare decât operatorul virgulă. Prin urmare, expresia este interpretată ca `(x = 1), 2, 3;`. Aceasta înseamnă că `x` primește mai întâi valoarea `1`. Restul expresiei `2, 3` este evaluat, dar rezultatul său nu este utilizat sau stocat nicăieri. Prin urmare, când se execută `printf(\"%d\",x);`,"
        },
        {
          "id": 16,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nvoid main() {\n    int array[3][] = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}};\n    int s = 0, i ,j;\n    for (i = 0; i < 3 ; ++i){\n        for (j = 2; j < 3 ; j++){\n            s += array[i][j];\n        }\n}\nprintf(\"%d\",s);\n}\n\nSolution: La declararea tablourilor multidimensionale numai prima dimensiune poate fi omisa.\nIn acest caz, se genereaza eroare de compilare deoarece nu este specificat numarul de coloane.",
          "options": {
            "A": "nimic (programul nu se compileaza)",
            "B": "15",
            "C": "0",
            "D": "27",
            "E": "36"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În C, atunci când declarăm tablouri multidimensionale, toate dimensiunile, cu excepția primei, trebuie specificate. În programul dat, tabloul `int array[3][] = {{0, 1, 2}, {3, 4, 5}, {6, 7, 8}};` nu are specificată dimensiunea celei de-a doua dimensiuni (numărul de coloane), ceea ce este necesar pentru ca programul să se compileze cu succes. Deoarece numărul de coloane nu este specificat, compilatorul nu poate aloca corect memoria pentru tablou, ceea ce duce la o eroare de compilare. Prin urmare, programul nu se compilează și nimic nu este afișat pe ecran. Așadar, răspunsul corect este A: nimic (programul nu se compilează)."
        },
        {
          "id": 17,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <stdio.h>\nint f(int y);\nvoid main(){\n    int x = 3;\n    int y = 6;\n    printf(\"%d\", f(x));\n}\nint f(int x){\n    return x+1;\n}",
          "options": {
            "A": "4",
            "B": "7",
            "C": "3",
            "D": "6",
            "E": "nimic (eroare de compilare deoarce functia f a fost apelata inainte de a fi definita)",
            "F": "nimic (eroare de compilare deoarce numele argumentului functiei f este y la declarare si x la definire)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Explicație: Programul se compilează și rulează corect deoarece funcția `f` este declarată înainte de a fi utilizată în funcția `main`. Când `main` apelează `printf(\"%d\", f(x));`, transmite valoarea lui `x` (care este 3) către funcția `f`. Funcția `f` este definită pentru a primi un input de tip întreg `x` și a returna `x + 1`. Prin urmare, `f(3)` returnează `3 + 1`, adică 4. Astfel, programul afișează `4` pe ecran. Numele parametrilor în declarația și definiția funcției nu trebuie să fie identice, deoarece aceștia sunt locali în cadrul funcțiilor lor respective."
        },
        {
          "id": 18,
          "text": "Cate elemente ale vectorului a vor avea valoarea 9 dupa executia programului de mai jos?:\n\nvoid main(){\n    int a[] = {0, 1, 2, 3, 0, 4, 5, 6};\n    int i = 0, x = 9;\n    do{\n        a[i++] = x;\n    }while(i<6&&a[i]);\n}",
          "options": {
            "A": "nici unul",
            "B": "unu",
            "C": "doua",
            "D": "patru",
            "E": "toate"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Programul dat inițializează un tablou `a` cu valori întregi specifice și apoi folosește un ciclu `do-while` pentru a modifica unele dintre aceste valori. Iată o descriere pas cu pas a execuției:\n\n1. Tabloul `a` este inițializat ca `{0, 1, 2, 3, 0, 4, 5, 6}`.\n2. Întregul `x` este setat la `9`, care va fi folosit pentru a înlocui anumite elemente din tablou.\n3. Ciclul începe cu `i = 0`.\n4. În interiorul blocului `do`, `a[i++] = x;` atribuie valoarea `9` lui `a[i]` și apoi incrementează `i`.\n5. Acest"
        },
        {
          "id": 19,
          "text": "Fie urmatorul program:\n\nvoid main (){\n    int v[20], i, n, D;\n    scanf(\"%d\", &n);\n    for(i=0;i<n;i++)\n    v[i]=i%2?i:-i;\n    for(D=1,i=0;i<n;D*=v[i++]);\n    D++;\n    printf(\"%d\",D);\n}\n\nIn urma executiei sale sunt posibile urmatoarele situatii:",
          "options": {
            "A": "Expresia conditionala din primul ciclu for este eronata din punct de vedere sintactic.",
            "B": "Daca variabila n primeste la citire valoarea 6, atunci elementele vectorului v vor fi, in ordine (0,1,-2,3,-4,5).",
            "C": "Prezenta caracterului ” ; ” dupa al doilea ciclu for constituie o eroare",
            "D": "Daca variabila n primeste la citire valoarea 5, atunci programul afiseaza 1",
            "E": "Programul functioneaza corect pentru orice valoare intreaga a lui n mai mica sau egala cu MAXINT."
          },
          "correct_answer": [
            "B",
            "D"
          ],
          "explanation": "Programul C dat inițializează un tablou de numere întregi și efectuează operațiuni bazate pe intrarea utilizatorului. Iată o defalcare a opțiunilor:\n\nA. Expresia condițională din primul ciclu `for` (`i < n`) este sintactic corectă, deci această opțiune este incorectă.\n\nB. Dacă `n` este 6, primul ciclu `for` rulează de la `i = 0` la `i = 5`. Expresia `i % 2 ? i : -i` rezultă în valorile: 0, 1, -2, 3, -4, 5. Aceasta corespunde cu secvența descrisă, făcând această opțiune corectă.\n\nC. Prezența unui punct și virgulă `;` după al doilea ciclu `for` este"
        },
        {
          "id": 20,
          "text": "Fie programul :\n\nvoid main(){\n    int v[]={0, 1, 2, 3, 4, 5, 0};\n    int i=0, n=0;\n    do{\n        if (i == v[i])\n        n++;\n    }while(i<6 && v[i++]);\n}\n\nIn urma executiei programului sunt posibile urmatoarele situatii:",
          "options": {
            "A": "variabila n va avea valoarea 0",
            "B": "variabila n va avea valoarea 1",
            "C": "programul va intra intr-un ciclu infinit",
            "D": "variabila n va avea valoarea 5",
            "E": "variabila n va avea valoarea 2"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Programul C dat inițializează un tablou `v` cu valorile `{0, 1, 2, 3, 4, 5, 0}` și două variabile întregi `i` și `n` setate la 0. Apoi intră într-o buclă `do-while` care continuă atâta timp cât `i` este mai mic decât 6 și `v[i++]` este diferit de zero.\n\nÎn cadrul buclei, condiția `if (i == v[i])` verifică dacă indicele curent `i` este egal cu valoarea de la `v[i]`. Dacă este adevărat, incrementează `n`.\n\nIată execuția pas cu pas:\n\n1. **Iterația 1:** `i = 0`, `v[0] ="
        },
        {
          "id": 21,
          "text": "Se considera secventa urmatoare, in care valorile lui n si x se presupun cunoscute, v este un\nvector cu elementele(v[0],v[1],...,v[n-1])\n\np=n;\nfor(i=0;i<n;i++)\nif (v[i]==x)\np=i;\nfor(i=p+1; i<n; i++)\nv[i-1]=v[i];\nfor(i=0; i<n-1; i++)\nprintf(\"%3d\",v[i])\n\nPrecizati care dintre urmatoarele afirmatii sunt adevarate:",
          "options": {
            "A": "Pentru n=5, x=3 si v=(5,6,2,7,1), se afiseaza ultimele patru elemente nemodificate ale vectorului:6 2 7 1.",
            "B": "Pentru n=5, x=1 si v=(2,1,3,1,4), se afiseaza: 2 3 1 4;",
            "C": "Secventa contine erori de sintaxa",
            "D": "Algoritmul sterge din vector elementul cu valoarea x, prin mutarea cu o pozitie mai la dreapta a elementelor aflate inaintea lui.",
            "E": "Algoritmul sterge din vector elementul cu valoarea x, prin mutarea cu o pozitie mai la stanga a elementelor a(cid:13)ate dupa el."
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Răspunsul corect este E. Iată explicația:\n\nCodul dat este conceput pentru a elimina prima apariție a elementului `x` din vectorul `v` prin deplasarea elementelor care vin după `x` cu o poziție spre stânga.\n\n1. **Inițializare**: Variabila `p` este inițializată cu valoarea `n`. Aceasta va stoca poziția primei apariții a lui `x` dacă este găsit în vector.\n\n2. **Găsirea lui `x`**: Primul ciclu `for` caută prima apariție a lui `x` în vectorul `v`. Dacă `x` este găsit la poziția `i`, `p` este actualizat la `i`.\n\n3. **Deplasarea Elementelor**: Dacă `x`"
        },
        {
          "id": 22,
          "text": "In programul urmator, care dintre secventele de instructiuni (I), (II), (III) realizeaza corect \ncitirea unui sir de caractere de la tastatura si afisarea acestuia?\n\nvoid main(){\n    char s1[10],s2[10],s3[10];\n    scanf(\"%s\", &s3[3]);\n    printf(\"%s\", s3[3]); //(I)\n    scanf(\"%s\", s2);\n    printf(\"s2=%s\", s2); //(II)\n    scanf(\"%s\",&s1);\n    printf(\"%s\", s1[10]); //(III)\n}",
          "options": {
            "A": "numai (I)",
            "B": "toate",
            "C": "(I) si (II)",
            "D": "(I) si (III)",
            "E": "numai (II)"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Răspunsul corect este E, ceea ce înseamnă că doar secvența (II) citește corect un șir de la tastatură și îl afișează. Iată de ce:\n\n1. **Secvența (I)**: `scanf(\"%s\", &s3[3]);` încearcă să citească un șir începând de la adresa `s3[3]`, ceea ce este incorect deoarece nu asigură că există suficient spațiu pentru a stoca șirul începând din această poziție în cadrul matricei `s3`. În plus, `printf(\"%s\", s3[3]);` încearcă să afișeze un caracter ca un șir, ceea ce este incorect și probabil va cauza un comportament nedefinit.\n\n2. **Secvența (II)**: `scanf(\"%s\", s2);` citește corect un șir în matricea `s2`."
        },
        {
          "id": 23,
          "text": "Pentru programul urmator, analizati corectitudinea afirmatiilor de mai jos:\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\nvoid main(){\n    char s1[4], s2[4];\n    long x;\n    scanf(\"%s %s\", s1, s2) ;\n    if (strcmp(s1, s2)>0)\n    x=atol(s1);\n    else\n    if(strcmp(s1, s2)==0)\n    x = 0;\n    else x = atol(s2);\n    printf(\"%d\", x);\n}",
          "options": {
            "A": "Conditiile din cele doua linii if sunt gresite.",
            "B": "Apelurile functiei atol sunt corecte",
            "C": "Daca de la tastatura se introduc sirurile \"98\" si \"123\" atunci se va afisa 98.",
            "D": "Daca de la tastatura se introduc sirurile \"123\" si \"121\", atunci programul va afisa sirul \"123\".",
            "E": ""
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "Să analizăm fiecare afirmație referitoare la programul C dat:\n\nA. \"Condițiile din cele două linii if sunt greșite.\"\n   - Condițiile din instrucțiunile `if` verifică rezultatul funcției `strcmp`, care este folosită corect pentru a compara șiruri de caractere în C. Prin urmare, această afirmație este incorectă.\n\nB. \"Apelurile funcției atol sunt corecte.\"\n   - Funcția `atol` este folosită pentru a converti un șir de caractere într-un număr întreg de tip long. Având în vedere că `s1` și `s2` sunt așteptate să fie șiruri numerice (pe baza logicii programului), apelurile funcției `atol` sunt adecvate. Prin urmare, această afirmație este corectă.\n\nC. \"Dacă de la tastatură se introduc șirurile '98'"
        },
        {
          "id": 24,
          "text": "In conformitate cu standardul ASCII, codurile literelor mari sunt succesive incepand cu 65, ce va \nafisa programul de mai jos?\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\nvoid main(){\n    int x = 20, e;\n    char s[15] =\"ABC\", t[15], u[15];\n    e = s[1] + s[2];\n    itoa(e, t, 10);\n    strcpy(u, t);\n    strcat(s, u);\n    printf(\"%s \", s);\n}",
          "options": {
            "A": "Nimic, sirul s fiind vid",
            "B": "ABC13",
            "C": "AB13",
            "D": "ABC133",
            "E": "ABC131"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Programul este conceput pentru a efectua anumite operațiuni asupra unui șir de caractere și apoi pentru a afișa rezultatul. Iată o explicație pas cu pas a ceea ce se întâmplă:\n\n1. **Inițializare**:\n   - `char s[15] = \"ABC\"` inițializează șirul `s` cu valoarea \"ABC\".\n   - `char t[15], u[15]` sunt declarate ca tablouri de caractere pentru a stoca șiruri temporare.\n\n2. **Calcularea lui `e`**:\n   - `e = s[1] + s[2]` calculează suma valorilor ASCII ale caracterelor de la pozițiile 1 și 2 din șirul `s`.\n   - `s[1]` este 'B', care are o valoare ASCII de"
        },
        {
          "id": 25,
          "text": "Care dintre specificatorii modului de acces al fisierelor binare sau text, pentru functia fopen, sunt corecti:",
          "options": {
            "A": "ab",
            "B": "rb",
            "C": "ap",
            "D": "wt",
            "E": "at",
            "F": "ba",
            "G": "toate variantele sunt corecte"
          },
          "correct_answer": [
            "A",
            "B",
            "D",
            "E"
          ],
          "explanation": "Răspunsul corect pentru specificatorii modului de acces la fișiere în funcția `fopen` este A, B, D, E. Iată o scurtă explicație pentru fiecare:\n\n- **A. ab**: Deschide un fișier binar pentru adăugare. Datele sunt adăugate la sfârșitul fișierului fără a elimina conținutul existent. Dacă fișierul nu există, va fi creat.\n- **B. rb**: Deschide un fișier binar pentru citire. Fișierul trebuie să existe; în caz contrar, operațiunea de deschidere va eșua.\n- **D. wt**: Deschide un fișier text pentru scriere. Dacă fișierul există deja, conținutul său este șters. Dacă nu există, va fi creat un fișier nou.\n- **E. at**: Deschide un fișier text pentru adăugare."
        },
        {
          "id": 26,
          "text": "Stiind ca fisierul f1.txt exista in directorul curent iar f2.txt nu este creat, care dintre urmatoarele secvente de instructiuni este gresita?",
          "options": {
            "A": "f1=fopen(”f1.txt”,”w”);",
            "B": "f1=fopen(”f1.txt”,”r+”);",
            "C": "f2=fopen(\"f2.txt\",\"r+\");",
            "D": "f2=fopen(”f2.txt”,”’w+”);",
            "E": "toate variantele anterioare sunt gresite"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Întrebarea se referă la deschiderea fișierelor în C folosind funcția `fopen` cu diferite moduri.\n\n- Opțiunea A (`fopen(\"f1.txt\", \"w\")`): Acest mod deschide fișierul pentru scriere. Dacă fișierul există, conținutul său este șters. Deoarece `f1.txt` există, această operațiune este validă.\n- Opțiunea B (`fopen(\"f1.txt\", \"r+\")`): Acest mod deschide fișierul atât pentru citire, cât și pentru scriere. Fișierul trebuie să existe pentru ca acest mod să funcționeze. Deoarece `f1.txt` există, această operațiune este validă.\n- Opțiunea C (`fopen(\"f2.txt\", \"r+\")`): Acest mod deschide fișierul atât pentru citire, cât și pentru scriere, dar fișierul trebuie să existe în prealabil."
        },
        {
          "id": 27,
          "text": "Care este efectul subprogramului alaturat?\n\nvoid X(char *a, char *b){\n    FILE *f,*g;\n    char s[255];\n    f=fopen(a,\"a\");\n    g=fopen(b,\"r\");\n    while(!feof(g)){\n        fgets(s,255,g);\n        fputs(s,f);\n    }\nfclose(f);\nfclose(g);\n}",
          "options": {
            "A": "copiaza continutul fisierului g peste continutul fisierului f",
            "B": "citeste informatiile din cele doua fisiere ale caror nume se transmit ca parametri",
            "C": "concateneaza doua fisiere, rezultatul concatenarii fiind pus in fisierul f",
            "D": "concateneaza doua fisiere, rezultatul concatenarii fiind pus in fisierul g",
            "E": "toate variantele anterioare sunt gresite"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Funcția `X` primește ca parametri două nume de fișiere: `a` și `b`. Deschide fișierul `a` în modul de adăugare (`\"a\"`) și fișierul `b` în modul de citire (`\"r\"`). Apoi citește fiecare linie din fișierul `b` folosind `fgets` și o scrie în fișierul `a` folosind `fputs`. Acest lucru adaugă efectiv întregul conținut al fișierului `b` la sfârșitul fișierului `a`. Astfel, funcția concatenează conținutul celor două fișiere, rezultatul fiind stocat în fișierul `a`. Prin urmare, răspunsul corect este C: concatenează două fișiere, iar rezultatul concatenării este plasat în fișierul `f`."
        },
        {
          "id": 28,
          "text": "Care dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Pentru a inchide un fisier se foloseste functia unlink;",
            "B": "Pentru redenumirea unui fisier in cadrul programului se foloseste functia remove",
            "C": "Pentru a deschide un fisier se foloseste functia fopen",
            "D": "Nu pot fi adaugate informatii intr-un fisier",
            "E": "Toate celelalte variante sunt eronate"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Răspunsul corect este C, deoarece funcția `fopen` este folosită pentru a deschide un fișier în programarea C. Iată o scurtă explicație pentru fiecare opțiune:\n\nA. Funcția `unlink` este folosită pentru a șterge un fișier, nu pentru a-l închide. Pentru a închide un fișier, se folosește funcția `fclose`.\n\nB. Funcția `remove` este folosită pentru a șterge un fișier, nu pentru a-l redenumi. Pentru a redenumi un fișier, se folosește funcția `rename`.\n\nC. Funcția `fopen` este într-adevăr folosită pentru a deschide un fișier, permițându-vă să specificați modul în care fișierul ar trebui accesat (de exemplu, citire, scriere).\n\nD. Este posibil să adăugați informații într-un fișier deschizându-l în modul de adăugare sau scriere."
        },
        {
          "id": 29,
          "text": "Ce valori se vor gasi in fisierul numere.txt dupa executia urmatorului program?\n\n#include <conio.h>\n#include <stdio.h>\nFILE *f;\nint i=0, a[10]={20,11,17,4,5,10,14,34,23,11};\nvoid main(){\n    f=fopen(\"c:\\\\numere.txt\",\"w\");\n    for(i=0; i<5; i++){\n        if(a[i]%2!=0)\n        fprintf(f,\"%d \\n\",a[i]);\n    }\nfclose(f);\n}",
          "options": {
            "A": "11 17 5 23 11",
            "B": "20 4 10 14 34",
            "C": "11\n17\n5",
            "D": "11\n17\n5\n23\n11"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Programul scrie anumite valori din tabloul `a` în fișierul `numere.txt`. Scrie doar valorile care sunt impare (adică, nu sunt divizibile cu 2) din primele cinci elemente ale tabloului `a`. Tabloul `a` este inițializat cu valorile `{20, 11, 17, 4, 5, 10, 14, 34, 23, 11}`. Bucla din program iterează de la `i = 0` la `i < 5`, luând astfel în considerare doar primele cinci elemente ale lui `a`: 20, 11, 17, 4 și 5. Dintre acestea, doar 11, 17 și 5"
        },
        {
          "id": 30,
          "text": "Ce se intampla in urma executiei urmatorului program daca fisierul nr.txt contine\nvalorile 7 14 6 3 8 10 ?FILE *f, *g;\nint x;\nvoid main(){\n    f=fopen(\"nr.txt\",\"r+\");\n    g=fopen(\"nr2.txt\",\"w+\");\n    while(!feof(f)){\n        fscanf(f,\"%d\", &x);\n        if(x%2==0)\n        fprintf(g,\"%d \\n\",x);\n    }\nfclose(f);\nfclose(g);\n}",
          "options": {
            "A": "Fisierul nr2.txt va contine valorile 14 6 8 10",
            "B": "Fisierul nr2.txt va contine valorile 14 6 8 10, fiecare pe alta linie",
            "C": "Fisierul nr.txt va contine valorile 7 14 6 8 10",
            "D": "Fisierul nr.txt va contine valorile 7 14 6 8 10, fiecare pe alta linie"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Programul C dat citește numere întregi din fișierul \"nr.txt\" și scrie doar numerele pare în fișierul \"nr2.txt\". Funcția `fscanf` citește fiecare număr întreg din \"nr.txt\", iar instrucțiunea `if` verifică dacă numărul este par folosind condiția `x%2==0`. Dacă numărul este par, acesta este scris în \"nr2.txt\", urmat de un caracter de linie nouă (`\\n`), ceea ce asigură că fiecare număr par este tipărit pe o linie nouă. Bucla continuă până la sfârșitul fișierului. Prin urmare, răspunsul corect este B, deoarece \"nr2.txt\" va conține numerele pare 14, 6, 8 și 10, fiecare pe o linie separată."
        }
      ]
    },
    {
      "name": "Structuri de date si tehnici de elaborare a algoritmilor",
      "questions": [
        {
          "id": 1,
          "text": "Se da urmatorul algoritm:\nCare vor fi valorile vectorului a dupa terminarea pasului i=5, a=(8;6;4;2;3;5;7)?",
          "image": "structuri_1.png",
          "options": {
            "A": "(2;3;4;5;6;8;7)",
            "B": "(2;3;4;5;8;7;6)",
            "C": "(2;3;4;8;7;6;5)",
            "D": "(8;7;6;5;4;2;3)",
            "E": "(2;3;4;5;6;7;8)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a determina răspunsul corect, trebuie să înțelegem algoritmul aplicat vectorului `a = (8;6;4;2;3;5;7)` în cadrul procesului descris. Deși algoritmul specific nu este menționat explicit, întrebarea pare să implice că este vorba despre un algoritm de sortare sau un proces iterativ similar care rearanjează elementele vectorului.\n\nAvând în vedere opțiunile, se pare că algoritmul efectuează o operațiune de sortare, probabil un sortare prin selecție sau sortare prin inserție, unde vectorul este sortat în ordine crescătoare. Până când algoritmul ajunge la pasul `i=5`, primele cinci elemente ale vectorului sunt sortate în ordine crescătoare, în timp ce restul vectorului rămâne neschimbat.\n\nOpțiunea A `(2;3;4;5;6"
        },
        {
          "id": 2,
          "text": "O procedura ce parcurge urmatorul arbore in inordine va afisa:",
          "image": "structuri_2.png",
          "options": {
            "A": "3,5,6,7,10,12,13,15,16,18,20,23",
            "B": "15,5,3,12,10,6,7,13,16,20,18,23",
            "C": "3,7,6,10,13,12,5,18,23,20,16,15",
            "D": "3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Un parcurs \"inorder\" al unui arbore binar de căutare (BST) implică vizitarea nodurilor în următoarea ordine: subarborele stâng, nodul rădăcină, subarborele drept. Acest parcurs are ca rezultat vizitarea nodurilor în ordine crescătoare pentru un BST. Având în vedere structura arborelui, parcursul inorder va accesa fiecare nod în secvența sortată a valorilor lor. Prin urmare, rezultatul corect va fi o listă sortată a valorilor nodurilor arborelui. Opțiunea A, care este \"3,5,6,7,10,12,13,15,16,18,20,23,\" reflectă această ordine sortată, prin urmare este răspunsul corect."
        },
        {
          "id": 3,
          "text": "O procedura ce parcurge urmatorul arbore in postordine va afisa:",
          "image": "structuri_3.png",
          "options": {
            "A": "3,5,6,7,10,12,13,15,16,18,20,23",
            "B": "15,5,3,12,10,6,7,13,16,20,18,23",
            "C": "3,7,6,10,13,12,5,18,23,20,16,15",
            "D": "3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Într-o parcurgere postordine a unui arbore binar, nodurile sunt vizitate în ordinea subarbore stâng, subarbore drept și apoi nodul rădăcină. Aceasta înseamnă că pentru fiecare subarbore, vizitezi mai întâi toate nodurile din subarborele stâng, apoi toate nodurile din subarborele drept și, în final, nodul rădăcină în sine.\n\nAvând în vedere că răspunsul corect este C: 3,7,6,10,13,12,5,18,23,20,16,15, această secvență reflectă parcurgerea postordine. Ea arată că pentru fiecare subarbore, subarborii stâng și drept sunt complet procesați înainte ca nodul rădăcină să fie vizitat. Ordinea de parcurgere începe de la cel mai adânc nod din stânga (3), procesează frații și nodurile părinte pe măsură ce urcă în arbore și, în final,"
        },
        {
          "id": 4,
          "text": "O procedura ce parcurge urmatorul arbore in preordine va afisa:",
          "image": "structuri_4.png",
          "options": {
            "A": "3,5,6,7,10,12,13,15,16,18,20,23",
            "B": "15,5,3,12,10,6,7,13,16,20,18,23",
            "C": "3,7,6,10,13,12,5,18,23,20,16,15",
            "D": "3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Traversarea pre-order a unui arbore vizitează nodurile în următoarea ordine: rădăcină, subarborele stâng și apoi subarborele drept. Pentru întrebarea dată, opțiunea B (15,5,3,12,10,6,7,13,16,20,18,23) reprezintă corect această ordine de traversare. Începe cu nodul rădăcină (15), apoi se mută la copilul din stânga (5), continuă cu copilul cel mai din stânga (3) și procedează vizitând subarborele stâng al lui 5. După ce completează subarborele stâng, vizitează subarborele drept al lui 5 (începând cu 12). Traversarea continuă vizitând subarborele stâng al fiecărui nod înaintea subarborelui drept, asigurându-se că toate nodurile sunt vizitate în secvența corectă pre-order."
        },
        {
          "id": 5,
          "text": "Care dintre urmatoarele conditii nu este conditia necesara pentru un algoritm de cautare binara:",
          "options": {
            "A": "lista trebuie sa fie sortata",
            "B": "ar trebui sa existe acces direct catre elementul din mijlocul fiecarei subliste",
            "C": "ar trebui sa existe un mecanism de stergere sau/si de inserare a elementelor  in lista",
            "D": "niciuna de mai sus"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Răspunsul corect este C. Un algoritm de căutare binară necesită ca lista să fie sortată (A) și să aibă capacitatea de a accesa direct elementul din mijlocul oricărei subliste (B) pentru a funcționa corect. Totuși, existența unui mecanism pentru ștergerea sau inserarea elementelor (C) nu este o condiție necesară pentru efectuarea unei căutări binare. Prin urmare, opțiunea C nu se califică drept o condiție necesară pentru căutarea binară."
        },
        {
          "id": 6,
          "text": "Care dintre urmatoarele nu este afirmatii nu este adevarata in cazul unui algoritm de cautare binara?",
          "options": {
            "A": "trebuie folosit un array sortat",
            "B": "cerintadeaaveaunarraysortatnecesitamultamemoriesitimpatuncicandsuntnecesare multe stergeri si inserari",
            "C": "trebuie sa existe un mecanism care sa permita accesul direct la elementul din mijloc",
            "D": "algoritmul de cautare binar nu este eficient atunci cand avem mai mult de 1000 de elemente"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Explicație: Algoritmul de căutare binară necesită un șir sortat (A) și acces direct la elementul din mijloc (C) pentru a funcționa corect. De asemenea, menținerea unui șir sortat (B) poate consuma multă memorie și timp, mai ales în cazul în care sunt necesare frecvente inserări și ștergeri. Totuși, afirmația D este falsă, deoarece căutarea binară este foarte eficientă chiar și pentru colecții mari de date, mult peste 1000 de elemente, datorită complexității sale logaritmice, ceea ce o face mai eficientă decât căutările liniare."
        },
        {
          "id": 7,
          "text": "Ce va afisa urmatorul program?\n\nString name;\nint i;\nboolean startWord;\nname = \"Franklin D. Roosevelt\";\nstartword = true;\nfor (i = 0; i < name.length(); i++) {\n    if (startWord)\n    System.out.println(name.charAt(i));\n    if (name.charAt(i) == ’ ’)\n    startWord = true;}\nelse\nstartWord = false;\n}",
          "options": {
            "A": "FDR",
            "B": "Franklin",
            "C": "D",
            "D": "Roosevelt",
            "E": "Franklin D. Roosevelt"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Programul este conceput pentru a extrage și a afișa inițialele cuvintelor din șirul \"Franklin D. Roosevelt\". Iată cum funcționează:\n\n1. Variabila `name` este inițializată cu șirul \"Franklin D. Roosevelt\".\n2. Variabila booleană `startWord` este setată inițial la `true`, indicând că primul caracter al șirului este considerat începutul unui cuvânt.\n3. Un ciclu `for` iterează peste fiecare caracter din șirul `name`.\n4. Dacă `startWord` este `true`, se afișează caracterul curent (`name.charAt(i)`) deoarece este începutul unui cuvânt.\n5. Dacă caracterul curent este un spațiu (`' '`), se setează `startWord` la"
        },
        {
          "id": 8,
          "text": "O procedura ce parcurge urmatorul arbore in inordine va afisa:",
          "image": "structuri_8.png",
          "options": {
            "A": "3,5,6,23,10,12,13,15,16,18,20,7",
            "B": "15,5,3,12,10,6,7,13,16,20,18,23",
            "C": "3,7,6,10,13,12,5,18,23,20,16,15",
            "D": "3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Într-un parcurs in-order al unui arbore binar, nodurile sunt vizitate în următoarea ordine: subarborele stâng, rădăcina, subarborele drept. Această metodă de parcurgere duce la vizitarea nodurilor în ordine crescătoare pentru un arbore binar de căutare (BST).\n\nPentru a determina secvența corectă, începem de la nodul cel mai din stânga și ne deplasăm către rădăcină și apoi către subarborele drept. Să presupunem că structura arborelui este astfel încât opțiunea A reprezintă secvența corectă in-order. Acest lucru ar implica faptul că nodurile sunt vizitate exact în ordinea listată în opțiunea A: 3,5,6,23,10,12,13,15,16,18,20,7. Această secvență se potrivește cu definiția parcurgerii in-order, unde nodurile fiecărui subarbore stâng sunt vizitate înainte de"
        },
        {
          "id": 9,
          "text": "O procedura ce parcurge urmatorul arbore in postordine va afisa:",
          "image": "structuri_9.png",
          "options": {
            "A": "3,5,6,7,10,12,13,15,16,18,20,23",
            "B": "15,5,3,12,10,6,7,13,16,20,18,23",
            "C": "3,23,6,10,13,12,5,18,7,20,16,15",
            "D": "i3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Într-o parcurgere postordine a unui arbore binar, nodurile sunt vizitate în următoarea ordine: subarborele stâng, subarborele drept și apoi nodul rădăcină. Aceasta înseamnă că pentru fiecare subarbore, întâi procesezi toate nodurile din copilul stâng, apoi toate nodurile din copilul drept și, în final, nodul propriu-zis.\n\nSă aplicăm aceasta la arborele dat:\n\n1. Începe cu subarborele cel mai din stânga și vizitează copilul stâng (3).\n2. Treci la copilul drept al primului subarbore (6), care are un copil stâng (5). Vizitează 5, apoi 6.\n3. Treci la copilul drept al rădăcinii principale (12) și repetă: vizitează copilul stâng (10), apoi copilul drept (13), apoi rădăcina..."
        },
        {
          "id": 10,
          "text": "O procedura ce parcurge urmatorul arbore in preordine va afisa:",
          "image": "structuri_10.png",
          "options": {
            "A": "3,5,6,7,10,12,13,15,16,18,20,23",
            "B": "15,5,3,12,10,6,23,13,16,20,18,7",
            "C": "3,7,6,10,13,12,5,18,23,20,16,15",
            "D": "3,6,5,7,10,12,13,15,16,18,20,23",
            "E": "3,5,6,7,10,12,13,16,15,18,20,23"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Traversarea în preordine a unui arbore binar este un tip de traversare în adâncime în care nodurile sunt procesate în următoarea ordine: rădăcină, subarborele stâng și apoi subarborele drept. Aceasta este adesea denumită \"NLR\" (Nod, Stânga, Dreapta).\n\nÎn întrebarea dată, răspunsul corect este B: 15,5,3,12,10,6,23,13,16,20,18,7.\n\nIată explicația pentru traversarea în preordine:\n\n1. Începeți de la rădăcina arborelui. Primul nod vizitat este nodul rădăcină, care este 15.\n2. Apoi, treceți la subarborele stâng al lui 15 și vizitați rădăcina acestui subarbore, care este 5.\n3. Continuați către stânga..."
        },
        {
          "id": 11,
          "text": "Ce metoda de sortare este descrisa in pseudo-codul urmator:\n\nprocedure sort(A)\nn = length(A)\nrepeat\nswapped = false\nfor i = 1 to n-1 do\nif (A[i-1]>A[i] then\nswap (A[i-1],A[i])\nswapped = true\nend if\nend for\nuntil not swapped\nend procedure\n",
          "options": {
            "A": "HeapSort",
            "B": "MergeSort",
            "C": "BubbleSort",
            "D": "SwapSort"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pseudocodul descrie algoritmul de sortare Bubble Sort. Bubble Sort funcționează prin parcurgerea repetată a listei, comparând elementele adiacente și interschimbându-le dacă sunt în ordine greșită. Acest proces se repetă până când nu mai sunt necesare interschimbări, indicând faptul că lista este sortată. Prezența indicatorului `swapped` și parcurgerile repetate prin listă pentru a verifica și efectua interschimbări sunt caracteristici distinctive ale algoritmului Bubble Sort."
        },
        {
          "id": 12,
          "text": "Coloana din stanga reprezinta un input de stringuri ce trebuie sortate; coloana din dreapta reprezinta strigurile sortate; celelalte coloane reprezinta un pas intermediar al unuia dintre algoritmii:\nquicksort, mergesort top-down, merge sort botton-up, heapsort. Care este ordinea algoritmilor\ntinand cont de coloanele afisate?\nnavy wine mist blue blue bark\nplum teal coal gray coal blue\ncoal silk jade rose gray cafe\njade plum blue mint jade coal\nblue sage cafe lime lime corn\npink pink herb navy mint dusk\nrose rose gray jade navy gray\ngray jade leaf teal pink herb\nteal navy dusk coal plum jade\nruby ruby mint ruby rose leaf\nmint pine lime plum ruby lime\nlime palm bark pink teal mint\nsilk coal corn silk bark mist\ncorn corn navy corn corn navy\nbark bark wine bark dusk palm\nwine gray silk wine leaf pine\ndusk dusk ruby dusk silk pink\nleaf leaf teal leaf wine plum\nherb herb sage herb cafe rose\nsage blue rose sage herb ruby\ncafe cafe pink cafe mist sage\nmist mist pine mist palm silk\npine mint palm pine pine teal\npalm lime plum palm sage wine\n0 - - - - 1",
          "options": {
            "A": "Input, quicksort, heapsort, merge bottom-up, merge top-down, output",
            "B": "Input, heapsort, merge top-down, merge bottom-up, quicksort, output",
            "C": "Input, quicksort, heapsort, merge top-down, merge bottom-up, output",
            "D": "Input, merge top-down, merge bottom-up, quicksort, heapsort, output",
            "E": "Input, merge top-down, quicksort, heapsort, merge bottom-up, output"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A.\n\nSă descompunem procesul de sortare așa cum este reflectat de coloane:\n\n1. **Coloana de Intrare**: Aceasta este lista inițială nesortată de șiruri de caractere.\n2. **Coloana Quicksort**: Quicksort este un algoritm de tip divide-et-impera care funcționează prin selectarea unui element 'pivot' și partiționarea array-ului în jurul pivotului. În această coloană, vedem că \"navy\" este primul element, ceea ce probabil înseamnă că a fost folosit ca pivot inițial.\n3. **Coloana Heapsort**: Heapsort construiește un heap din datele de intrare și apoi extrage în mod repetat elementul maxim din heap, urmat de reconstruirea heap-ului. Coloana intermediară arată probabil starea după câteva operațiuni pe heap."
        },
        {
          "id": 13,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f1(int N){\n    int x = 0;\n    for (int i = 0; i < N, i++)\n    x++;\n    return x;\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Algoritmul furnizat constă într-o buclă simplă care iterează de la 0 la \\( N-1 \\). În interiorul buclei, se efectuează o singură operație: incrementarea variabilei \\( x \\). Bucla rulează exact de \\( N \\) ori, iar fiecare iterație a buclei durează un timp constant, independent de \\( N \\). Prin urmare, complexitatea de timp a acestui algoritm este direct proporțională cu \\( N \\), ceea ce face ca timpul de execuție să fie \\( O(N) \\). Aceasta corespunde opțiunii B."
        },
        {
          "id": 14,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f2(int N){\n    int x = 0;\n    for (int i = 0; i < N, i++)\n    for (int j = 0; j < i; j++)\n    x++;\n    return x;\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Algoritmul dat constă într-o structură de bucle imbricate, unde bucla exterioară rulează de `N` ori, iterând cu `i` de la `0` la `N-1`. Bucla interioară rulează de `i` ori pentru fiecare iterație a buclei exterioare.\n\nSă descompunem numărul de iterații:\n\n- Pentru `i = 0`, bucla interioară rulează de `0` ori.\n- Pentru `i = 1`, bucla interioară rulează de `1` dată.\n- Pentru `i = 2`, bucla interioară rulează de `2` ori.\n- ...\n- Pentru `i = N-1`, bucla interioară rulează de `N-1` ori.\n\nNumărul total de iterații ale buclei interioare este suma primelor `N`"
        },
        {
          "id": 15,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f3(int N){\n    if (N==0) return 1;\n    int x=0;\n    for (int i = 0; i < N; i++)\n    x+=f3(N-1);\n    return x;\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "F"
          ],
          "explanation": "Funcția `f3` este o funcție recursivă care calculează o valoare bazată pe intrarea `N`. Cazul de bază este atunci când `N` este 0, caz în care returnează 1. În caz contrar, inițializează un întreg `x` la 0 și folosește un ciclu care rulează de `N` ori. În fiecare iterație a ciclului, își apelează recursiv propria funcție cu argumentul `N-1` și adaugă rezultatul la `x`.\n\nAceasta creează un arbore de apeluri recursive în care fiecare nivel al arborelui corespunde unei scăderi a valorii lui `N` cu 1. La fiecare nivel `N`, funcția face `N` apeluri recursive la nivelul `N-1`. Acest tipar rezultă într-un număr total de apeluri care"
        },
        {
          "id": 16,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f1(int N){\n    int x = 0;\n    for (int i = 0; i < N, i++)\n    x++;\n    return x;\n}\npublic static int f4(int N){\n    if (N==0) return 0;\n    return f4(N/2) + f1(N) + f4(N/2);\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a determina complexitatea temporală a algoritmului dat, trebuie să analizăm ambele funcții, `f1` și `f4`.\n\n1. **Analiza funcției `f1(int N)`:**\n   - `f1` conține un simplu ciclu `for` care iterează de `N` ori, incrementând `x` în fiecare iterație.\n   - Prin urmare, complexitatea temporală a funcției `f1` este O(N).\n\n2. **Analiza funcției `f4(int N)`:**\n   - `f4` este o funcție recursivă care operează după cum urmează:\n     - Dacă `N` este 0, se întoarce imediat cu o operație de timp constant O(1).\n     - Altfel, face două apeluri recursive către ea însăși cu un argument de"
        },
        {
          "id": 17,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f1(int N){\n    int x = 0;\n    for (int i = 0; i < N, i++)\n    x++;\n    return x;\n}\npublic static int f5(int N){\n    int x = 0;\n    for (int i = N; i > 0; i = i/2)\n    x+=f1(i);\n    return x;\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a determina complexitatea temporală a funcției `f5`, trebuie să analizăm atât `f1`, cât și `f5`.\n\n1. **Analizând `f1(int N)`:**\n   - Funcția `f1` execută un ciclu de la 0 la N, efectuând o operație simplă (`x++`) la fiecare iterație.\n   - Prin urmare, complexitatea temporală a lui `f1` este O(N).\n\n2. **Analizând `f5(int N)`:**\n   - Funcția `f5` execută un ciclu în care `i` începe de la N și este înjumătățit (`i = i / 2`) de fiecare dată până când `i` devine 0.\n   - Acesta este un ciclu logaritmic, care în mod tipic rulează log"
        },
        {
          "id": 18,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f6(int N){\n    if (N==0) return 1;\n    return f6(N-1) + f6(N-1);\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Algoritmul dat este o funcție recursivă care se apelează de două ori pentru fiecare decrementare a lui \\( N \\). Mai exact, pentru orice intrare \\( N \\), funcția face două apeluri recursive cu \\( N-1 \\). Această structură seamănă cu un arbore binar unde fiecare nivel al arborelui reprezintă un apel recursiv, iar fiecare nod are doi copii până se ajunge la cazul de bază (când \\( N = 0 \\)).\n\nAdâncimea arborelui de recursivitate este \\( N \\), iar la fiecare nivel \\( i \\), există \\( 2^i \\) noduri (sau apeluri ale funcției). Astfel, la cel mai adânc nivel, numărul de noduri (sau apeluri ale funcției) este \\( 2^N \\). Ca urmare, numărul de operații efectuate de"
        },
        {
          "id": 19,
          "text": "Analizand algoritmul de mai jos precizati ce timp de executie are.\n\npublic static int f7(int N){\n    if (N==1) return 0;\n    return 1+f7(N/2);\n}",
          "options": {
            "A": "logN",
            "B": "N",
            "C": "NlogN",
            "D": "N²",
            "E": "2^N",
            "F": "N!"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Funcția `f7` este o funcție recursivă care reduce valoarea de intrare `N` la jumătate de fiecare dată când este apelată, până când `N` devine 1. Fiecare apel recursiv reprezintă o împărțire la 2, ceea ce sugerează un comportament logaritmic. Numărul de ori în care putem împărți `N` la 2 până ajungem la 1 este aproximativ `log₂N`. Prin urmare, complexitatea de timp a acestei funcții este `O(log N)`, care corespunde răspunsului A."
        },
        {
          "id": 20,
          "text": "Algoritmul Quiksort este cel mai potrivit pentru",
          "options": {
            "A": "Sortarea unui liste mari de chei care sunt in ordine aleatoare",
            "B": "Sortarea unei liste de chei care sunt aproape ordonate",
            "C": "Gasirea celui mai scurt drum",
            "D": "Sortarea unei liste scurte de chei"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Algoritmul QuickSort este un algoritm de sortare eficient, mai ales când se aplică pe liste mari de elemente care sunt distribuite aleatoriu. Funcționează prin alegerea unui pivot și rearanjarea elementelor astfel încât cele mai mici să se afle înaintea pivotului, iar cele mai mari după acesta, continuând recursiv pentru sublistele rezultate. Datorită complexității sale medii de timp de \\(O(n \\log n)\\), QuickSort este deosebit de eficient pentru liste mari de chei în ordine aleatoare. În schimb, pentru liste aproape ordonate sau foarte scurte, alți algoritmi, precum Insertion Sort, pot fi mai eficienți."
        }
      ]
    },
    {
      "name": "Programare orientata obiect",
      "questions": [
        {
          "id": 1,
          "text": "Un program orientat obiect reprezinta:",
          "options": {
            "A": "o colectie de obiecte care coopereaza prin intermediul mesajelor  in vederea realizarii unui obiectiv comun",
            "B": "o varianta de program procedural",
            "C": "un program care poate fi considerat un obiect de catre alte programe",
            "D": "un program specific mediului de programare Windows",
            "E": "un program format din mai multe fisiere sursa si header"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Un program orientat obiect este, în mod fundamental, bazat pe principiile programării orientate pe obiecte (OOP). Răspunsul corect, A, descrie acest concept cu acuratețe. În OOP, un program este structurat ca o colecție de obiecte care interacționează, unde fiecare obiect reprezintă o instanță a unei clase. Aceste obiecte comunică între ele prin mesaje (apeluri de metode) pentru a îndeplini sarcini și a atinge un scop comun. Această abordare pune accent pe modularitate, încapsulare și reutilizabilitate, care sunt principii fundamentale ale designului orientat pe obiecte. Celelalte opțiuni nu surprind cu acuratețe aceste aspecte cheie ale OOP."
        },
        {
          "id": 2,
          "text": "O clasa in modelul de programare orientat obiect reprezinta:",
          "options": {
            "A": "o colectie de obiecte cu aceleasi caracteristici si cu un comportament comun",
            "B": "o colectie de caracteristici",
            "C": "un obiect din program",
            "D": "o interfata",
            "E": "un grup de comportamente specific unui obiect"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În programarea orientată pe obiecte, o clasă este un șablon sau un model pentru crearea obiectelor. Ea definește o colecție de atribute (caracteristici) și metode (comportamente) pe care obiectele create din clasă le vor avea. Astfel, opțiunea A este corectă deoarece descrie cu acuratețe o clasă ca o colecție de obiecte care împărtășesc aceleași caracteristici și comportamente. Opțiunile B, C, D și E reprezintă greșit conceptul de clasă fie prin simplificare excesivă, fie prin confuzia cu alte concepte precum interfețele sau obiectele individuale."
        },
        {
          "id": 3,
          "text": "Obiectele apartinand unei aceleiasi clase se diferentiaza prin:",
          "options": {
            "A": "starea lor",
            "B": "valorile datelor membru declarate in cadrul clasei",
            "C": "valorile caracteristicilor clasei",
            "D": "caracteristicile diferite specifice fiecarui obiect",
            "E": "comportamentul diferit specific fiecarui obiect"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "În contextul programării orientate pe obiecte, obiectele care aparțin aceleiași clase pot diferi între ele pe baza următoarelor aspecte:\n\nA. **Starea lor:** Starea unui obiect este determinată de valorile atributelor sale (sau câmpurilor). Chiar dacă două obiecte sunt instanțe ale aceleiași clase, ele pot avea stări diferite dacă atributele lor dețin valori diferite.\n\nB. **Valorile datelor membru declarate în cadrul clasei:** Fiecare obiect poate avea propriul său set de valori pentru variabilele membru definite de clasă. Aceste valori pot varia de la un obiect la altul, conducând la diferențe între obiectele aceleiași clase.\n\nC. **Valorile caracteristicilor**"
        },
        {
          "id": 4,
          "text": "Consideram urmatorul program C++ \n\n#include <iostream>\nusing namespace std;\nclass C\n{\n    private:\n    int _i;\n    public:\n    C(int i):_i(i){}\n    C():_i(3){}\n    ~C(){cout<<_i<<endl;}\n};\nvoid main()\n{\n    C c1(4);\n    C c2;\n}\n\nCare din urmatoarele afirmatii sunt adevarate:",
          "options": {
            "A": "programul nu contine erori de sintaxa",
            "B": "exista erori de sintaxa in definitiile metodelor constructor",
            "C": "destructorul nu poate contine instructiuni de afisare",
            "D": "in cadrul programului principal sunt create doua instante ale clasei C",
            "E": "programul afiseaza la consola numerele 3 si 4"
          },
          "correct_answer": [
            "A",
            "D",
            "E"
          ],
          "explanation": "Explicație:\n\nA. Programul nu conține erori de sintaxă. - Această afirmație este adevărată. Programul este sintactic corect deoarece respectă sintaxa corectă a limbajului C++ pentru definirea claselor, inițializarea constructorului și implementarea destructorului.\n\nB. Nu există erori de sintaxă în definițiile constructorilor. - Această afirmație este falsă. Definițiile constructorilor sunt corect implementate folosind liste de inițializare, care reprezintă o practică validă și comună în C++.\n\nC. Un destructor nu poate conține instrucțiuni de ieșire. - Această afirmație este falsă. În C++, destructorii pot conține orice cod, inclusiv instrucțiuni de ieșire precum `cout`. Destructorul din acest program este valid și va afișa valoarea lui `_i`.\n\nD. Două instanțe ale clasei C sunt create în programul principal. - Această afirmație este adevărată."
        },
        {
          "id": 5,
          "text": "Care din urmatoarele afirmatii referitoare la mostenire sunt adevarate relativ la limbajul de pro- gramare C++:",
          "options": {
            "A": "Relatia de mostenire in care clasa de baza si clasa derivata au aceeasi interfata se numeste mostenire pura",
            "B": "Dintr-o clasa de baza se poate obtine prin intermediul mostenirii cel mult o clasa derivata",
            "C": "O clasa derivata are exact o clasa de baza",
            "D": "Obiectele apartinand unei clase derivate pot fi convertite la tipul unei clase de baza din care clasa derivata provine",
            "E": "Specificatorul protected este folosit pentru a arata ca elementele care il urmeaza pot fi accesate si din cadrul claselor derivate"
          },
          "correct_answer": [
            "A",
            "D",
            "E"
          ],
          "explanation": "În C++, moștenirea permite unei clase (clasa derivată) să preia proprietăți și comportamente de la o altă clasă (clasa de bază). Să analizăm fiecare afirmație:\n\nA. **Relația de moștenire în care clasa de bază și clasa derivată au aceeași interfață se numește moștenire pură** - Această afirmație este oarecum înșelătoare. Termenul \"moștenire pură\" nu este standard. Totuși, ar putea implica faptul că clasa derivată aderă strict la interfața clasei de bază, ceea ce ar putea avea legătură cu moștenirea de interfață în alte contexte.\n\nB. **Dintr-o clasă de bază se poate obține prin intermediul moștenirii cel mult o clasă derivată** - Aceasta este falsă. În C++, o clasă de bază poate avea multiple clase derivate."
        },
        {
          "id": 6,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program: \n\n#include <iostream.h>\nclass Test {\n    int n;\n    public:\n    Test(int x):n(x){}\n    int f(int n, int &x, int *p){\n        n=this->n;\n        x=n++;\n        *p=this->n + n;\n        return n;\n    }\n};\nvoid main(){\n    Test t(2);\n    int n=6,x=0x10,p=1;\n    cout<<t.f(n,x,&p)<<\" \";\n    cout<<n<<\" \"<<x<<\" \"<<p;\n}",
          "options": {
            "A": "3 6 2 5",
            "B": "3 6 16 1",
            "C": "6 6 10 1",
            "D": "3 7 10 1",
            "E": "Eroare de compilare deoarce constructorul nu contine nici o intructiune"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a înțelege ce va fi afișat pe ecran, să analizăm programul pas cu pas:\n\n1. **Inițializarea Clasei**:\n   - Un obiect `t` al clasei `Test` este creat cu constructorul `Test(2)`, care inițializează variabila membru `n` a obiectului `t` la 2.\n\n2. **Apelul Funcției**:\n   - Funcția `f` este apelată cu argumentele `n=6`, `x=0x10` (care este 16 în sistemul zecimal) și `&p` (adresa lui `p`, unde `p` este inițializat la 1).\n\n3. **În Interiorul Funcției `f`**:\n   - `n=this->n;`: Parametrul local `"
        },
        {
          "id": 7,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program: \n\n#include <iostream.h>\nclass B1 {\n    public:\n    B1(){cout<<\"B1 \";}\n    ~B1(){cout<<\"DB1 \";}\n};\nclass B2 {\n    public:\n    B2(){cout<<\"B2 \";}\n    ~B2(){cout<<\"DB2 \";}\n};\nclass D: public B1, public B2{\n    public:\n    D():B2(),B1(){cout<<\"D \";}\n    ~D(){cout<<\"DD \";}\n};\nvoid main(){\n    D d1;\n    D d2=d1;\n}",
          "options": {
            "A": "B1 B2 D DD DB2 DB1 DD DB2 DB1",
            "B": "B2 B1 D DD DB2 DB1 DD DB2 DB1",
            "C": "B1 B2 D B1 B2 D DD DB2 DB1 DD DB2 DB1",
            "D": "B1 B2 D DD DB1 DB2 DD DB1 DB2",
            "E": "D DD"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a înțelege ce va fi afișat pe ecran, să analizăm programul pas cu pas:\n\n1. **Constructori și Destructorii Clasei:**\n   - Constructorul `B1` afișează \"B1 \".\n   - Destructorul `B1` afișează \"DB1 \".\n   - Constructorul `B2` afișează \"B2 \".\n   - Destructorul `B2` afișează \"DB2 \".\n   - Constructorul `D` inițializează mai întâi `B2` (afișează \"B2 \"), apoi `B1` (afișează \"B1 \"), și în final afișează \"D \".\n   - Destructorul `D` afișează \"DD \".\n\n2. **Execuția în `main`:**\n   - Când `D d1;` este executat, constructorul lui `D` este"
        },
        {
          "id": 8,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B1 {\n    public:\n    B1(){cout<<\"B1 \";}\n    ~B1(){cout<<\"DB1 \";}\n};\nclass B2 {\n    public:\n    B2(){cout<<\"B2 \";}\n    ~B2(){cout<<\"DB2 \";}\n};\nclass D: public B1, public B2{\n    static int idGen;\n    int id;\n    public:\n    D():B2(),B1(){id=idGen++;cout<<\"D(\"<<id<<\") \";}\n    D(const D &o){id=idGen++;cout<<\"CD(\"<<id<<\") \";}\n    ~D(){cout<<\"DD \";}\n};\nint D::idGen = 0;\nvoid main(){\n    cout<<endl;\n    D d1;\n    D d2=d1;\n}",
          "options": {
            "A": "B1 B2 D(0) B1 B2 CD(1) DD DB2 DB1 DD DB2 DB1",
            "B": "B1 B2 D(0) DD DB2 DB1 DD DB2 DB1",
            "C": "B1 B2 D(0) DD DB2 DB1",
            "D": "B2 B1 D(0) B1 B2 CD(1) DD DB2 DB1 DD DB2 DB1",
            "E": "B1 B2 D(0) B2 B1 CD(1) DD DB2 DB1 DD DB2 DB1",
            "F": "rezultatul executiei nu poate fi determinat deoarce depinde de continul memoriei"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a determina ce va fi afișat pe ecran, trebuie să urmărim secvența de apeluri ale constructorilor și destructorilor.\n\n1. Când programul începe să execute `main()`, mai întâi se afișează un rând nou datorită `cout<<endl;`.\n\n2. Crearea obiectului `D d1` declanșează următoarea secvență:\n   - Constructorul `B2` este apelat primul datorită ordinii din lista de inițializare a clasei `D`: `B2()`.\n   - Constructorul `B1` este apelat următorul: `B1()`.\n   - Constructorul `D` este executat, care afișează `D(0)`, deoarece `idGen` începe de la 0 și apoi este incrementat.\n\n3. Crearea obiectului `D d2 = d..."
        },
        {
          "id": 9,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B1 {\n    public:\n    B1(){cout<<\"B1 \";}\n    ~B1(){cout<<\"DB1 \";}\n};\nclass B2 {\n    public:\n    B2(){cout<<\"B2 \";}\n    ~B2(){cout<<\"DB2 \";}\n};\nclass D: public B1, public B2{\n    public:\n    D():B2(),B1(){cout<<\"D \";}\n    D(const D &o){cout<<\"CD \";}\n    ~D(){cout<<\"DD \";}\n};\nvoid main(){\n    D *d1 = new D;\n    D *d2 = d1;\n    delete d1;\n}",
          "options": {
            "A": "B1 B2 D DD DB2 DB1",
            "B": "B1 B2 D DD DB2 DB1 DD DB2 DB1",
            "C": "B2 B1 D DD DB2 DB1",
            "D": "B2 B1 D DD DB2 DB1 DD DB2 DB1",
            "E": "B1 B2 D B1 B2 D DD DB2 DB1 DD DB2 DB1",
            "F": "B1 B2 D B1 B2 D DD DB2 DB1"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Programul demonstrează ordinea apelurilor constructorilor și destructorilor într-o ierarhie de clase cu moștenire multiplă.\n\n1. **Faza de Construcție:**\n   - Când obiectul `d1` este creat cu `new D`, constructorii sunt apelați în următoarea ordine:\n     - Constructorul `B2`: Deoarece lista de constructori `D():B2(),B1()` specifică `B2` primul, constructorul lui `B2` este apelat, afișând \"B2 \".\n     - Constructorul `B1`: Apoi, constructorul lui `B1` este apelat, afișând \"B1 \".\n     - Constructorul `D`: În cele din urmă, constructorul lui `D` este executat, afișând \"D \".\n   - Întreaga fază de construcție afișează:"
        },
        {
          "id": 10,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass A {\n    public:\n    A(){cout<<\"A()\";}\n    A(int n,int m=0){cout<<\"A(int,int)\";}\n    A(const A &o){cout<<\"A(const A&)\";}\n    ~A(){cout<<\"~A\";}\n};\nvoid main(){\n    cout<<endl;\n    A a1;\n    A a2=a1;\n    A a3=1;\n    A a4(1);\n    A a5(1,1);\n}",
          "options": {
            "A": "A()A(const A&)A(int,int)A(int,int)A(int,int)~A~A~A~A~A",
            "B": "A(const A&)A(const A&)A(int)A(int,int)A(int,int)~A~A~A~A~A",
            "C": "A()A(const A&)A(int,int)A(int,int)A(int,int)~A~A~A~A",
            "D": "A()A(const A&)A(int)A(int)A(int,int)~A~A~A~A~A",
            "E": "A()A()A(int,int)A(int)A(int,int)~A~A~A~A~A",
            "F": "Eroare de compilare la declararea obiectului a2 deoarece nu e supra incarcat operatorul =."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Codul C++ furnizat demonstrează comportamentul constructorilor și destructorilor într-o clasă. Iată o descriere a ceea ce se întâmplă în funcția `main`:\n\n1. `A a1;` - Această linie apelează constructorul implicit `A()`, afișând `A()`.\n\n2. `A a2 = a1;` - Această linie inițializează `a2` folosind constructorul de copiere deoarece `a1` este un obiect al aceleiași clase. Constructorul de copiere `A(const A &o)` este apelat, afișând `A(const A&)`.\n\n3. `A a3 = 1;` - Această linie încearcă să inițializeze `a3` folosind un număr întreg. Deoarece `A(int, int)` poate acționa ca un constructor de conversie datorită..."
        },
        {
          "id": 11,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B {\n    public:\n    virtual void f() { cout<<\"B::f() \";}\n    void g() { cout<<\"B::g() \";}\n};\nclass D1: public B{\n    public:\n    void f() { cout<<\"D1::f() \";}\n    void g() { cout<<\"D1::g() \";}\n};\nclass D2: public B{\n    public:\n    void g() { cout<<\"D2::g() \";}\n};\nvoid main(){\n    int i;\n    B *b[] = {new B(), new D1(), new D2()};\n    for (i=2;i>=0;i--) {b[i]->f();}\n    for (i=0;i<=2;i++) {b[i]->g();}\n}",
          "options": {
            "A": "B::f() D1::f() B::f() B::g() B::g() B::g()",
            "B": "D2::f() D1::f() B::f() B::g() B::g() B::g()",
            "C": "B::f() D1::f() D::f() B::g() D1::g() D2::g()",
            "D": "B::f() D1::f() B::f() B::g() D1::g() D2::g()",
            "E": "B::f() B::f() D2::f() B::g() B::g() D2::g()"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În programul dat, rezultatul este determinat de utilizarea funcțiilor virtuale și a suprascrierii funcțiilor în clasele derivate.\n\n1. **Funcția Virtuală `f()`:**\n   - Funcția `f()` din clasa `B` este declarată ca virtuală. Aceasta înseamnă că atunci când un pointer de tip `B*` indică un obiect al unei clase derivate, versiunea funcției `f()` care este apelată este determinată la momentul execuției, pe baza tipului real al obiectului.\n   - Când `b[2]->f()`, `b[1]->f()`, și `b[0]->f()` sunt apelate în buclă, ele se rezolvă la `B::f()`, `D1::f()`, și `B::f()` respectiv, deoarece:\n     - `b"
        },
        {
          "id": 12,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B {\n    public:\n    virtual void f() { cout<<\"B::f() \";}\n};\nclass D1: public B{\n    public:\n    void f() { cout<<\"D1::f() \";}\n};\nclass D2: public B{\n    public:\n    void f() { cout<<\"D2::f() \";}\n};\nvoid main(){\n    int i;\n    B b[] = { B(), D1(), D2()};\n    for (i=2;i>=0;i--) {b[i].f();}\n}",
          "options": {
            "A": "B::f() B::f() B::f()",
            "B": "D2::f() D1::f() B::f()",
            "C": "B::f() D1::f() D2::f()",
            "D": "B::f() D1::f() D2::f()"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A. Iată explicația:\n\nÎn programul C++ dat, avem o clasă de bază `B` cu o funcție virtuală `f()`, și două clase derivate `D1` și `D2`, fiecare suprascriind funcția `f()`. În funcția `main`, un tablou de obiecte de tip `B` este inițializat cu obiecte de tip `B`, `D1` și `D2`.\n\nTotuși, deoarece tabloul `b` este de tip `B`, când tabloul este inițializat, fiecare obiect al clasei derivate (`D1` și `D2`) este redus la un obiect al clasei de bază `B`. Acest fenomen este cunoscut sub numele de \"tăierea obiectului\", unde părțile derivate ale obiectului sunt eliminate, lăsând doar părțile clasei de bază."
        },
        {
          "id": 13,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B {\n    protected:\n    int x;\n    public:\n    B(int x=0){this->x=x;}\n    virtual void f() {x=x+1;}\n    void print(){cout<<x<<\" \";}\n};\nclass D1: public B{\n    public:\n    void f() {x=x+5;}\n};\nclass D2: public B{\n    public:\n    void f() {x=x+2;}\n};\nvoid main(){\n    int i;\n    B *b[] = { new B(2), new D1(), new D2(), new B};\n    for (i=3;i>0;i--) (*b[i]).f();\n    for (i=0;i<=3;i++) b[i]->print();\n}",
          "options": {
            "A": "2 5 2 1",
            "B": "2 0 0 0",
            "C": "3 5 2 1",
            "D": "2 1 1 1",
            "E": "2 5 2 0",
            "F": "2 5 2",
            "G": "Eroare de compilare"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a determina ce va afișa programul, să analizăm codul pas cu pas:\n\n1. **Definiții de clase:**\n   - `B` este o clasă de bază cu un membru întreg `x`, inițializat prin constructorul său. Are o funcție virtuală `f()` care incrementează `x` cu 1 și o funcție `print()` care afișează valoarea lui `x`.\n   - `D1` și `D2` sunt clase derivate din `B`. `D1` suprascrie `f()` pentru a crește `x` cu 5, iar `D2` suprascrie `f()` pentru a crește `x` cu 2.\n\n2. **Funcția principală:**\n   - Se creează un array de pointeri către obiecte de tip `B`, inițializat cu:"
        },
        {
          "id": 14,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B {\n    int x;\n    public:\n    B(int x=0){this->x=x;}\n    virtual void f() {x=x+1;}\n    void print(){cout<<x<<\" \";}\n};\nclass D1: public B{\n    public:\n    void f() {x=x+5;}\n};\nclass D2: public B{\n    public:\n    void f() {x=x+2;}\n};\nvoid main(){\n    int i;\n    B *b[] = { new B(2), new D1(), new D2(), new B};\n    for (i=3;i>0;i--) (*b[i]).f();\n    for (i=0;i<=3;i++) b[i]->print();\n}",
          "options": {
            "A": "2 5 2 1",
            "B": "2 0 0 0",
            "C": "3 5 2 1",
            "D": "2 1 1 1",
            "E": "2 5 2 0",
            "F": "2 5 2",
            "G": "Eroare de compilare"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a determina ce va afișa programul, trebuie să analizăm codul pas cu pas, concentrându-ne pe clase și apelurile de metode.\n\n1. **Definirea claselor și inițializarea:**\n   - Clasa `B` are un constructor implicit care inițializează `x` și o funcție virtuală `f()` care incrementează `x` cu 1.\n   - `D1` și `D2` sunt derivate din `B` și suprascriu `f()`, modificând `x` prin adăugarea a 5 și, respectiv, 2.\n\n2. **Array de pointeri:**\n   - `b[]` este un array de pointeri către obiecte de tip `B`, inițializat cu:\n     - `new B(2)`: Un obiect `B` cu `x`"
        },
        {
          "id": 15,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program:\n\n#include <iostream.h>\nclass B {\n    int x;\n    static int y;\n    public:\n    B(int x=0){this->x=x;}\n    void setX(int vx) {x=vx;}\n    void setY(int vy) {y=vy;}\n    void print(){cout<<x<<\" \"<<y<<\" \";}\n};\nint B::y=0;\nvoid main(){\n    B b1=3;\n    B b2(4);\n    b1.print(); b2.print();\n    b1.setX(5); b2.setY(2);\n    b1.print(); b2.print();\n}",
          "options": {
            "A": "3 0 4 0 5 2 4 2",
            "B": "3 0 4 0 5 0 4 2",
            "C": "3 4 5 2 4 2",
            "D": "3 3 4 4 5 2 4 2",
            "E": "3 0 4 0 5 2 5 2",
            "F": "3 0 4 0 5 0 2 0"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Programul constă într-o clasă `B` care are o variabilă membru non-statică `x` și o variabilă membru statică `y`. Membrul static `y` este împărțit între toate instanțele clasei, în timp ce fiecare instanță are propria sa copie a lui `x`.\n\n1. Două obiecte ale clasei `B`, `b1` și `b2`, sunt create cu valorile inițiale 3 și respectiv 4 pentru `x`. Variabila statică `y` este inițializată la 0 la început și este împărțită între `b1` și `b2`.\n\n2. Când `b1.print()` și `b2.print()` sunt apelate inițial, ele afișează valorile lui `x` și `y` pentru fiecare obiect. Deoarece"
        },
        {
          "id": 16,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <iostream.h>\nstruct A{\n    int x;\n    operator double() {\n        return 21.4;\n    }\n};\nvoid main(){\n    A a;\n    a.x = 11;\n    cout << (0?3:a);\n}",
          "options": {
            "A": "21",
            "B": "21.4",
            "C": "3",
            "D": "11",
            "E": "programul nu se compileaza"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În programul dat, operatorul ternar condițional `(0 ? 3 : a)` este utilizat. Condiția `0` este evaluată ca fiind falsă, așa că expresia se evaluează la `a`. Structura `A` are un operator de conversie definit de utilizator `operator double()`, care permite ca un obiect de tip `A` să fie convertit implicit la un tip `double`. Totuși, instrucțiunea `cout` încearcă să afișeze valoarea lui `a` direct. Deoarece `cout` nu poate gestiona direct un tip definit de utilizator precum `A`, operatorul de conversie este invocat, convertind `a` la un `double`, care este `21.4`. Dar, deoarece instrucțiunea `cout` afișează valorile de tip `double` ca întregi în mod implicit, aceasta trunchiază."
        },
        {
          "id": 17,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <iostream.h>\nstruct A {\n    A(int d) : x(d) {}\n    int x;\n};\nvoid main(){\n    double x = 3.14;\n    A f( int(x) );\n    cout << f.x << endl;\n}",
          "options": {
            "A": "nimic (eroare de compilare)",
            "B": "0",
            "C": "3",
            "D": "3.14",
            "E": "depinde de implementarea compilatorului"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A: nimic (eroare de compilare).\n\nExplicație: Programul conține câteva probleme care duc la o eroare de compilare. În primul rând, fișierul header `<iostream.h>` nu face parte din biblioteca standard C++; în schimb, headerul corect este `<iostream>`. De asemenea, programul folosește semnătura funcției `void main()`, care nu este standard în C++. Semnătura standard pentru funcția main ar trebui să fie `int main()`.\n\nMai mult, programul încearcă să folosească `cout` fără a specifica namespace-ul `std::` sau fără a folosi directiva `using namespace std;`. Aceste probleme combinate duc la o eroare de compilare, împiedicând programul să ruleze și să afișeze orice rezultat."
        },
        {
          "id": 18,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <iostream.h>\nint f(int x, int y = x) {\n    return x+y+1;\n}\nvoid main(){\n    cout << f(2);\n}",
          "options": {
            "A": "nimic (eroare de compilare)",
            "B": "1",
            "C": "3",
            "D": "5",
            "E": "depinde de implementarea compilatorului"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A: nimic (eroare de compilare).\n\nExplicație: Programul dat va rezulta într-o eroare de compilare din cauza utilizării unui argument implicit care depinde de un alt parametru al aceleiași funcții. În definiția funcției `int f(int x, int y = x)`, argumentul implicit `y = x` nu este valid deoarece `x` nu este o expresie constantă și valoarea sa nu este cunoscută în momentul în care argumentul implicit este setat. În C++, argumentele implicite trebuie să fie constante sau expresii care nu se bazează pe alți parametri ai aceleiași funcții. Din cauza acestei încălcări a regulii, programul nu va fi compilat, conducând la o eroare."
        },
        {
          "id": 19,
          "text": "Ce se va afisa pe ecran in urma executiei urmatorului program?\n\n#include <iostream.h>\nstruct A {\n    virtual int f(int x = 5){\n        return x * 2;\n    }\n};\nstruct B : public A{\n    int f(int x = 10) {\n        return x * 3;\n    }\n};\nvoid main(){\n    A* a = new B;\n    cout << a->f();\n}",
          "options": {
            "A": "15",
            "B": "10",
            "C": "20",
            "D": "3",
            "E": "nimic (eroare de compilare)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Programul demonstrează conceptul de funcții virtuale și parametri impliciți în C++. În codul dat, `A` este o clasă de bază cu o funcție virtuală `f` care are o valoare implicită a parametrului de `5`. Clasa `B` moștenește din `A` și suprascrie funcția `f` cu propria sa valoare implicită a parametrului de `10`.\n\nÎn funcția `main`, un obiect de tip `B` este creat și atribuit unui pointer de tip `A*`. Când funcția `f` este apelată prin acest pointer (`a->f()`), se rezolvă la versiunea suprascrisă a lui `f` din `B` datorită polimorfismului dinamic (mecanismul funcției virtuale). Totuși, în C++, argumentele implicite sunt determinate de tipul static."
        },
        {
          "id": 20,
          "text": "Fie secventa de program:\n\nclass A {\n    private:\n    int x,y;\n    public:\n    A(){x=0;y=0; }\n    A(int xi,int yi){\n        x=xi;y=yi;\n    }\nvoid afis(){\n    cout <<x ” ” << y;\n}\n};\nvoid main(){\n    A A1,A2(10,20);\n    A1.afis();\n    A2.afis();\n}\nCare din urmatoarele afirmatii sunt adevarate:",
          "options": {
            "A": "Metoda afis() este incorect definita",
            "B": "Constructorul este incorect definit",
            "C": "Declaratie incorecta pentru obiectul A1",
            "D": "Programul afiseaza valorile (10 20 0 0 )",
            "E": "Programul afiseaza valorile (0 0 10 20 )"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Explicație:\n\nÎn programul C++ dat, există o clasă `A` cu doi membri întregi privați, `x` și `y`, și doi constructori. Constructorul implicit inițializează atât `x`, cât și `y` la 0, în timp ce constructorul cu parametri îi inițializează la `xi` și `yi`, respectiv. Metoda `afis()` este definită corect pentru a afișa valorile lui `x` și `y`.\n\nÎn funcția `main`, sunt create două obiecte ale clasei `A`: `A1` folosind constructorul implicit și `A2` folosind constructorul cu parametri cu valorile 10 și 20. Când `A1.afis()` este apelat, acesta afișează `0 0` deoarece `"
        },
        {
          "id": 21,
          "text": "Fie secventa de program:\n\nclass C{\n    public:\n    C(){n++;}\n    static int index(){return n;}\n    private:\n    static int n;\n};\nint C :: n = 0;\nclass A{\n    private:\n    C c;\n    int a;\n};\nclass B{\n    public:\n    B(int i = 0) :b(i)\n    {cout <<C :: index() <<” ”;}\n    private:\n    A a;\n    C c;\n    int b;\n};\nvoid main(){\n    A a1;\n    cout <<C :: index() <<’ ’;\n    B b1[3];\n}\nRezultatul executiei programului este:",
          "options": {
            "A": "1 2 3 4",
            "B": "1 3 4 5",
            "C": "1 7 3 4",
            "D": "1 3 5 7",
            "E": "0 1 2 3"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Pentru a înțelege răspunsul corect, să descompunem execuția programului:\n\n1. Membrul static `n` al clasei `C` este inițializat la 0 (`int C::n = 0;`).\n\n2. În funcția `main()`, un obiect `a1` al clasei `A` este creat. Clasa `A` conține un membru `c` de tip `C`. Prin urmare, construirea lui `a1` apelează constructorul clasei `C`, incrementând `n` cu 1. Astfel, `n` devine 1.\n\n3. Instrucțiunea `cout << C::index() << ' ';` afișează valoarea curentă a lui `n`, care este 1.\n\n4. Următorul, un array `b1`"
        },
        {
          "id": 22,
          "text": "Se considera secventa de program:\n\nclass C {\n    private:\n    int x,y;\n    public:\n    C(int xi,int yi){ x=xi;y=yi; }\n    C(const C &a){\n        x=a.x;y=a.y;\n    }\n};\nIn care din urmatoarele situatii se realizeaza copierea unui obiect in altul:",
          "options": {
            "A": "C c1(4,5)",
            "B": "C c2(0.0, 0,0)",
            "C": "C c3=c1",
            "D": "C c4(1)",
            "E": "C c5(c1)"
          },
          "correct_answer": [
            "C",
            "E"
          ],
          "explanation": "În clasa `C` dată, există un constructor de copiere definit, care permite copierea unui obiect într-altul. Acest constructor de copiere este apelat în situații specifice în care un obiect trebuie să fie inițializat folosind un alt obiect din aceeași clasă.\n\n- **Opțiunea A (`C c1(4,5)`)**: Creează un obiect folosind constructorul cu doi parametri întregi. Nu este implicată copierea, ci inițializarea directă. Constructorul de copiere nu este apelat.\n\n- **Opțiunea B (`C c2(0.0, 0, 0)`)**: Este o declarație eronată. Constructorul așteaptă doi parametri `int`, dar sunt furnizate trei valori (inclusiv un `double`), ceea ce nu corespunde niciunui constructor definit. Această linie ar genera o eroare la compilare.\n\n- **Opțiunea C (`C c3 = c1`)**: Acesta este un caz clasic de inițializare prin copiere. Obiectul `c3` este creat prin copierea lui `c1`, ceea ce duce la apelarea constructorului de copiere.\n\n- **Opțiunea D (`C c4(1)`)**: Constructorul disponibil necesită doi parametri `int`. Deoarece este furnizat doar unul, iar nu există constructor cu un singur parametru, această linie ar produce o eroare de compilare.\n\n- **Opțiunea E (`C c5(c1)`)**: Aceasta este forma clasică de apelare a constructorului de copiere. Obiectul `c5` este creat prin copierea lui `c1`, deci constructorul de copiere este folosit.\n\nPrin urmare, **constructorul de copiere este apelat doar în opțiunile C și E**, ceea ce face ca acestea să fie răspunsurile corecte."
        },
        {
          "id": 23,
          "text": "Se considera secventa de program:\n\nclass Punct {\n    private:\n    double x,y;\n    public:\n    Punct(double xi,double yi){\n        x=xi;y=yi;\n    }\n};\nIn care din urmatoarele situatii se realizeaza copierea unui obiect:",
          "options": {
            "A": "Punct P1(10,20)",
            "B": "Punct P2(P1(3))",
            "C": "Punct P3",
            "D": "Punct P4=P1",
            "E": "Punct P5(P1)"
          },
          "correct_answer": [
            "D",
            "E"
          ],
          "explanation": "În secvența de cod dată, clasa `Punct` are un constructor care inițializează membrii săi privați `x` și `y` folosind parametrii `xi` și `yi`.\n\nSă analizăm fiecare opțiune:\n\nA. `Punct P1(10,20)` - Aceasta creează un nou obiect `P1` folosind constructorul cu valorile `x` și `y` ca `10` și `20`, respectiv. Nu are loc nicio copiere aici; este o inițializare directă.\n\nB. `Punct P2(P1(3))` - Această linie este incorectă din punct de vedere sintactic. `P1(3)` sugerează un apel de funcție, ceea ce este invalid deoarece `P1` nu este apelabil. Prin urmare, această opțiune nu implică copiere."
        },
        {
          "id": 24,
          "text": "Se da programul :\n\nclass P {\n    double x,y;\n    public:\n    P(double x1 = 0,double y1 = 0){\n        x=x1;y=y1;\n    }\nvoid afis(){\n    cout <<x <<” ” << y;\n}\nP operator++ (){\n    ++x;++y;\n    return *this;\n}\n};\nvoid main(){\n    P p1(1,2),p2;\n    p2=++p1;\n    p2.afis();\n}\nCare din afirmatiile urmatoare sunt corecte:",
          "options": {
            "A": "Obiectul p2 nu poate fi instantiat",
            "B": "Asignarea p2=++p1 este incorecta",
            "C": "In program se realizeaza supraancarcarea operatorului prefix de incrementare",
            "D": "Programul va afisa valorile: 23",
            "E": "Programul afiseaza valorile lui p1"
          },
          "correct_answer": [
            "C",
            "D"
          ],
          "explanation": "Iată traducerea textului în limba română:\n\nÎn programul C++ dat, avem o clasă `P` care include un constructor, o metodă `afis` pentru afișarea valorilor și un operator de incrementare prefix supraîncărcat (`operator++`). Iată o detaliere a răspunsurilor corecte:\n\n- **C. În program se realizează supraîncărcarea operatorului prefix de incrementare:**\n  - Această afirmație este corectă. Programul supraîncarcă operatorul de incrementare prefix `++` pentru obiectele clasei `P`. Metoda `operator++` mărește atât `x`, cât și `y` cu 1 și returnează obiectul incrementat.\n\n- **D. Programul va afișa valorile: 23:**\n  - Această afirmație este, de asemenea, corectă. Inițial, `p1` este instanțiat."
        },
        {
          "id": 25,
          "text": "Se da programul :\n\nclass A {\n    int x,y;\n    public:\n    A(int xi = 0, int yi=0){\n        x=xi;y=yi;\n    }\nvoid afis(){\n    cout <<” x” << y;\n}\nA operator+ (A o2);\nfriend A operator++ (A &a);\n};\nA A::operator+ (A o2){\n    A temp;\n    temp.x=x+o2.x;\n    temp.y=y+o2.y;\n    return temp;\n}\nA operator++ (A &a){\n    ++a.x;++a.y;\n    return a;\n}\nvoid main(){\n    A a1(20,30),a2(2,2),a3;\n    a3=++a1+a2;\n    a3.afis();\n}\nCare din afirmatiile urmatoare sunt corecte:",
          "options": {
            "A": "Utilizarea cuvantului predefinit ” friend ” nu este permisa in acest context",
            "B": "Functia operatorului ++ nu este definita corect",
            "C": "Programul va afisa valorile: 23 33",
            "D": "Atribuirea a3=++a1+a2 este incorecta",
            "E": "programul va afisa valorile: 22 32"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a înțelege răspunsul corect, să analizăm programul și opțiunile de întrebări:\n\n1. **Cuvântul cheie Friend:** \n   - Cuvântul cheie `friend` este utilizat corect. Acesta permite funcției externe `operator++` să acceseze membrii privați ai clasei `A`.\n\n2. **Funcția Operator++:** \n   - Funcția `operator++` este definită ca o funcție prieten, care incrementează valorile `x` și `y` din obiectul `a` și returnează obiectul modificat. Este definită corect pentru utilizarea intenționată.\n\n3. **Ieșirea programului:**\n   - În funcția `main`, `a1` este inițializat cu valorile (20, 30).\n   - Expresia `++a1` incrementează"
        },
        {
          "id": 26,
          "text": "Supra incarcarea unor operatori se poate realiza prin functii operator sau functii friend. Diferenta consta in:",
          "options": {
            "A": "Precedenta operatorilor",
            "B": "Asociativitatea operatorilor",
            "C": "Obiectul returnat",
            "D": "Lista de parametri",
            "E": "Numarul parametrilor din lista functiei"
          },
          "correct_answer": [
            "D",
            "E"
          ],
          "explanation": "În programarea C++, supraîncărcarea operatorilor îți permite să definești cum funcționează operatorii cu tipuri definite de utilizator. Acest lucru poate fi realizat fie prin funcții membru (funcții operator), fie prin funcții prietene. Diferențele cheie dintre aceste două abordări constau în modul în care sunt gestionate parametrii:\n\nD. Lista de parametri: O funcție membru care supraîncarcă un operator ia operandul din stânga (de obicei obiectul clasei) implicit ca `*this`, iar operandul din dreapta ca parametru explicit. În contrast, o funcție prieten tratează ambii operanzi ca parametri expliciți, necesitând o listă de parametri diferită.\n\nE. Numărul parametrilor din lista funcției: Acest aspect se leagă direct de lista de parametri; o funcție membru pentru operatorii binari ia un parametru explicit, în timp ce o funcție prieten necesită doi parametri."
        },
        {
          "id": 27,
          "text": "Se considera secventa:\n\nclass A {\n    int a[3];\n    public:\n    A(int xi, int yi, int zi ){\n        a[0]=xi;a[1]=yi;a[2]=zi;\n    }\nint &operator[](int i){\n    return a[i];\n}\n};\nvoid main() {\n    A o(1, 2, 3);\n    cout<<o[0];\n    o[1]=10;\n    cout<<o[1];\n}\nCe se poate afirma despre operator[]()?",
          "options": {
            "A": "Supraincarca operatorul()",
            "B": "Supraincarca un operator unar",
            "C": "Este o metoda oarecare a clasei care nu produce supra incarcarea unor operatori",
            "D": "Este un constructor",
            "E": "Supraincarca operatorul[]"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Răspunsul corect este E.\n\nExplicație: În C++, funcția `operator[]` dintr-o clasă îți permite să definești cum se comportă operatorul de indexare `[]` pentru obiectele acelei clase. Acest lucru este cunoscut sub numele de supraîncărcare a operatorului, unde oferi o implementare personalizată pentru un operator. În codul dat, `operator[]` este supraîncărcat pentru a oferi acces la elementele tabloului privat `a` din cadrul clasei `A`. Acest lucru îți permite să folosești operatorul de indexare pe o instanță a clasei `A` ca și cum ar fi un tablou, permițând expresii precum `o[0]` și `o[1]`. Prin returnarea unei referințe (`int &`), permite de asemenea modificarea directă a elementelor, așa cum este arătat cu"
        },
        {
          "id": 28,
          "text": "Se considera secventa:\n\nclass B{\n    int a;\n    protected:\n    int b;\n    public:\n    int c;\n    void set a(int x){a = x;}\n    void set b(int y){b = y;}\n    void set c(int z){c = z;}\n};\nclass D : public B{ int d;\n    public:\n    void set b(int y) {b = y;}\n    void set c(int z) {c = z;}\n};\nvoid main(){\n    D o;\n    o.a = 1; //(1)\n    o.B::set a(2); //(2)\n    o.b = 3; //(3)\n    o.B::set b(4); //(4)\n    o.c = 5; //(5)\n}\nCare din instructiunile (1)-(5) acceseaza corect membrii claselor:",
          "options": {
            "A": "Toate",
            "B": "(1), (2) si (5)",
            "C": "(1), (3) si(4)",
            "D": "(1), (2), (3), (4)",
            "E": "(2), (4) si (5)"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Pentru a înțelege care instrucțiuni accesează corect membrii clasei, să examinăm codul și modificatorii de acces utilizați:\n\n1. **Instrucțiunea (1)**: `o.a = 1;`\n   - Membrul `a` este privat în clasa `B`, ceea ce înseamnă că nu poate fi accesat direct din afara clasei. Prin urmare, această instrucțiune este incorectă.\n\n2. **Instrucțiunea (2)**: `o.B::set a(2);`\n   - Aceasta folosește metoda `set a` pentru a modifica membrul privat `a`. Este corect să folosească metoda clasei pentru a accesa membrul privat, deci este corectă.\n\n3. **Instrucțiunea (3)**: `o.b = 3;`\n   - Membrul `b` este protejat în clasa `B`."
        },
        {
          "id": 29,
          "text": "In programul urmator, care din instructiunile (1)-(5) acceseaza corect membrii claselor:\n\nclass B{\n    int a;\n    protected:\n    int b;\n    public:\n    int c;\n    void set a(int x){a = x;}\n    void set b(int y){b = y;}\n    void set c(int z){c = z;}\n};\nclass D : protected B{\n    int d;\n    public:\n    void set b(int y) {b = y;}\n    void set c(int z) {c = z;}\n};\nvoid main(){\n    D o;\n    o.a = 1; //(1)\n    o.B::set a(2); //(2)\n    o.b = 3; //(3)\n    o.B::set b(4); //(4)\n    o.c = 5; //(5)\n}",
          "options": {
            "A": "Toate",
            "B": "Nici una",
            "C": "Numai (5)",
            "D": "(2), (4) si (5)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În codul dat, avem două clase: `B` și `D`. Clasa `D` moștenește clasa `B` folosind moștenire protejată. Să analizăm fiecare instrucțiune:\n\n1. `o.a = 1;` - Aceasta este incorectă deoarece `a` este un membru privat al clasei `B` și nu poate fi accesat direct dintr-un obiect al clasei `D`.\n\n2. `o.B::set a(2);` - Aceasta este incorectă deoarece metoda `set a` nu este definită corect în clasa `B` (ar trebui să fie `void set_a(int x)`), și chiar dacă ar fi, `a` este privat și nu poate fi accesat prin moștenire.\n\n3. `o.b = 3;` - Aceasta"
        },
        {
          "id": 30,
          "text": "In programul urmator, care din instructiunile (1)-(6) acceseaza corect membrii claselor:\n\nclass B{\n    int a;\n    protected:\n    int b;\n    public:\n    int c;\n    void set a(int x){a = x;}\n    void set b(int y){b = y;}\n    void set c(int z){c = z;}\n};\nclass D : private B{\n    int d;\n    public:\n    void set b(int y) {b = y;}\n    void set c(int z) {c = z;}\n};\nvoid main(){\n    D o;\n    o.a = 1; //(1)\n    o.B::set a(2); //(2)\n    o.b = 3; //(3)\n    o.B::set b(4); //(4)\n    o.c = 5; //(5)\n    o.set c(6); //(6)\n}",
          "options": {
            "A": "(1) si (4)",
            "B": "(2), (3), (4)",
            "C": "Toate",
            "D": "(6)"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "În programul dat, clasa `D` moștenește în mod privat clasa `B`, ceea ce înseamnă că toți membrii clasei `B` devin privați în `D`. Iată o analiză a accesului în fiecare instrucțiune:\n\n1. **(1) `o.a = 1;`** - Aceasta este incorectă deoarece `a` este un membru privat al clasei `B` și nu poate fi accesat direct dintr-un obiect al clasei `D`.\n2. **(2) `o.B::set a(2);`** - Aceasta este incorectă deoarece `set a` nu este o funcție validă din cauza unei erori de sintaxă (ar trebui să fie `set_a` dacă ar fi definită). De asemenea, `a` este privat.\n3. **(3) `o.b ="
        }
      ]
    },
    {
      "name": "Tehnologii Java",
      "questions": [
        {
          "id": 1,
          "text": "Fie urmatoarea declaratie Java:\n\npublic private int h;\n\nCare afirmatii sunt adevarate:",
          "options": {
            "A": "Variabila h va fi accesata in mod public, deoarece se ia in considerare primul modificator de acces;",
            "B": "Variabila h va fi accesata in mod private,deoarece se ia in considerare ultimul modificator de acces;",
            "C": "Va fi eroare la compilare deoarece o variabila nu poate fi  in acelasi timp accesata public si private;",
            "D": "Nici una din variantele de mai sus;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "În Java, o variabilă nu poate avea simultan doi modificatori de acces contradictorii, cum sunt \"public\" și \"private\". Modificatorii de acces definesc vizibilitatea și accesibilitatea unui membru al clasei, iar fiecare membru poate avea doar un singur modificator de acces. În cazul prezentat în întrebare, încercarea de a declara o variabilă cu ambii modificatori, \"public\" și \"private\", va genera o eroare de compilare, deoarece este o construcție invalidă în Java. Așadar, răspunsul corect este C: va fi eroare la compilare."
        },
        {
          "id": 2,
          "text": "Fie urmatorul cod Java:\n\nint x=0;\nif (Double.isInfinite(2/x))\nSystem.out.println(\"Infinit\");\nelse\nSystem.out.println(\"2/0\");\n\nCe puteti spune despre acest cod, daca este integrat in cadrul unui program Java?",
          "options": {
            "A": "Va produce eroare la compilare din cauza impartirii la 0;",
            "B": "Va produce eroare la executie din cauza impartirii la 0 (se arunca o exceptie: \"ArithmeticExpetion\");",
            "C": "Codul este corect si va afisa Infinit;",
            "D": "Codul este corect si va afisa NaN;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În Java, împărțirea unui număr întreg la zero rezultă într-o excepție aritmetică. În codul dat, `2/x` implică împărțirea lui 2 la întregul `x`, care este inițializat cu valoarea 0. Când această împărțire la zero are loc, Java aruncă o `ArithmeticException` în timpul execuției. Metoda `Double.isInfinite()` nici măcar nu este apelată deoarece excepția întrerupe fluxul de execuție. Prin urmare, opțiunea B este corectă deoarece codul va produce o eroare la rulare din cauza împărțirii la zero, aruncând specific o `ArithmeticException`."
        },
        {
          "id": 3,
          "text": "Fie urmatorul program Java:\n\npublic class Program{\n    static void f(int k){\n        switch(k){\n            default: System.out.print(\"i \"); break;\n            case 1: System.out.print(\"1 \"); break;\n            case 2: case 3: System.out.print(\"23 \"); break;\n            case 4: case 5: System.out.print(\"45 \");\n        }\n}\npublic static void main(String []args){\n    for(int i=0;i<6;i++)\n    f(i);\n}\n}\n\nCare afirmatii sunt adevarate?",
          "options": {
            "A": "Programul produce eroare la compilare;",
            "B": "Programul se compileaza si la executie afiseaza\ni 1 23 23 45 45 ;",
            "C": "Programul se compileaza si la executie afiseaza\ni 1 23 45 ;",
            "D": "Programul se compileaza si la executie afiseaza\ni 1 23 23 45 45 i;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Programul Java furnizat folosește o instrucțiune `switch` pentru a gestiona diferite cazuri pentru variabila întreagă `k`. Când metoda `main` este executată, aceasta rulează un ciclu de la `i = 0` la `i = 5`, apelând metoda `f(i)` în fiecare iterație.\n\nIată cum operează instrucțiunea `switch` pentru fiecare valoare a lui `k`:\n\n1. Pentru `k = 0`: Nu există un `case` pentru 0, așa că se execută cazul `default`, afișând \"i \".\n2. Pentru `k = 1`: Se potrivește `case 1`, afișând \"1 \".\n3. Pentru `k = 2`: Se potrivește `case 2` (comportament de cădere în gol)."
        },
        {
          "id": 4,
          "text": "Fie urmatorul cod Java:\n\nbyte b=-7 >>> 1;\nSystem.out.println(b);\n\nCe se poate spune despre acest cod, daca este integrat intr-un program Java?",
          "options": {
            "A": "Va produce eroare la compilare;",
            "B": "Va produce eroare la executie;",
            "C": "Programul se compileaza si la executie afiseaza -3;",
            "D": "Programul se compileaza si la executie afiseaza -4;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A. Iată explicația:\n\nÎn Java, operatorul `>>>` este operatorul de deplasare la dreapta fără semn, ceea ce înseamnă că deplasează biții spre dreapta și completează biții din stânga cu zerouri, indiferent de semnul numărului original. Totuși, acest operator funcționează doar cu tipurile `int` și `long`. În codul dat, `b` este declarat ca un `byte`. Expresia `-7 >>> 1` implică o promovare implicită a tipului lui `-7` la `int` înainte ca operația de deplasare să fie aplicată. Ca rezultat, operația `-7 >>> 1` produce un `int`, nu un `byte`. Atribuirea rezultatului de tip `int` înapoi la un `byte`..."
        },
        {
          "id": 5,
          "text": "Ce puteti afirma despre urmatorul program Java?\n\npublic class Static1{\n    public static void main(String []args){\n        Static2 a=new Static2();\n        Static2 b=new Static2();\n        System.out.print(\"a.x= \"+ a.x);\n        a.x=100; b.x=200;\n        System.out.print(\"a.x= \"+a.x);\n    }\n}\nclass Static2{\n    static int x=0;\n    Static2()\n    {\n        x++;\n    };\n}",
          "options": {
            "A": "Afiseaza: a.x=2 a.x=200;",
            "B": "Afiseaza: a.x=0 a.x=100;",
            "C": "Afiseaza: a.x=1 a.x=100;",
            "D": "Programul nu este corect deoarece asignarea lui x, conform obiectului b, este ilegala in Java;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A. Explicația se bazează pe utilizarea cuvântului cheie `static` în Java. Variabila `x` din clasa `Static2` este declarată ca o variabilă statică, ceea ce înseamnă că este partajată între toate instanțele clasei. Orice modificare a acestei variabile printr-o instanță este vizibilă pentru toate celelalte instanțe ale clasei.\n\nIată o descriere pas cu pas a ceea ce se întâmplă în program:\n\n1. Când `Static2 a = new Static2();` este executat, constructorul clasei `Static2` este apelat și incrementează `x` de la 0 la 1.\n\n2. Când `Static2 b = new Static2();` este apelat, constructorul este din nou executat, iar `x` devine 2.\n\n3. Apoi se execută `System.out.print(\"a.x= \"+ a.x);`, care afișează `a.x= 2`, deoarece `x` este static și are valoarea 2 după cele două instanțieri.\n\n4. Se modifică valorile: `a.x = 100;` și apoi `b.x = 200;`. Deoarece `x` este static, ambele modificări afectează aceeași variabilă `x` partajată. A doua atribuire (`b.x = 200`) va suprascrie valoarea stabilită de `a.x = 100`.\n\n5. Se afișează din nou: `System.out.print(\"a.x= \"+a.x);`, care va afișa `a.x= 200`, pentru că `x` a fost setat ultima dată la 200, iar `a.x` și `b.x` se referă la aceeași variabilă statică.\n\nPrin urmare, programul afișează: `a.x= 2a.x= 200`, ceea ce corespunde opțiunii **A**."
        },
        {
          "id": 6,
          "text": "Ce se va afisa la executia urmatorului program Java?\n\ninterface I1{\n    float x=2.3f;\n}\npublic class Test implements I1{\n    public static void main(String [] args){\n        System.out.print(x+\" \");\n        x=6.7f;\n        System.out.print(x);\n    }\n}",
          "options": {
            "A": "Va aparea eroare la compilare deoarece valoarea variabilei x nu se mai poate modifica;",
            "B": "La executie se va afisa:\n2.3f 6.7f;",
            "C": "La executie se va afisa:\n2.3f 2.3f;",
            "D": "La executie se va afisa:\n2.3 6.7;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A. În Java, câmpurile definite într-o interfață sunt implicit `public`, `static` și `final`. Aceasta înseamnă că variabila `x` din interfața `I1` este o constantă și nu poate fi modificată. Când programul încearcă să atribuie o nouă valoare lui `x` (`x = 6.7f;`), rezultă o eroare de compilare deoarece `x` este `final` și nu poate fi reasignat. Prin urmare, programul nu se va compila și va apărea o eroare la linia unde codul încearcă să schimbe valoarea lui `x`."
        },
        {
          "id": 7,
          "text": "Ce puteti spune despre urmatorul program Java?\n\nclass C1{\n    int x=1;\n    void f(int x){\n        this.x=x;\n    }\nint getX_C1(){\n    return x;\n}\n}\nclass C2 extends C1{\n    float x=5.0f;\n    int f(int x){\n        super.f((int)x);\n    }\nfloat getX_C2(){\n    return x;\n}\n}\npublic class Subiect9{\n    public static void main(String []args){\n        C2 obiect = new C2();\n        obiect.f(4);\n        System.out.print(obiect.getX_C2() + \" \");\n        System.out.println(obiect.getX_C1());\n    }\n}",
          "options": {
            "A": "Programul este corect si va afisa la executie 5 4;",
            "B": "Programul este corect si va afisa la executie 4.0 4;",
            "C": "Va aparea eroare la compilare deoarece in clasa C2 s-a suprascris gresit atributul x din clasa C1;",
            "D": "Va aparea eroare la compilare deoarece metoda suprascrisa f() din clasa C2  intoarce un tip diferit de void;"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Răspunsul corect este D. Programul va genera o eroare de compilare deoarece metoda `f(int x)` din clasa `C2` are un tip de returnare diferit față de omologul său suprascris din clasa `C1`. În Java, atunci când suprascrii o metodă, tipul de returnare trebuie să rămână același ca în superclasă, cu excepția cazului în care tipul de returnare este covariant (adică tipul de returnare poate fi o subclasă a tipului de returnare original). În acest caz, `void` și `int` nu sunt tipuri de returnare compatibile, așa că rezultă într-o eroare de compilare."
        },
        {
          "id": 8,
          "text": "Ce puteti spune despre urmatorul program Java?\n\npublic class Test{\n    public static void main(String []args){\n        C1 obiect =new C1();\n        obiect.f(4,3);\n    }\n}\nclass C1{\n    public void f(int xx, final int yy){\n        int a=xx+yy;\n        final int b=xx-yy;\n        class C2{\n            public void g(){\n                System.out.print(\"a= \"+a);\n                System.out.print(\", b= \"+b);\n            }\n    }\nC2 obiect2 = new C2();\nobiect2.g();\n}\n}",
          "options": {
            "A": "Programul este corect si va afisa la executie a=4, b=3;",
            "B": "Va aparea eroare la compilare, deoarece clasa C2 nu poate fi definita in metoda f() din clasa C1;",
            "C": "Va aparea eroare la compilare deoarece in metoda g() nu putem accesa vari- abila locala a din metoda f();",
            "D": "Va aparea eroare la compilare deoarece nu se creeaza in clasa Test un obiect de tip C1.C2;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Răspunsul corect este C. În Java, clasele locale (cum ar fi clasa C2 definită în cadrul metodei f a clasei C1) pot accesa doar variabilele locale finale sau efectiv finale din domeniul înconjurător. În acest program, variabila `a` nu este declarată ca fiind finală și nici nu este efectiv finală, deoarece este calculată folosind parametrii nefinali `xx` și `yy`. Prin urmare, încercarea de a accesa `a` în cadrul metodei `g` a clasei C2 va duce la o eroare de compilare. Pe de altă parte, variabila `b` este declarată ca fiind finală, așa că poate fi accesată fără probleme."
        },
        {
          "id": 9,
          "text": "Un fir de executie poate intra in starea ”blocat” (blocked) astfel?",
          "options": {
            "A": "Prin apelul metodei sleep();",
            "B": "Automat de catre sistemul de operare;",
            "C": "Prin apelul metodei block();",
            "D": "Prin apelul metodei wait();"
          },
          "correct_answer": [
            "A",
            "D"
          ],
          "explanation": "În contextul gestionării firelor de execuție, un fir poate intra într-o stare de \"blocare\" în anumite condiții.\n\n- Opțiunea A, \"Prin apelul metodei sleep();\", este corectă deoarece apelarea metodei `sleep()` pe un fir determină pauzarea execuției pentru o perioadă specificată, punându-l efectiv într-o stare de blocare în acel timp.\n\n- Opțiunea D, \"Prin apelul metodei wait();\", este de asemenea corectă deoarece atunci când un fir apelează `wait()`, eliberează orice blocaje deținute și intră într-o stare de blocare, așteptând să fie notificat sau întrerupt.\n\nOpțiunea B, \"Automat de către sistemul de operare,\" nu este suficient de specifică, deoarece firele sunt în general blocate din cauza unor acțiuni specifice, cum ar fi operațiunile de I/O sau sincronizarea, nu automat."
        },
        {
          "id": 10,
          "text": "Care dintre urmatoarele propozitii referitoare la metodele unui applet sunt adevarate?",
          "options": {
            "A": "Trebuie sa redefinim macar o metoda altfel obtinem eroare la compilare;",
            "B": "Sunt apelate automat de navigatorul Web;",
            "C": "Pot fi apelate direct de catre utilizator;",
            "D": "Nu se pot declara noi metode;"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "În contextul applet-urilor, care sunt mici programe Java ce rulează într-un browser web, metodele unui applet sunt gestionate în moduri specifice:\n\n- **A. Incorect**. Nu este obligatoriu să redefinim vreo metodă pentru ca un applet să fie compilat. Applet-ul poate moșteni implementările implicite ale metodelor din clasa `Applet` sau `JApplet`. Totuși, pentru a-i oferi funcționalitate specifică, este obișnuit să suprascriem metode precum `init()`, `start()`, `stop()` și `destroy()`.\n\n- **B. Corect**. Metodele ciclului de viață ale unui applet (`init()`, `start()`, `stop()`, `destroy()`) sunt apelate automat de către browserul web sau de mediul de execuție Java atunci când applet-ul este încărcat, pornit, întrerupt sau distrus. Acest comportament este specific applet-urilor și permite gestionarea automată a execuției lor.\n\n- **C. Corect**. Metodele definite într-un applet pot fi apelate direct de către utilizator, de obicei prin acțiuni de interfață grafică, cum ar fi apăsarea unui buton, selectarea unei opțiuni etc. Aceste metode trebuie să fie publice pentru a putea fi apelate din exteriorul clasei.\n\n- **D. Incorect**. Nu există nicio restricție în ceea ce privește declararea de noi metode într-un applet. Programatorul poate defini orice metode necesare funcționalității aplicației.\n\nPrin urmare, opțiunile **B** și **C** sunt corecte."
        },
        {
          "id": 11,
          "text": "Care dintre gestionarii de pozitionare (Layout Managers) de mai jos pot fi utilizati pentru applet-uri?",
          "options": {
            "A": "GridBagLayout;",
            "B": "TableLayout;",
            "C": "DefaultLayout;",
            "D": "FlowLayout;"
          },
          "correct_answer": [
            "A",
            "D"
          ],
          "explanation": "În Abstract Window Toolkit (AWT) din Java, managerii de layout sunt utilizați pentru a aranja componentele într-un container. `GridBagLayout` și `FlowLayout` sunt manageri de layout standard furnizați de AWT care pot fi utilizați în applet-uri pentru a controla poziționarea și dimensionarea componentelor.\n\n- **GridBagLayout (A):** Acesta este un manager de layout versatil și flexibil care permite aranjamente complexe cu dimensiuni și aliniamente variabile ale componentelor, fiind potrivit pentru aranjarea componentelor într-un mod asemănător unei grile, cu constrângeri diferite.\n\n- **FlowLayout (D):** Acest manager de layout aranjează componentele într-un flux de la stânga la dreapta, asemănător cu textul într-un paragraf, și este potrivit pentru aranjamente simple și directe."
        },
        {
          "id": 12,
          "text": "Ce metode trebuie definite pentru a putea desena pe suprafata applet-ului?",
          "options": {
            "A": "Nu trebuie definita nici o metoda;",
            "B": "update();",
            "C": "paint();",
            "D": "repaint();"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "În applet-urile Java, metoda `paint()` este esențială pentru redarea graficelor pe suprafața applet-ului. Când un applet trebuie să afișeze sau să actualizeze conținutul său vizual, metoda `paint(Graphics g)` este apelată de sistem. Această metodă furnizează un obiect `Graphics` ca argument, care este folosit pentru a desena forme, text și imagini pe suprafața applet-ului. Metodele `update()` și `repaint()` sunt legate de procesul de desenare, dar `paint()` este metoda principală unde este implementată logica efectivă de desenare. `repaint()` solicită un apel la `update()`, care în cele din urmă apelează `paint()`, iar `update()` este folosită pentru a șterge conținutul anterior înainte de a apela `paint()`. Prin urmare, pentru a..."
        },
        {
          "id": 13,
          "text": "Care sunt deosebirile dintre Swing si AWT?",
          "options": {
            "A": "Componentele Swing sunt scrise in totalitate in Java, pe cand in AWT, componentele sunt scrise folosind cod nativ;",
            "B": "Componentele AWT au vizualizarea dependenta de sistemul de operare, iar  in Swing componentele pot avea o aceeasi vizualizare, indiferent de sistemul de operare;",
            "C": "In sistemele de operare Unix componentele AWT nu sunt vizibile, pe cand cele din Swing da;",
            "D": "Fiecare componenta AWT are o componenta corespondenta in Swing;"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "Swing și AWT sunt două biblioteci utilizate pentru crearea interfețelor grafice în Java. Diferențele principale dintre ele sunt:\n\nA. Componentele Swing sunt scrise complet în Java, ceea ce le face independente de platformă. În schimb, AWT (Abstract Window Toolkit) folosește componente scrise cu ajutorul codului nativ al sistemului de operare, ceea ce poate duce la diferențe de comportament și aspect pe diverse platforme.\n\nB. Componentele AWT depind de aspectul și comportamentul specific sistemului de operare pe care rulează, ceea ce înseamnă că pot arăta diferit pe Windows, Mac sau Linux."
        },
        {
          "id": 14,
          "text": "Care din fragmentele de cod Java de mai jos dauga un buton unui container de baza JFrame?",
          "options": {
            "A": "JFrame f= new JFrame();\nJPanel p = (JPanel)f.getContentPane();\np.add(new JButton(\"Buton\")) ;",
            "B": "JFrame f= new JFrame();\nf.getContentPane().add(new JButton(\"Buton\"));",
            "C": "JFrame f= new JFrame();\nf. add(new JButton(\"Buton\"));",
            "D": "JFrame f=new JFrame();\nJButton b=new JButton(\"Buton\");\nf.add(b);"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "În Java, un `JFrame` este un container de nivel superior folosit pentru a crea o fereastră. Pentru a adăuga componente precum butoane, de obicei le adaugi la panoul de conținut al ferestrei. În opțiunile corecte (A și B), codul accesează corect panoul de conținut al instanței `JFrame` `f` și adaugă un `JButton` la acesta.\n\n- **Opțiunea A**: Recuperează panoul de conținut ca un `JPanel` și adaugă un nou `JButton` la acest panou. Aceasta este o modalitate validă de a adăuga componente la panoul de conținut.\n\n- **Opțiunea B**: Adaugă direct un nou `JButton` la panoul de conținut folosind `f.getContentPane().add()`. Aceasta este o metodă simplă și corectă."
        },
        {
          "id": 15,
          "text": "Fie urmatoarea secventa de cod:\n\nJPanel p =new JPanel();\nJlabel e = new JLabel(\"Eticheta:\");\ne.setDisplayedMnemonic(’E’);\np.add(e, BorderLayout.EAST);\nJTextField t = new JTextField(7);\ne.setLabelFor(t);\np.add(t, BorderLayout.WEST);\n\nCe se va intampla la apasarea combinatiei de taste: Alt + E?",
          "options": {
            "A": "Eticheta e va detine focusul;",
            "B": "Campul t va detine focusul;",
            "C": "Nici o componenta nu va detine focusul;",
            "D": "Panoul p va detine focusul;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În codul furnizat, un `JLabel` este creat cu textul \"Eticheta:\" și i se setează un mnemonic 'E' folosind `setDisplayedMnemonic('E')`. Acest mnemonic permite utilizatorilor să interacționeze cu interfața prin scurtături de la tastatură. `JLabel` este apoi asociat cu un `JTextField` folosind metoda `setLabelFor(t)`. Această asociere înseamnă că atunci când tasta mnemonică (Alt + E) este apăsată, focalizarea va fi transferată către componenta `JTextField` (`t`). Astfel, opțiunea B este corectă deoarece apăsarea combinației Alt + E va face ca câmpul de text `t` să primească focalizarea."
        },
        {
          "id": 16,
          "text": "Care dintre urmatoarele afirmatii referitoare la componenta grafica JTable sunt adevarate?",
          "options": {
            "A": "Intotdeauna o componenta JTable are asociata un model de date, chiar daca nu specificam explicit acest lucru;",
            "B": "Prin modificarile efectuate asupra datelor unui model, se va actualiza automat si vizualizarea tabelului;",
            "C": "Pentru a crea o tabela folosind modelul AbstractModelTable, este indeajuns sa suprascriem metodele getRowCount() si getColumnCount();",
            "D": "Modelul de date AbstractTableModel tine datele intotdeauna intr-un Vector avand elemente Vector;"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "Răspunsurile corecte, A și B, se referă la modul în care funcționează JTable în Java:\n\nA. Adevărat. Un JTable are întotdeauna un model de date asociat. Dacă nu furnizezi explicit unul, JTable va crea automat un model de date implicit pentru tine. Acest lucru asigură că JTable are o structură pentru a deține și gestiona datele pe care le afișează.\n\nB. Adevărat. JTable este conceput să fie un component de vizualizare care reflectă modificările făcute modelului său de date subiacente. Când modifici datele în model, JTable ascultă aceste schimbări și își actualizează afișajul în consecință, menținând sincronizarea între date și vizualizare.\n\nC. Fals. Deși suprascrierea metodelor `getRowCount()` și `getColumnCount()` este necesară, nu este suficientă pentru a crea un tabel funcțional cu AbstractTableModel. De asemenea, trebuie să..."
        },
        {
          "id": 17,
          "text": "JDesktopPane este un exemplu de:",
          "options": {
            "A": "Container pentru JInternalFrame;",
            "B": "Subclasa pentru JLayeredPane;",
            "C": "Subclasa pentru JInternalFrame;",
            "D": "Componenta atomica simpla;"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "JDesktopPane este o parte a bibliotecii Java Swing utilizată pentru a crea aplicații cu Interfață Multi-Document (MDI). Acesta are două scopuri principale:\n\nA. Container pentru JInternalFrame: JDesktopPane este special conceput pentru a fi un container pentru obiectele JInternalFrame, care sunt similare cu cadrele individuale (precum ferestrele), dar care se află în interiorul unui panou desktop. Acest lucru permite gestionarea mai multor cadre interne într-o singură fereastră principală.\n\nB. Subclasă pentru JLayeredPane: JDesktopPane extinde JLayeredPane, ceea ce înseamnă că moștenește proprietățile și funcționalitățile acestuia. JLayeredPane permite plasarea componentelor în diferite straturi, permițând suprapunerea componentelor cu niveluri variate de vizibilitate, ceea ce este esențial pentru gestionarea mai multor cadre interne în cadrul panoului desktop."
        },
        {
          "id": 18,
          "text": "Fie urmatorul program Java:\n\npublic class Afisare {\n    public static void main (String[] args) {\n        for (int i = 0; i < args.length; i++)\n        System.out.println(args[i]);\n    }\n}\n\nUn apel de genul java Afisare \"Hello Java\"; va produce urmatorul rezultat:",
          "options": {
            "A": "Hello Java;",
            "B": "Hello\nJava;",
            "C": "Programul este incorect, deoarece nu sunt prezente argumentele;",
            "D": "NaN;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Explicație: Programul Java definește o clasă `Afisare` cu o metodă `main` care primește un array de argumente de tip `String` (`args`). Bucla `for` iterează peste fiecare element din array-ul `args` și îl afișează folosind `System.out.println()`. Când programul este executat cu comanda `java Afisare \"Hello Java\";`, întregul șir \"Hello Java\" este transmis ca un singur argument programului, deoarece este încadrat între ghilimele. Prin urmare, `args` conține un singur element: șirul \"Hello Java\". Bucla afișează acest unic element, rezultând în afișarea \"Hello Java\", corespunzând opțiunii A."
        },
        {
          "id": 19,
          "text": "Fie urmatorul program Java:\n\npublic class Program{\n    static void f(int k){\n        switch(k){\n            default: System.out.print(\"i \"); break;\n            case 1: System.out.print(\"1 \"); break;\n            case 2: case 3: System.out.print(\"21 \"); break;\n            case 4: case 5: System.out.print(\"26 \");\n        }\n}\npublic static void main(String []args){\n    for(int i=0;i<6;i++)\n    f(i);\n}\n}\n\nCare afirmatii sunt false?",
          "options": {
            "A": "Eroare la compilare;",
            "B": "Programul se compileaza si la executie afiseaza\ni 1 21 21 26 26 ;",
            "C": "Programul se compileaza si la executie afiseaza\ni 1 21 26 ;",
            "D": "Programul se compileaza si la executie afiseaza\ni 1 21 21 26 26 i;"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "Programul Java dat definește o clasă `Program` cu o metodă statică `f(int k)`, care utilizează o instrucțiune `switch` pentru a afișa diferite ieșiri în funcție de valoarea lui `k`. Metoda `main` iterează de la 0 la 5 și apelează metoda `f` cu fiecare valoare. Iată o descriere a comportamentului:\n\n- Pentru `k=0`: Instrucțiunea `switch` nu are un caz pentru 0, așa că se folosește de cazul implicit, afișând \"i \".\n- Pentru `k=1`: Instrucțiunea `switch` se potrivește cu cazul 1, afișând \"1 \".\n- Pentru `k=2` și `k=3`: Atât 2 cât și 3 trec prin același bloc, afișând \"21 \"."
        },
        {
          "id": 20,
          "text": "Se utilizeaza protected  in Java pentru date si metode la care nu este necesar:",
          "options": {
            "A": "Sa facem o initializare;",
            "B": "Sa le accesam in subclase;",
            "C": "Ca utilizatorul sa aiba acces;",
            "D": "Accesul direct atunci cand clasa este utilizata dar care prezinta interes atunci\ncand cineva creeaza o subclasa a acesteia ca parte a unui pachet diferit, in\nvederea extinderii ei;"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "În Java, modificatorul de acces `protected` este utilizat pentru a permite accesul la membrii unei clase (câmpuri și metode) în cadrul aceluiași pachet și, de asemenea, de către subclase, chiar dacă acestea se află în pachete diferite. Răspunsul corect (D) subliniază faptul că `protected` este deosebit de util atunci când dorești să permiți subclaselor, posibil în alte pachete, să acceseze anumiți membri ai clasei. Acest lucru facilitează extinderea funcționalității clasei, menținând în același timp încapsularea pentru restul pachetului, aliniindu-se cu principiile programării orientate pe obiecte care promovează reutilizarea și extinderea codului."
        },
        {
          "id": 21,
          "text": "O subclasa a unei clase abstracte poate fi instantiata numai daca:",
          "options": {
            "A": "Se foloseste cuvantul cheie abstract;",
            "B": "Suprascrie fiecare metoda declarata abstracta in superclasa sa, si furnizeaza implementari pentru toate acestea;",
            "C": "Se foloseste mostenirea multipla;",
            "D": "O subclasa abstracta nu poate fi instantiata;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În contextul programării orientate pe obiecte, o clasă abstractă este o clasă care nu poate fi instanțiată direct și poate conține metode abstracte, care sunt declarate fără implementare. O subclasă a unei clase abstracte poate fi instanțiată doar dacă suprascrie toate metodele abstracte ale clasei părinte și furnizează implementări concrete pentru acestea. Astfel, opțiunea B este corectă deoarece subliniază necesitatea ca toate metodele abstracte să fie implementate în subclasă pentru a putea crea obiecte din aceasta."
        },
        {
          "id": 22,
          "text": "Prin modalitatea sa de tratare a exceptiilor, Java are urmatoarele avantaje fata de mecanismul traditional de tratare a erorilor:",
          "options": {
            "A": "Exista o metoda care se ocupa cu acest lucru;",
            "B": "Separarea codului pentru tratarea unei erori de codul  in care ea poate sa apara;",
            "C": "Propagarea unei erori pana la un analizor de exceptii corespunzator;",
            "D": "Gruparea erorilor dupa tipul lor;"
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "În Java, mecanismul de gestionare a excepțiilor oferă mai multe avantaje față de metodele tradiționale de gestionare a erorilor:\n\nB. Separarea codului pentru tratarea unei erori de codul în care ea poate să apară: Gestionarea excepțiilor în Java permite o separare clară între codul responsabil pentru executarea unei sarcini și codul responsabil pentru gestionarea erorilor. Această separare îmbunătățește lizibilitatea și mentenabilitatea codului.\n\nC. Propagarea unei erori până la un analizor de excepții corespunzător: Java permite propagarea excepțiilor pe stiva de apeluri până când acestea sunt interceptate de un handler de excepții corespunzător. Această propagare asigură că erorile pot fi gestionate la nivelul cel mai adecvat în program.\n\nD. Gruparea erorilor după tipul lor: Cadrul de gestionare a excepțiilor în Java permite"
        },
        {
          "id": 23,
          "text": "Metodele care sunt apelate uzual pentru un obiect de tip exceptie sunt definite in clasa Throwable si sunt:",
          "options": {
            "A": "Declarate cu modificatorul de acces private;",
            "B": "dinamice;",
            "C": "publice;",
            "D": "exceptii;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "În Java, clasa `Throwable` este superclasa pentru toate erorile și excepțiile. Metodele definite în această clasă, care sunt utilizate frecvent pentru gestionarea excepțiilor, sunt destinate să fie accesibile oricărui cod care gestionează excepții. Prin urmare, aceste metode sunt declarate cu modificatorul de acces `public`. Acest lucru le permite să fie apelate din orice alt cod care are acces la o instanță a unei clase `Throwable` sau a subclaselor sale, permițând o gestionare eficientă a excepțiilor în diferite părți ale unui program. Prin urmare, răspunsul corect este C. Metodele publice asigură că funcționalități esențiale, precum obținerea mesajului excepției, a traseului stivei sau a cauzei, sunt accesibile oriunde este nevoie."
        },
        {
          "id": 24,
          "text": "Un fir de executie poate intra in starea de ready astfel:",
          "options": {
            "A": "Prin apelul metodei sleep();",
            "B": "Automat de catre sistemul de operare;",
            "C": "Prin apelul metodei join();",
            "D": "Niciodata;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Răspunsul corect este B: Automat de către sistemul de operare.\n\nExplicație: În contextul sistemelor de operare și al multithreading-ului, un fir de execuție poate intra în starea de \"pregătit\" automat de către sistemul de operare atunci când este pregătit să ruleze, dar nu este în execuție în acel moment. Această tranziție are loc de obicei după ce firul de execuție a fost blocat (de exemplu, așteptând I/O sau o resursă) și resursa devine disponibilă, sau când durata de somn a firului s-a încheiat. Sistemul de operare gestionează stările și tranzițiile firelor de execuție, mutând firele în starea de \"pregătit\" atunci când sunt eligibile să utilizeze CPU-ul. Celelalte opțiuni implică acțiuni explicite, cum ar fi somnul sau alăturarea, care de obicei blochează un fir de execuție în loc să-l facă pregătit pentru rulare."
        },
        {
          "id": 25,
          "text": "Cand browser-ul intalneste tag-ul < APPLET >, rezerva o zona pentru afisare cu dimensiunile\nspecificate de paramterii WIDTH, HEIGHT si:",
          "options": {
            "A": "Se instaleaza un manager de securitate, adica un obiect de tip SecurityManager care va monitoriza activitatea metodelor appletului, aruncand exceptii de tip SecurityException;",
            "B": "Incarca codul compilat al applet-ului cu numele specificat de parametrul CODE;",
            "C": "Creaza o instanta a clasei Applet dupa care apeleaza metodele init() si start();",
            "D": "Se deschid mai multe procese pe masina client;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Când un browser web întâlnește eticheta `<APPLET>` într-un document HTML, acesta rezervă o zonă de afișare cu dimensiunile specificate de parametrii `WIDTH` și `HEIGHT`. Apoi, browserul sau mașina virtuală Java (JVM) efectuează o serie de pași pentru a inițializa și rula appletul.\n\nOpțiunea **C** este corectă: browserul încarcă clasa specificată prin atributul `CODE`, creează o instanță a acelei clase (care extinde `Applet`), și apoi apelează metodele `init()` și `start()` pentru a inițializa și porni execuția vizuală a appletului în zona rezervată din pagină.\n\nIată de ce celelalte opțiuni sunt incorecte sau incomplete:\n\n- **A**: Este adevărat că un `SecurityManager` este implicat în execuția appleturilor, pentru a restricționa accesul la resursele sistemului (cum ar fi sistemul de fișiere sau rețeaua), dar acest lucru nu este un efect direct și imediat al întâlnirii tagului `<APPLET>`, ci parte din mecanismul general de securitate al JVM.\n\n- **B**: Codul compilat al appletului (fișierul `.class`) este într-adevăr încărcat folosind parametrul `CODE`, însă acest pas face parte din procesul mai larg care include și instanțierea obiectului și apelarea metodelor de viață (`init()`, `start()`), care sunt menționate doar în opțiunea C.\n\n- **D**: Această afirmație este falsă. Nu se deschid mai multe procese pe mașina client în sensul clasic al proceselor de sistem. Appletul rulează în contextul JVM într-un singur proces, eventual cu fire de execuție (threads), dacă este programat astfel.\n\nPrin urmare, **răspunsul corect este C**, deoarece descrie în mod precis comportamentul standard al browserului/JVM atunci când procesează un applet Java."
        },
        {
          "id": 26,
          "text": "Care dintre urmatoarele coduri nu reprezinta arhivarea fisierelor unui applet?",
          "options": {
            "A": "jar cvf arhiva.jar ClasaPrincipala.java imagine.jpg;",
            "B": "jar cvf arhiva.jar *.class *.jpg *.au;",
            "C": "jar cfv arhiva.jar *.class *.jpg *.au;",
            "D": "jar cvf arhiva.jar ClasaPrincipala.class AltaClasa.class imagine.jpg sunet.au"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "În contextul creării unui fișier JAR (Java ARchive) pentru un applet, comanda `jar` este utilizată pentru a împacheta mai multe fișiere într-un singur fișier arhivă. Comanda folosește de obicei opțiuni precum `c` (creare), `v` (verbose) și `f` (nume fișier).\n\n- Opțiunea A: `jar cvf arhiva.jar ClasaPrincipala.java imagine.jpg;` este incorectă deoarece include un fișier `.java`, care este cod sursă, nu bytecode compilat. Applet-urile necesită fișiere compilate `.class` pentru a rula.\n\n- Opțiunea C: `jar cfv arhiva.jar *.class *.jpg *.au;` este corectă din punct de vedere al sintaxei și funcționalității. Totuși, secvența opțiunilor nu..."
        },
        {
          "id": 27,
          "text": "In care din exemplele de mai jos se foloseste corect variabila iLocation?",
          "options": {
            "A": "tabbedPanel.insertTab( \"Inserted Page\", new ImageIcon( \"image.gif\" ), pagePanel,\"My tooltip text\",iLocation );",
            "B": "JFrame f= new JFrame(); f.getContentPane().add(new JButton(\"Buton\", iLocation));",
            "C": "tabbedPanel.removeTabAt( iLocation );",
            "D": "JFrame f=new JFrame(); JButton b=new JButton(\"Buton\"); f.add(b, iLocation);"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "Întrebarea se referă la utilizarea corectă a variabilei `iLocation` în diferite contexte.\n\nÎn opțiunea A, `iLocation` este utilizată corect ca parametru de index în metoda `insertTab` a unui obiect `JTabbedPane`. Această metodă ia de obicei un parametru de index pentru a specifica poziția unde ar trebui să fie inserat noul tab.\n\nÎn opțiunea C, `iLocation` este utilizată corect ca parametru de index în metoda `removeTabAt` a unui obiect `JTabbedPane`. Această metodă folosește indexul pentru a identifica care tab ar trebui eliminat.\n\nOpțiunea B este incorectă deoarece metoda `add` a unui `Container` (cum ar fi `JFrame`) care primește un `Component` și un `String` sau `Object` ca parametri nu utilizează un index pentru a specifica poziția."
        },
        {
          "id": 28,
          "text": "Ce rezulta din urmatorul fragment de cod Java?\n\nint x=1;\nString []names={\"Fred\",\"Jim\",\"Sheila\"};\nnames[--x]+=\".\";\nfor(int i=0;i<names.length;i++)\nSystem.out.println(names[i]);",
          "options": {
            "A": "Output-ul include Sheila.;",
            "B": "Output-ul include Fred.;",
            "C": "Output-ul include Jim.;",
            "D": "Nimic din cele de mai sus;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În acest fragment de cod Java, avem o variabilă int x inițializată cu valoarea 1 și un array de stringuri numit `names` care conține trei elemente: \"Fred\", \"Jim\" și \"Sheila\". Linia `names[--x]+=\".\";` decrementează mai întâi valoarea lui x de la 1 la 0 (datorită operatorului de pre-decrement `--`) și apoi adaugă un punct (\".\") la elementul din array corespunzător indexului 0, care este \"Fred\". Astfel, \"Fred\" devine \"Fred.\". În bucla for, fiecare element al array-ului `names` este afișat pe rând."
        },
        {
          "id": 29,
          "text": "Applet-urile se diferentiaza de aplicatiile Java standard prin:",
          "options": {
            "A": "Restrictiile impuse de necesitatea asigurarii unui anumit nivel de securitate si faptul ca nu au o metoda main();",
            "B": "Faptul ca trebuie sa suprascrie toate metodele: init(), start(), stop(), pause() si destroy();",
            "C": "Faptul ca detin un instrument cu ajutorul caruia se creaza relatii de mostenire;",
            "D": "Faptul ca detin un instrument care desemneaza meniurile din cadrul unei forme;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Applet-urile Java sunt programe mici care rulează în interiorul unui browser web și sunt încorporate într-o pagină web. Spre deosebire de aplicațiile Java standard, care rulează independent și au un punct de intrare prin metoda main(), applet-urile nu au o astfel de metodă. În plus, din motive de securitate, applet-urile sunt supuse unor restricții stricte. De exemplu, ele rulează într-un sandbox, ceea ce înseamnă că nu pot accesa resursele locale ale calculatorului utilizatorului, cum ar fi fișierele de pe disc, și nu pot efectua operații care ar putea compromite securitatea sistemului gazdă."
        },
        {
          "id": 30,
          "text": "Declararea constructorilor trebuie sa tina cont de:",
          "options": {
            "A": "relatia de mostenire dintre clase;",
            "B": "numele constructorului, care trebuie sa fie identic cu numele clasei;",
            "C": "comportamentul obiectelor pe care le instantiaza;",
            "D": "o metoda prin care poate fi accesat de toate tipurile din Java sau de tipuri mostenite din tipul care contine membrul in discutie; 5 Algoritmica grafurilor"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Explicație: În programarea orientată pe obiecte, un constructor este o metodă specială folosită pentru a inițializa obiectele unei clase. Caracteristica principală a unui constructor este că trebuie să aibă același nume ca și clasa căreia îi aparține. Acesta este motivul pentru care opțiunea B este răspunsul corect. Asigură faptul că atunci când un obiect este creat, constructorul este apelat automat pentru a stabili starea inițială a obiectului. Opțiunile A, C și D, deși sunt legate de clase și obiecte, nu abordează în mod specific cerința ca numele constructorului să se potrivească cu numele clasei."
        }
      ]
    },
    {
      "name": "Algoritmica grafurilor",
      "questions": [
        {
          "id": 1,
          "text": "O procedura ce parcurge arborele binar in postordine va afisa:",
          "image": "grafuri_1.png",
          "options": {
            "A": "A B C D E F",
            "B": "A B D E C F",
            "C": "D B E A F C",
            "D": "D E B F C A",
            "E": "D E F B C A"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Într-un parcurs postordine al unui arbore binar, nodurile sunt vizitate în următoarea ordine: subarborele stâng, subarborele drept și apoi nodul rădăcină. Aceasta înseamnă că pentru fiecare subarbore, mai întâi procesezi toate nodurile din subarborele stâng, apoi toate nodurile din subarborele drept și, în final, rădăcina subarborelui.\n\nPentru a înțelege de ce opțiunea D este corectă, să descompunem procesul de parcurgere pentru un arbore binar:\n\n1. Începe cu subarborele cel mai din stânga și parcurge-l în postordine: stânga, dreapta, rădăcină.\n2. Treci la subarborele drept al rădăcinii inițiale și parcurge-l în același mod: stânga, dreapta, rădăcină.\n3. În final, vizitează nodul rădăcină al întregului arbore.\n\nUrmând această metodă, secvența de"
        },
        {
          "id": 2,
          "text": "O procedura ce parcurge arborele binar  in preordine va afisa:",
          "image": "grafuri_2.png",
          "options": {
            "A": "J D P B H L R F N",
            "B": "J D B H F P L N R",
            "C": "N F R L H B P D J",
            "D": "B D H F N L P R J",
            "E": "B D F H L J N P R"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Întrebarea se referă la ordinea de parcurgere a nodurilor într-un arbore binar atunci când se utilizează metoda de parcurgere pre-ordine. În parcurgerea pre-ordine, nodurile sunt vizitate în următoarea ordine:\n\n1. Vizitează nodul rădăcină.\n2. Parcurge subarborele stâng în pre-ordine.\n3. Parcurge subarborele drept în pre-ordine.\n\nAvând în vedere această metodă, secvența corectă pentru vizitarea nodurilor în arborele binar este \"J D B H F P L N R\", care corespunde opțiunii B. Această secvență începe cu nodul rădăcină (J), urmat de parcurgerea pre-ordine a subarborelui stâng (D B H F) și apoi a subarborelui drept (P L N R)."
        },
        {
          "id": 3,
          "text": "O procedura ce parcurge arborele binar  in inordine va afisa:",
          "image": "grafuri_3.png",
          "options": {
            "A": "B H F D L N P R J",
            "B": "B D H F N L P R J",
            "C": "N F R L H B P D J",
            "D": "J D P B H L R F N",
            "E": "B D F H J L N P R"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Parcurgerea in-order a unui arbore binar implică vizitarea nodurilor în următoarea ordine: subarborele stâng, nodul rădăcină, subarborele drept. Această metodă de parcurgere are ca rezultat afișarea nodurilor în ordine crescătoare pentru un arbore binar de căutare. Dintre opțiuni, secvența B D F H J L N P R (opțiunea E) reflectă această ordine, deoarece listează nodurile de la cea mai mică la cea mai mare valoare, în concordanță cu o parcurgere in-order a unui arbore binar de căutare."
        },
        {
          "id": 4,
          "text": "O procedura ce parcurge arborele binar  in A-preordine va afisa:",
          "image": "grafuri_4.png",
          "options": {
            "A": "A B C E F D G H I J",
            "B": "A B C D E F G H I J",
            "C": "B E F C G H I J D A",
            "D": "B A E C F G D H I J",
            "E": "B E F G H I J C D A"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Într-o parcurgere a unui arbore binar, A-preordine (sau pre-order) înseamnă vizitarea nodurilor în ordinea: Rădăcină, Stânga, Dreapta. Această parcurgere începe de la rădăcina arborelui, apoi vizitează recursiv subarborele stâng urmat de subarborele drept. Având în vedere că răspunsul corect este A, secvența \"A B C E F D G H I J\" urmează acest tipar. Începe cu nodul rădăcină \"A\", urmat de nodurile subarborelui stâng \"B\", \"C\", \"E\", \"F\", și apoi parcurge nodurile subarborelui drept \"D\", \"G\", \"H\", \"I\", \"J\". Acest lucru corespunde metodei de parcurgere în preordine."
        },
        {
          "id": 5,
          "text": "Care este numarul maxim de componente conexe pe care le poate avea un graf neorientat cu 20 de noduri si 12 muchii?",
          "options": {
            "A": "6",
            "B": "12",
            "C": "10",
            "D": "15",
            "E": "18"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Pentru a determina numărul maxim de componente conexe într-un graf neorientat cu 20 de noduri și 12 muchii, putem folosi conceptul conform căruia o componentă conexă este un subset al grafului în care oricare două vârfuri sunt conectate între ele prin căi și care nu este conectat la alte vârfuri din supergraf.\n\nPentru a obține numărul maxim de componente conexe, graful ar trebui să aibă cât mai multe noduri izolate posibil, deoarece nodurile izolate sunt propriile lor componente conexe. Dacă există 20 de noduri și 12 muchii, cel mai mic număr de noduri care pot fi conectate de aceste muchii este 12 (deoarece fiecare muchie conectează două noduri). Astfel, numărul maxim de noduri izolate este \\(20 - 12 = 8\\).\n\nAcum, dacă avem 8 noduri izolate..."
        },
        {
          "id": 6,
          "text": "Cate grafuri neorientate, distincte, cu 4 varfuri se pot construi? Doua grafuri se considera distincte \ndaca matricele lor de adiacenta sunt diferite.",
          "options": {
            "A": "4⁶",
            "B": "2⁶",
            "C": "6⁴",
            "D": "4",
            "E": "2¹⁰"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a determina câte grafuri neorientate distincte cu 4 vârfuri pot fi construite, trebuie să luăm în considerare potențialele muchii dintre aceste vârfuri. Într-un graf neorientat cu \\( n \\) vârfuri, numărul maxim de muchii posibile este dat de coeficientul binomial \\(\\binom{n}{2}\\), care reprezintă numărul de moduri de a alege 2 vârfuri din \\( n \\) pentru a forma o muchie.\n\nPentru 4 vârfuri, numărul de muchii posibile este:\n\n\\[\n\\binom{4}{2} = 6\n\\]\n\nAceasta deoarece fiecare pereche de vârfuri poate fi fie conectată printr-o muchie, fie nu, și deoarece nu există bucle sau muchii multiple în grafurile neorientate simple, fiecare dintre aceste 6 perechi poate..."
        },
        {
          "id": 7,
          "text": "Intr-un graf neorientat cu 10 muchii, fiecare nod are gradul un numar nenul. Doar trei dintre noduri \nau gradul un numar par, restul nodurilor avand gradele numere impare. Care este numarul maxim \nde noduri pe care poate sa le aiba graful?",
          "options": {
            "A": "14",
            "B": "10",
            "C": "17",
            "D": "16",
            "E": "19"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Într-un graf, suma gradelor tuturor nodurilor este egală cu de două ori numărul de muchii (cunoscută sub numele de Lema Strângerii de Mână). În acest caz, graful are 10 muchii, deci suma gradelor tuturor nodurilor este \\(2 \\times 10 = 20\\).\n\nConform problemei, trei noduri au grade pare, iar restul nodurilor au grade impare. Să presupunem că numărul nodurilor cu grade impare este \\(x\\), deci \\(x + 3\\) este numărul total de noduri.\n\nSuma gradelor nodurilor cu grade impare este impară, iar suma gradelor nodurilor cu grade pare este pară. Suma totală este pară (20), ceea ce înseamnă că suma gradelor..."
        },
        {
          "id": 8,
          "text": "Determinati numarul de frunze ale arborelui cu radacina descris prin urmatorul vector tata: (6, 5, 5, 2, 0, 3, 3, 3, 8, 7, 7)?",
          "options": {
            "A": "1",
            "B": "2",
            "C": "4",
            "D": "5",
            "E": "7"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Pentru a determina numărul de frunze într-un arbore înrădăcinat descris de vectorul de părinți dat, trebuie mai întâi să înțelegem structura arborelui. Vectorul furnizat indică părintele fiecărui nod, unde indexul reprezintă nodul copil, iar valoarea de la acel index reprezintă nodul părinte.\n\nAvând vectorul: (6, 5, 5, 2, 0, 3, 3, 3, 8, 7, 7), valoarea '0' indică rădăcina arborelui.\n\nO frunză într-un arbore este un nod care nu are copii. Pentru a găsi frunzele, trebuie să identificăm nodurile care nu sunt listate ca părinte pentru niciun alt nod. Analizând vectorul, putem determina care noduri sunt frunze."
        },
        {
          "id": 9,
          "text": "Care dintre urmatoarele valori pot reprezenta gradele nodurilor unui graf neorientat cu 6 noduri?",
          "options": {
            "A": "(3, 2, 2, 2, 3, 3)",
            "B": "(4, 2, 2, 2, 3, 2)",
            "C": "(5, 2, 2, 2, 0, 3)",
            "D": "(5, 2, 2, 2, 1, 2)",
            "E": "(5, 2, 3, 2, 1, 2)"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Pentru a determina care secvență de grade ale nodurilor poate reprezenta un graf neorientat valid cu 6 noduri, trebuie să ne asigurăm că suma gradelor este pară, deoarece fiecare muchie contribuie la gradul a două noduri. În plus, fiecare grad trebuie să fie un număr întreg nenegativ și mai mic decât numărul de noduri (deoarece un nod nu poate avea mai multe muchii decât numărul total de alte noduri).\n\nSă analizăm opțiunile:\n\nA. (3, 2, 2, 2, 3, 3)  \nSuma = 3 + 2 + 2 + 2 + 3 + 3 = 15 (sumă impară, nu este posibil)\n\nB. (4, 2, 2, 2, 3, 2)"
        },
        {
          "id": 10,
          "text": "Se considera graful neorientat cu multimea varfurilor {1, 2, 3, 4, 5, 6} si multimea muchiilor \n{[1, 2], [2, 3], [3, 4], [3, 5], [4, 5], [1, 3], [2, 6], [2, 4], [4, 6]}. Care este numarul minim de muchii ce trebuie \neliminate (care sunt aceste muchii) astfel incat graful partial obtinut sa nu mai fie conex?",
          "options": {
            "A": "1",
            "B": "3",
            "C": "2",
            "D": "5",
            "E": "nici una"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a rezolva această problemă, trebuie să găsim numărul minim de muchii care, atunci când sunt eliminate, vor deconecta graful. Un graf este deconectat dacă există cel puțin o pereche de noduri care nu au un drum între ele.\n\nDat fiind graful neorientat cu nodurile {1, 2, 3, 4, 5, 6} și muchiile {[1, 2], [2, 3], [3, 4], [3, 5], [4, 5], [1, 3], [2, 6], [2, 4], [4, 6]}, putem analiza structura sa. Scopul este să identificăm un set de muchii a căror eliminare rezultă într-un graf deconectat cu"
        },
        {
          "id": 11,
          "text": "Se considera graful neorientat G cu 8 noduri, care are urmatoarele proprietati: \nI. suma gradelor tuturor nodurilor este 12; \nII. graful are exact 3 noduri cu gradul 1. \nCare este numarul maxim de noduri de grad 0 ale grafului G?",
          "options": {
            "A": "1",
            "B": "4",
            "C": "2",
            "D": "3",
            "E": "0"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a determina numărul de noduri cu gradul 0 în graful neorientat \\( G \\) cu 8 noduri, putem folosi proprietățile date:\n\n1. Suma gradelor tuturor nodurilor este 12.\n2. Graful are exact 3 noduri cu gradul 1.\n\nMai întâi, considerăm că suma gradelor tuturor nodurilor într-un graf este de două ori numărul de muchii. Astfel, graful are în total 6 muchii.\n\nÎn continuare, deoarece există 3 noduri cu gradul 1, acestea contribuie cu un grad total de \\( 1 \\times 3 = 3 \\) la suma gradelor. Prin urmare, celelalte \\( 8 - 3 = 5 \\) noduri trebuie să aibă un grad combinat de"
        },
        {
          "id": 12,
          "text": "Se considera graful neorientat cu 80 de noduri si 3160 de muchii. Care este numarul de muchii ce pot fi eliminate astfel incat graful partial obtinut sa devina arbore?",
          "options": {
            "A": "80",
            "B": "3160",
            "C": "3081",
            "D": "6320",
            "E": "2450"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a transforma un graf cu \\( n \\) noduri într-un arbore, acesta trebuie să aibă exact \\( n-1 \\) muchii, deoarece un arbore este un graf conex fără cicluri, iar numărul minim de muchii care menține conectivitatea este \\( n-1 \\). În acest caz, graful are 80 de noduri, deci trebuie să aibă 79 de muchii pentru a fi un arbore. Graful original are 3160 de muchii. Prin urmare, numărul de muchii care trebuie eliminate este \\( 3160 - 79 = 3081 \\). Astfel, răspunsul corect este C."
        },
        {
          "id": 13,
          "text": "Se considera graful orientat G reprezentat prin listele de adiacenta alaturate. Care este lungimea\nmaxima a unui drum elementar din acest graf? Sa se specifice arcele ce compun un drum cu aceste\nproprietati.\n1 2 6 5\n2 3\n3 1\n4 6\n5 6\n6 2",
          "options": {
            "A": "1",
            "B": "7",
            "C": "3",
            "D": "4",
            "E": "5"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Pentru a determina lungimea maximă a unui drum elementar într-un graf orientat reprezentat prin liste de adiacență, trebuie să identificăm cel mai lung drum care nu repetă niciun vârf. Listele de adiacență furnizate sunt:\n\n- 1: 2, 6, 5\n- 2: 3\n- 3: 1\n- 4: 6\n- 5: 6\n- 6: 2\n\nUn drum elementar este un drum care vizitează fiecare vârf cel mult o dată. Pentru a găsi un astfel de drum, putem începe de la orice vârf și să urmăm muchiile orientate, asigurându-ne că nu vizităm niciun vârf de mai multe ori.\n\nUn potențial cel mai lung drum elementar este: 1 → 2 → 3 →"
        },
        {
          "id": 14,
          "text": "Pentru care dintre urmatorii arbori cu radacina, fiecare avand 9 noduri, numerotate de la 1 la 9, \nmemorati cu ajutorul vectorilor tata, nodul 3 are cei mai multi descendenti?",
          "options": {
            "A": "(2, 0, 2, 3, 2, 3, 4, 4, 3)",
            "B": "(3, 3, 4, 0, 2, 3, 4, 4, 4)",
            "C": "(4, 2, 4, 0, 3, 3, 3, 3, 3)",
            "D": "(0, 1, 1, 3, 4, 3, 4, 4, 3)",
            "E": "(0, 1, 2, 3, 4, 5, 6, 7, 8)"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a determina care structură de arbore are nodul 3 cu cei mai mulți descendenți, trebuie să analizăm relațiile părinte-copil definite de fiecare vector. Fiecare vector reprezintă relațiile părinte-copil într-un arbore, unde indexul este copilul, iar valoarea de la acel index este părintele.\n\n- În opțiunea A (2, 0, 2, 3, 2, 3, 4, 4, 3), nodul 3 este părintele nodurilor 4, 6 și 9. Nodul 4 este părintele nodurilor 7 și 8. Astfel, nodul 3 are 5 descendenți (4, 6, 9, 7, 8).\n\n- În opțiunea B (3, 3, 4..."
        },
        {
          "id": 15,
          "text": "Care dintre urmatoarele proprietati este adevarata pentru un graf orientat cu n varfuri si n arce \n(n > 3) si care prezinta un circuit de lungime n:",
          "options": {
            "A": "exista un varf cu gradul intern n(cid:0)1.",
            "B": "pentru orice varf, gradul intern si gradul extern sunt egale.",
            "C": "graful nu are drumuri de lungime strict mai mare decat 2.",
            "D": "gradul intern al oricarui varf este egal cu 2.",
            "E": "daca notam graful cu G = (V, E), |V| = n, atunci |E| = n - 1."
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Într-un graf orientat cu \\( n \\) vârfuri și \\( n \\) arce care conține un ciclu de lungime \\( n \\), fiecare vârf face parte din ciclu, contribuind cu exact un arc de intrare și un arc de ieșire. Acest lucru înseamnă că pentru fiecare vârf, gradul de intrare (numărul de arce care intră) și gradul de ieșire (numărul de arce care ies) sunt ambele egale cu 1. Prin urmare, gradul de intrare și gradul de ieșire pentru fiecare vârf sunt egale, ceea ce face ca afirmația B să fie adevărată. Celelalte opțiuni nu sunt valabile pentru un astfel de graf:\n\n- A: Niciun vârf nu poate avea un grad de intrare de \\( n-1 \\) deoarece fiecare vârf are doar un arc de intrare.\n- C: Graful poate avea căi mai lungi de 2, deoarece fiecare"
        },
        {
          "id": 16,
          "text": "Care este ordinea de parcurgere a nodurilor grafului din figura 1, daca se foloseste metoda de \nvizitare in latime (BFS) pornind din nodul 5?",
          "image": "grafuri_16.png",
          "options": {
            "A": "5, 2, 1, 3, 4, 7, 6, 8",
            "B": "5, 2, 1, 3, 5, 7, 6, 8",
            "C": "5, 7, 6, 4, 8, 2, 1, 3",
            "D": "5, 2, 7, 1, 6, 3, 4, 8",
            "E": "5, 7, 2, 6, 1, 8, 4, 3"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "nodurile adiacente la 7, în ordinea în care au fost descoperite. Algoritmul de parcurgere în lățime asigură că toate nodurile la o distanță egală de nodul de pornire sunt vizitate înainte de a trece la nodurile de la distanțe mai mari. Acest proces continuă până când toate nodurile accesibile din nodul de pornire au fost vizitate."
        },
        {
          "id": 17,
          "text": "Care este ordinea de parcurgere a nodurilor grafului din figura 2, daca se foloseste metoda de \nvizitare in adancime (DFS) pornind din nodul 3?",
          "image": "grafuri_17.png",
          "options": {
            "A": "3, 5, 7, 6, 4, 8, 2, 1",
            "B": "3, 5, 2, 7, 1, 6, 4, 8",
            "C": "3, 5, 2, 1, 4, 7, 6, 8",
            "D": "3, 5, 2, 1, 4, 6, 8, 7",
            "E": "3, 5, 2, 7, 1, 4, 6, 8"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Căutarea în adâncime (DFS) este un algoritm de parcurgere a grafurilor care explorează cât mai departe posibil pe fiecare ramură înainte de a reveni înapoi. Începând de la nodul 3, DFS va explora graful vizitând unul dintre vecinii săi, mergând mai adânc până când ajunge la un nod fără vecini nevizitați, apoi va reveni înapoi.\n\nSă descompunem parcurgerea folosind DFS de la nodul 3:\n1. Începe la nodul 3.\n2. Vizitează un nod vecin, să zicem nodul 5.\n3. De la nodul 5, vizitează un alt vecin, nodul 2.\n4. De la nodul 2, vizitează unul dintre vecinii săi, nodul 1.\n5. De la nodul 1, revino înapoi deoarece toți vecinii săi sunt vizitați, întoarce-te la nodul 2.\n6. De la"
        },
        {
          "id": 18,
          "text": "Deteminati ordinul si dimensiunea grafului din figura 3?",
          "image": "grafuri_18.png",
          "options": {
            "A": "5, 6",
            "B": "8, 5",
            "C": "7, 6",
            "D": "7, 7",
            "E": "6, 7"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a determina ordinul și dimensiunea unui graf, trebuie să identificăm numărul de vârfuri (noduri) și numărul de muchii (conexiuni între noduri) din graf.\n\n- **Ordin**: Acesta este numărul de vârfuri din graf. În Figura 3, există 7 vârfuri, deci ordinul este 7.\n- **Dimensiune**: Acesta este numărul de muchii din graf. În Figura 3, există 6 muchii, deci dimensiunea este 6.\n\nPrin urmare, răspunsul corect este C, care indică un ordin de 7 și o dimensiune de 6."
        },
        {
          "id": 19,
          "text": "Daca pentru un arbore binar avem un numar de N muchii, sa se determine numarul de muchii \ncritice ale arborelui?",
          "options": {
            "A": "N - 1",
            "B": "N + 1",
            "C": "N/2",
            "D": "(N +1 )/2",
            "E": "N"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Într-un arbore, fiecare muchie este critică deoarece eliminarea oricărei muchii ar deconecta arborele, împărțindu-l în două componente separate. Un arbore binar cu \\( N \\) muchii are exact \\( N \\) muchii critice, deoarece fiecare muchie este necesară pentru a menține conectivitatea și structura arborelui. Prin urmare, răspunsul corect este E: \\( N \\)."
        },
        {
          "id": 20,
          "text": "Daca avem un arbore binar plin cu 9 nivele,sa se determine numarul de varfuri ce se \nafla pe nivelul cu numarul 5?",
          "options": {
            "A": "15",
            "B": "31",
            "C": "2⁵",
            "D": "2⁴",
            "E": "14"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Într-un arbore binar complet, fiecare nivel \\( n \\) al arborelui are \\( 2^n \\) noduri. Acest lucru se datorează faptului că fiecare nod dintr-un arbore binar are exact doi copii, dublând numărul de noduri la fiecare nivel următor. Având un arbore binar cu 9 niveluri, trebuie să determinăm numărul de noduri la nivelul 5 (considerând nivelul rădăcină ca fiind nivelul 0).\n\nFolosind formula \\( 2^n \\), unde \\( n \\) este numărul nivelului, numărul de noduri la nivelul 5 este \\( 2^5 \\). Calculând aceasta, obținem \\( 2^5 = 32 \\). Totuși, se pare că a fost o neînțelegere în explicație—permiteți-mi să corectez:"
        },
        {
          "id": 21,
          "text": "Avand un arbore binar reprezentat prin urmatoarea expresie cu paranteze: \n1(2(3(0, 4(0, 0)), 5(6(0, 0), 7(0, 0))), 8(0, 9(0, 0))). Sa se determine numarul de frunze ale grafului.",
          "options": {
            "A": "4",
            "B": "3",
            "C": "5",
            "D": "9",
            "E": "6"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Într-un arbore binar, un „frunză” este un nod care nu are niciun copil. Expresia dată, 1(2(3(0, 4(0, 0)), 5(6(0, 0), 7(0, 0))), 8(0, 9(0, 0))), reprezintă un arbore binar folosind o structură imbricată în care fiecare nod este urmat de copilul său stâng și drept între paranteze. Un „0” indică absența unui copil, marcând astfel un nod ca fiind o frunză dacă ambii copii sunt „0”.\n\nSă descompunem arborele:\n- Nodul 3 are copii 0 și 4(0, 0). Nodul 4 este o frunză deoarece ambii copii sunt 0."
        },
        {
          "id": 22,
          "text": "Avand graful ponderat din figura 4, sa se determine un arbore de acoperire de cost minim. \nVom considera nodul A ca nod de plecare. Care este ordinea de parcurgere a nodurilor?",
          "image": "grafuri_22.png",
          "options": {
            "A": "A, C, B, D, E;",
            "B": "A, B, D, E, C;",
            "C": "A, D, E, C, B;",
            "D": "A, B, D, C, E;",
            "E": "A, B, E, B, D;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a determina un arbore de acoperire minim (MST) folosind un nod de pornire, cum ar fi nodul A, aplicăm de obicei algoritmi precum cel al lui Prim sau Kruskal. Având în vedere că problema specifică un nod de pornire, algoritmul lui Prim este mai relevant aici. Algoritmul lui Prim începe de la un nod ales și extinde MST-ul adăugând în mod repetat muchia cea mai ieftină de la arbore la un vârf care nu este încă în arbore.\n\nPornind de la nodul A, procesul implică:\n\n1. Selectarea muchiei cu greutatea cea mai mică care conectează A la un alt nod. Să presupunem că aceasta se conectează la nodul B.\n2. Din nodurile A și B, alegeți următoarea muchie cea mai mică care se conectează la un nod nou, continuând acest proces.\n3. Urmând această logică cu conexiunile cele mai puțin costisitoare, ordinea..."
        }
      ]
    },
    {
      "name": "Metode de analiza a algoritmilor",
      "questions": [
        {
          "id": 1,
          "text": "Care este expresia timpului de executie T(n) al urmatorului algoritm in cazul cel mai favorabil, \nin cazul mediu si in cazul cel mai defavorabil, unde n noteaza dimensiunea setului de intrare, \niar k, k1, ..., k8 - orice constanta pozitiva:",
          "image": "maa_1.png",
          "options": {
            "A": "k, k1n, k2n + k3",
            "B": "k1n + k2, k3n + k4, k5n + k6",
            "C": "k, k1n + k2, k2n² + k3n + k4",
            "D": "k1n + k2, k3n + k4, k5n² + k6n + k7",
            "E": "k, k1n² + k2n + k3, k4n² + k5n + k6",
            "F": "k1n + k2, k3n² + k4n + k5, k6n² + k7n + k8"
          },
          "correct_answer": [
            "F"
          ],
          "explanation": "Răspunsul corect este F deoarece reflectă în mod corespunzător modul în care complexitatea temporală a unui algoritm poate varia în funcție de scenariu (cel mai bun caz, caz mediu și cel mai rău caz) și de dimensiunea setului de intrare, \\( n \\).\n\n- **Cel mai bun caz (F: \\( k_1n + k_2 \\))**: Acest lucru sugerează că algoritmul se comportă liniar în raport cu dimensiunea intrării \\( n \\) în cel mai favorabil scenariu. Termenul liniar \\( k_1n \\) domină expresia, indicând că fiecare element este procesat de un număr constant de ori.\n\n- **Caz mediu (F: \\( k_3n^2 + k_4n + k_5 \\))**: Aceasta indică o complexitate temporală de ordin cuadratic, care"
        },
        {
          "id": 2,
          "text": "Determinati in care caz timpii de executie T1(n) si T2(n) au acelasi ordin de crestere, unde prin n\nnotam dimensiunea datelor de inrtare iar k noteaza o constanta oarecare pozitiva: ",
          "options": {
            "A": "lim (n → ∞) (T1(n)/T2(n)) = 0",
            "B": "lim (n → ∞) (T1(n)/T2(n)) = ∞",
            "C": "lim (n → ∞) (T1(n)/T2(n)) = k"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a determina dacă două funcții \\( T_1(n) \\) și \\( T_2(n) \\) au același ordin de creștere, folosim conceptul de echivalență asimptotică. Mai exact, se spune că două funcții cresc în același ritm dacă limita raportului lor este o constantă pozitivă pe măsură ce \\( n \\) tinde către infinit.\n\nÎn contextul întrebării cu alegere multiplă date, limita \\(\\lim_{n \\to \\infty} \\frac{T_1(n)}{T_2(n)} = k\\) (unde \\( k \\) este o constantă pozitivă) indică faptul că \\( T_1(n) \\) și \\( T_2(n) \\) cresc proporțional una cu cealaltă pentru valori mari ale lui \\( n \\)."
        },
        {
          "id": 3,
          "text": "Pentru lim (n → ∞) (f(n)/g(n)) = ∞, care din urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "f(n) ∈ ω(g(n))",
            "B": "f(n) ∈ Θ(g(n))",
            "C": "f(n) ∈ Ω(g(n))"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "a fi în \\(\\omega(g(n))\\).**\n\n- **B. \\(f(n) \\in O(g(n))\\):** Această notație înseamnă că \\(f(n)\\) nu crește mai repede decât o constantă înmulțită cu \\(g(n)\\) pentru valori mari ale lui \\(n\\). Totuși, condiția \\(\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = \\infty\\) sugerează că \\(f(n)\\) crește mult mai repede decât \\(g(n)\\), ceea ce contrazice definiția lui \\(f(n) \\in O(g(n))\\).\n\n- **C. \\(f(n) \\in o(g(n))\\):** Această notație înseamnă că \\(f(n)\\) crește mult mai încet decât \\(g(n)\\) pe măsură ce \\(n\\) tinde la infinit. Din nou, condiția \\(\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = \\infty\\) indică faptul că \\(f(n)\\) crește mai repede decât \\(g(n)\\), deci \\(f(n)\\) nu poate fi în \\(o(g(n))\\).\n\n- **D. \\(f(n) \\in \\Theta(g(n))\\):** Această notație înseamnă că \\(f(n)\\) și \\(g(n)\\) cresc la aceeași rată asimptotică. Totuși, deoarece \\(\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = \\infty\\), \\(f(n)\\) crește mai repede decât \\(g(n)\\), deci \\(f(n)\\) nu poate fi în \\(\\Theta(g(n))\\).\n\nConcluzionând, singura afirmație adevărată este A: \\(f(n) \\in \\omega(g(n))\\)."
        },
        {
          "id": 4,
          "text": "Pentru f(n) ∈ Θ(n) si g(n) ∈ Ω(n) atunci",
          "options": {
            "A": "f(n)g(n) ∈ Ω(n²)",
            "B": "f(n)g(n) ∈ Θ(n²)",
            "C": "f(n)g(n) ∈ O(n²)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a înțelege de ce răspunsul corect este A, să analizăm informațiile date:\n\n1. **f(n) ∈ Θ(n):** Aceasta înseamnă că f(n) crește liniar cu n. Mai exact, există constante pozitive c1, c2 și n0 astfel încât pentru toate n ≥ n0, c1n ≤ f(n) ≤ c2n.\n\n2. **g(n) ∈ Ω(n):** Aceasta indică faptul că g(n) crește cel puțin liniar cu n. Există o constantă pozitivă c3 și un n1 astfel încât pentru toate n ≥ n1, g(n) ≥ c3n.\n\nAcum, să considerăm produsul f(n)g(n):\n\n- Deoarece f(n) este delimitat între c..."
        },
        {
          "id": 5,
          "text": "Pentru f(n)=6n^3 + 14n^2 - 8n + 4 si g(n)=2n^3 care din urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "f(n), g(n) ∈ O(2n^3)",
            "B": "f(n), g(n) ∈ O(n^3)",
            "C": "f(n) ∈ O(6n^3) si g(n) ∈ O(2n^3)"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "Pentru a determina comportamentul asimptotic al funcțiilor \\( f(n) = 6n^3 + 14n^2 - 8n + 4 \\) și \\( g(n) = 2n^3 \\), folosim notația Big O, care descrie o limită superioară a ratei de creștere a unei funcții.\n\n- **f(n) = 6n^3 + 14n^2 - 8n + 4**: Termenul dominant este \\( 6n^3 \\), deci \\( f(n) \\) este asimptotic echivalent cu \\( 6n^3 \\). Astfel, \\( f(n) \\) este în \\( O(n^3) \\) deoarece termenul de gradul cel mai mare"
        },
        {
          "id": 6,
          "text": "Pentru f(n) ∈ Ω(n) si g(n) ∈ O(n2) atunci",
          "options": {
            "A": "(f(n) / g(n)) ∈ Ω(n)",
            "B": "(f(n) / g(n)) ∈ O(n)",
            "C": "(f(n) / g(n)) ∈ Θ(n)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a înțelege de ce răspunsul corect este B, să descompunem problema folosind definițiile notațiilor Big Omega (Ω) și Big O (O).\n\n1. **f(n) ∈ Ω(n)**: Aceasta înseamnă că f(n) crește cel puțin la fel de repede ca un multiplu constant al lui n pentru n suficient de mari. Cu alte cuvinte, există o constantă pozitivă c și o valoare n₀ astfel încât pentru toate n ≥ n₀, f(n) ≥ c * n.\n\n2. **g(n) ∈ O(n²)**: Aceasta înseamnă că g(n) crește cel mult la fel de repede ca un multiplu constant al lui n² pentru n suficient de mari. Cu alte cuvinte, există o constantă pozitivă C și o valoare n..."
        },
        {
          "id": 7,
          "text": "Pentru f(n) ∈ O(h(n)) si h(n) ∈ O(g(n)) atunci",
          "options": {
            "A": "functia f(n) este echivalenta cu g(n)",
            "B": "f(n) ∈ O(g(n))",
            "C": "f(n) ∈ Θ(g(n))"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Răspunsul corect este B: \\( f(n) \\in O(g(n)) \\).\n\nExplicație: Notația Big O, \\( O \\), este folosită pentru a descrie o limită superioară a ratei de creștere a unei funcții. Dacă \\( f(n) \\in O(h(n)) \\), înseamnă că rata de creștere a lui \\( f(n) \\) este cel mult rata de creștere a lui \\( h(n) \\), până la un factor constant. În mod similar, dacă \\( h(n) \\in O(g(n)) \\), aceasta implică faptul că rata de creștere a lui \\( h(n) \\) este cel mult rata de creștere a lui \\( g(n) \\), din nou până la un factor constant. Prin tranzitivitate, dacă \\( f(n) \\) este mărginită superior..."
        },
        {
          "id": 8,
          "text": "Pentru n - numar natural nenul si f(n) = 1 + 2 + ... + n atunci",
          "options": {
            "A": "f(n) ∈ O(n)",
            "B": "f(n) ∈ O(n²)",
            "C": "f(n) ∈ Θ(n²)"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "Pentru a rezolva această întrebare, trebuie să analizăm funcția \\( f(n) = 1 + 2 + \\ldots + n \\), care reprezintă suma primelor \\( n \\) numere naturale. Această sumă poate fi exprimată folosind formula:\n\n\\[ f(n) = \\frac{n(n + 1)}{2} \\]\n\nAceasta se simplifică aproximativ la:\n\n\\[ f(n) \\approx \\frac{n^2}{2} \\]\n\nAcum, să luăm în considerare notațiile big O și big Theta:\n\n- **Notația Big O (O)** descrie o limită superioară a ratei de creștere a unei funcții. În acest caz, deoarece \\( f(n) \\approx \\frac{n^2}{2} \\), aceasta crește cuadratic."
        },
        {
          "id": 9,
          "text": "Care este ordinul de complexitate al algoritmului de cautare binara?",
          "image": "maa_9.png",
          "options": {
            "A": "Ω(logn)",
            "B": "O(logn)",
            "C": "O(n)"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "Algoritmul de căutare binară este conceput pentru a găsi eficient un element într-un șir sortat prin împărțirea repetată a intervalului de căutare la jumătate. Această abordare reduce semnificativ numărul de comparații necesare.\n\nComplexitatea de timp a căutării binare este O(log n) deoarece, cu fiecare pas, spațiul de căutare este înjumătățit, ceea ce duce la un număr logaritmic de pași în raport cu dimensiunea șirului. Aceasta înseamnă că, în cel mai rău caz, numărul de operațiuni necesare este proporțional cu logaritmul numărului de elemente, n.\n\nNotația Ω(log n) se referă la cel mai bun caz, unde complexitatea de timp este, de asemenea, logaritmică. Acest lucru se întâmplă deoarece, chiar și în cel mai bun caz, unde elementul este găsit în mijlocul șirului la prima verificare,"
        },
        {
          "id": 10,
          "text": "Care este ordinul de complexitate al algoritmului de ridicare la putere al unui numar x^n?",
          "options": {
            "A": "Θ(n)",
            "B": "Θ(logn)",
            "C": "Θ(x^n)"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "Complexitatea calculării lui \\(x^n\\) poate varia în funcție de algoritmul folosit. Dacă folosim abordarea naivă, care implică înmulțirea lui \\(x\\) cu el însuși de \\(n\\) ori, complexitatea în timp este Θ(n). Totuși, o abordare mai eficientă este metoda \"exponențiere prin pătrare\" sau \"exponențiere binară\", care reduce numărul de înmulțiri necesare. Această metodă profită de reprezentarea binară a exponentului \\(n\\) și reduce complexitatea în timp la Θ(log n). Prin urmare, ambele opțiuni A și B sunt corecte, corespunzând metodelor naive și optimizate, respectiv."
        },
        {
          "id": 11,
          "text": "Care este ordinul de complexitate al functiei f(n) cu relatia de recurenta t(n)=2t(sqrt(n)) + logn?",
          "options": {
            "A": "f(n) ∈ O(lognlog(logn))",
            "B": "f(n) ∈ O(logn)",
            "C": "f(n) ∈ O(n^1/2)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Relația de recurență dată este \\( t(n) = 2t(\\sqrt{n}) + \\log n \\). Pentru a determina ordinea de complexitate, putem folosi Teorema Maestrului sau alte tehnici potrivite pentru analizarea relațiilor de recurență. Totuși, Teorema Maestrului nu este direct aplicabilă aici din cauza formei neobișnuite a \\( \\sqrt{n} \\).\n\nÎn schimb, putem transforma recurența pentru a o face mai ușor de analizat. Să fie \\( m = \\log n \\). Atunci, \\( n = 2^m \\) și \\( \\sqrt{n} = 2^{m/2} \\). Înlocuind acestea în recurență obținem:\n\n\\[ t(2^m) = 2t(2^{m/2}) \\]"
        },
        {
          "id": 12,
          "text": "Care este ordinul de crestere al unui algoritm avand timpul de executie de forma urmatoare:",
          "image": "maa_12.png",
          "options": {
            "A": "f(n) ∈ O(n²)",
            "B": "f(n) ∈ Θ(n²)",
            "C": "f(n) ∈ O(n)"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "În analiza algoritmilor, ordinul de creștere al unui algoritm este determinat de modul în care timpul său de execuție crește în funcție de dimensiunea intrării. În acest caz, timpul de execuție al algoritmului este dat de o formă care sugerează că depinde în principal de n², unde n este dimensiunea intrării.\n\n- Opțiunea A: f(n) ∈ O(n²) înseamnă că timpul de execuție crește cel mult proporțional cu n², ceea ce este adevărat pentru funcția dată, deoarece O(n²) oferă o limită superioară.\n\n- Opțiunea B:"
        },
        {
          "id": 13,
          "text": "Care este ordinul de crestere al unui algoritm avand timpul de executie de forma urmatoare:",
          "image": "maa_13.png",
          "options": {
            "A": "f(n) ∈ O(log2n)",
            "B": "f(n) ∈ O(logn)",
            "C": "f(n) ∈ O(lgn)"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "Întrebarea se referă la ordinea de creștere sau complexitatea temporală a unui algoritm cu o expresie specifică a timpului de execuție. Notația \\(O(\\cdot)\\) este folosită în informatică pentru a descrie limita superioară a timpului de rulare sau a cerințelor de spațiu ale unui algoritm în funcție de dimensiunea intrării \\(n\\).\n\nAici, timpul de execuție este exprimat în termeni de logaritmi, iar opțiunile arată diferite moduri de a reprezenta complexitatea logaritmică:\n\n- \\(O(\\log_2 n)\\) (opțiunea A) specifică logaritmi în baza 2.\n- \\(O(\\log n)\\) (opțiunea B) folosește o notație generală a logaritmului care, de obicei, implică baza 10 sau logaritmul natural; totuși, în notația Big O, diferențele de bază sunt factori constanți și nu afectează"
        },
        {
          "id": 14,
          "text": "Care este ordinul de crestere al algoritmului pentru problema Turnurilor din Hanoi avand timpul \nde executie de forma",
          "image": "maa_14.png",
          "options": {
            "A": "f(n) ∈ O(n)",
            "B": "f(n) ∈ O(2^n)",
            "C": "f(n) ∈ O(logn)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Problema Turnului din Hanoi este un exemplu clasic de algoritm recursiv, unde scopul este de a muta un teanc de discuri de pe un țăruș pe altul, folosind un al treilea țăruș ca auxiliar, respectând anumite reguli. Soluția recursivă implică mutarea a \\( n-1 \\) discuri pe țărușul auxiliar, apoi mutarea discului cel mai mare direct pe țărușul țintă și, în final, mutarea celor \\( n-1 \\) discuri de pe țărușul auxiliar pe țărușul țintă.\n\nComplexitatea de timp a acestui algoritm poate fi descrisă de relația de recurență:\n\n\\[ T(n) = 2T(n-1) + 1 \\]\n\nAceastă recurență se rezolvă ca \\( T(n) = 2^n - 1 \\), ceea ce reprezintă o creștere exponențială. Prin urmare, ordinea de"
        },
        {
          "id": 15,
          "text": "Care este ordinul de crestere al unui algoritm avand timpul de executie de forma urmatoare:",
          "image": "maa_15.png",
          "options": {
            "A": "f(n) ∈ O(n)",
            "B": "f(n) ∈ O(2^logn)",
            "C": "f(n) ∈ O(logn)"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "Întrebarea se referă la ordinea de creștere a unui algoritm a cărui timp de execuție este reprezentat într-o formă specifică.\n\n- Opțiunea A, \\( f(n) \\in O(n) \\), indică faptul că complexitatea timpului crește liniar cu dimensiunea intrării \\( n \\). Aceasta este o complexitate comună pentru algoritmi care parcurg toate elementele intrării o singură dată.\n\n- Opțiunea B, \\( f(n) \\in O(2^{\\log n}) \\), se simplifică la \\( O(n) \\) deoarece \\( 2^{\\log n} = n \\). Prin urmare, și aceasta reprezintă o creștere liniară.\n\n- Opțiunea C, \\( f(n) \\in O(\\log n) \\), reprezintă o creștere logaritmică, care nu este echivalentă cu forma dată, prin urmare"
        },
        {
          "id": 16,
          "text": "Care este ordinul de complexitate al algoritmului mergesort avand relatia de \nrecurenta t(n) = 2t(n/2) + Θ(n)?",
          "options": {
            "A": "f(n) ∈ Θ(nlogn)",
            "B": "f(n) ∈ Θ(n)",
            "C": "f(n) ∈ Θ(n+nlogn)"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "Relația de recurență pentru algoritmul mergesort este dată de \\( T(n) = 2T(n/2) + \\Theta(n) \\). Această relație poate fi înțeleasă astfel:\n\n- Problema de dimensiune \\( n \\) este împărțită în două subprobleme de dimensiune \\( n/2 \\), ceea ce sugerează termenul \\( 2T(n/2) \\).\n- Termenul \\( \\Theta(n) \\) reprezintă complexitatea de timp pentru a combina cele două jumătăți sortate înapoi împreună.\n\nPentru a determina complexitatea generală, putem folosi Teorema Maestrului, care este aplicabilă relațiilor de recurență de forma \\( T(n) = aT(n/b) + f(n) \\), unde:\n\n- \\( a \\) este numărul"
        },
        {
          "id": 17,
          "text": "Sa se indice ordinul de crestere al functiei f(n) cu urmatoarea relatie de recurenta:",
          "image": "maa_17.png",
          "options": {
            "A": "f(n) ∈ O(n²)",
            "B": "f(n) ∈ Θ(n)",
            "C": "f(n) ∈ O(logn)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a determina ordinea de creștere a funcției \\( f(n) \\) dată de o relație de recurență, de obicei analizăm recurența pentru a identifica comportamentul său asimptotic. Dacă răspunsul corect este \\( B. f(n) \\in \\Theta(n) \\), aceasta implică faptul că relația de recurență descrie o funcție care crește liniar cu \\( n \\). Notația \\( \\Theta(n) \\) înseamnă că \\( f(n) \\) este mărginită atât superior, cât și inferior de funcții liniare de \\( n \\). Acest lucru sugerează că relația de recurență se simplifică la o formă în care termenul dominant este proporțional cu \\( n \\), indicând o ordine de creștere liniară. Înțelegerea structurii relației de recurență, cum ar fi cazul de bază și pasul recursiv, este esențială pentru a confirma acest lucru."
        },
        {
          "id": 18,
          "text": "Sa se indice ordinul de crestere al functiei f(n) cu urmatoarea relatie de recurenta:",
          "image": "maa_18",
          "options": {
            "A": "f(n) ∈ O(n!)",
            "B": "f(n) ∈ O(n²)",
            "C": "f(n) ∈ O(n)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a determina ordinea de creștere a funcției \\( f(n) \\) dată de o relație de recurență, trebuie să analizăm cum se comportă funcția pe măsură ce \\( n \\) crește. Dacă relația de recurență sugerează că \\( f(n) \\) este construită prin înmulțirea sau combinarea termenilor într-un mod care seamănă cu creșterea factorială, atunci funcția va crește foarte rapid, similar cu \\( n! \\).\n\nFuncția factorială \\( n! \\) crește mai rapid decât funcțiile polinomiale, cum ar fi \\( n^2 \\), sau funcțiile liniare, cum ar fi \\( n \\). Prin urmare, dacă relația de recurență implică înmulțirea cu termeni care cresc rapid odată cu \\( n \\), aceasta se aliniază cu modelul de creștere \\( O(n!) \\), făcând-o răspunsul corect.\n\nÎn acest caz, recurența probabil"
        },
        {
          "id": 19,
          "text": "Sa se indice ordinul de crestere al functiei f(n) cu urmatoarea relatie de recurenta:",
          "image": "maa_19",
          "options": {
            "A": "f(n) ∈ Θ(n)",
            "B": "f(n) ∈ Θ(n+nlogn)",
            "C": "f(n) ∈ Θ(nlogn)"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "Pentru a determina ordinea de creștere a funcției \\( f(n) \\) dintr-o relație de recurență, de obicei folosești metode precum Teorema Maestrului sau metoda substituției iterative, în funcție de forma recurenței. Scopul este de a exprima complexitatea temporală în notația Big Theta, care descrie o limită asimptotică strânsă.\n\nPentru această întrebare, dacă răspunsurile corecte sunt \\( B \\) și \\( C \\), aceasta implică faptul că relația de recurență conduce la o funcție care crește proporțional cu atât \\( n + n\\log{n} \\), cât și \\( n\\log{n} \\). Acest lucru sugerează de obicei că ordinea de creștere a funcției este dominată de termenul \\( n\\log{n} \\), dar forma \\("
        },
        {
          "id": 20,
          "text": "Care din urmatoarele interpretari fac adevarata formula F ilustrata in graficul din Figura 5?",
          "image": "maa_20",
          "options": {
            "A": "x1 = true, x2 = true, x3 = true",
            "B": "x1 = false, x2 = true, x3 = false",
            "C": "x1 = true, x2 = false, x3 = true"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a determina care interpretare face formula \\( F \\) adevărată, trebuie să analizăm atribuțiile de adevăr pentru variabilele \\( x1 \\), \\( x2 \\) și \\( x3 \\) așa cum sunt date în opțiuni. Răspunsul corect este opțiunea B: \\( x1 = \\text{fals} \\), \\( x2 = \\text{adevărat} \\), \\( x3 = \\text{fals} \\). Această combinație specifică satisface formula \\( F \\), așa cum este arătat în graficul din Figura 5. De obicei, aceasta înseamnă că, pe baza operațiunilor logice ilustrate (cum ar fi ȘI, SAU, NU), doar atunci când \\( x1 \\) este fals, \\( x2 \\) este adevărat, și \\( x3 \\) este"
        }
      ]
    },
    {
      "name": "Arhitectura calculatoarelor",
      "questions": [
        {
          "id": 1,
          "text": "Exprimati in binar, octal, hexazecimal numarul zecimal 3.625",
          "options": {
            "A": "11.2000; 3.42; 4.20;",
            "B": "11.101; 3.5; 3.A;",
            "C": "2.1001; 3.52; 2D;",
            "D": "11.10000; 3.20; 3.2A;",
            "E": "11.10000; 2.42; 3.2;"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a exprima numărul zecimal 3.625 în binar, octal și hexazecimal, convertim fiecare parte separat:\n\n1. **Conversia în Binar**:\n   - Partea întreagă \\(3\\) în binar este \\(11\\).\n   - Partea fracționară \\(0.625\\) se convertește prin înmulțire cu 2:\n     - \\(0.625 \\times 2 = 1.25\\) (luăm partea întreagă \\(1\\))\n     - \\(0.25 \\times 2 = 0.5\\) (luăm partea întreagă \\(0\\))\n     - \\(0.5 \\times 2 = 1.0\\) (luăm partea întreagă \\(1\\))\n   - Combinăm aceste rezultate"
        },
        {
          "id": 2,
          "text": "Convertiti in zecimal numerele urmatoare (baza este indicata in indice): DA.C₁₆, 27.4₈, 11011.101₂",
          "options": {
            "A": "216.5; 17.5; 27.52;",
            "B": "218.75; 23.5; 27.625;",
            "C": "218.75; 22.5; 26.5;",
            "D": "218.5; 23.5; 27.6;",
            "E": "218.75; 23.55; 27.625;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a converti numere din diferite baze în zecimal:\n\n1. **DA.C₁₆ (Hexazecimal la Zecimal):**\n   - D în hexazecimal este 13 în zecimal.\n   - A în hexazecimal este 10 în zecimal.\n   - Numărul DA.C₁₆ se calculează astfel:\n     \\((13 \\times 16^1) + (10 \\times 16^0) + (12 \\times 16^{-1}) = 208 + 10 + 0.75 = 218.75\\).\n\n2. **27:4₈ (Octal la Zecimal):**\n   - 2 în octal este 2 în zecimal.\n   - 7 în octal este 7 în"
        },
        {
          "id": 3,
          "text": "Dati valoarea zecimala cu semn a numarului B7₁₆ codificat in complement fata de 1 (cod invers)",
          "options": {
            "A": "+7.2",
            "B": "71;",
            "C": "72;",
            "D": "-71;",
            "E": "-72;"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Pentru a decodifica numărul hexadecimal B7₁₆ folosind codul invers (complement față de unu), trebuie mai întâi să-l convertim în binar. Cifra hexadecimală 'B' este '1011' în binar, iar '7' este '0111'. Astfel, B7₁₆ devine 10110111 în binar.\n\nÎn notația complement față de unu, bitul cel mai din stânga este bitul de semn, unde '1' indică un număr negativ. Deoarece primul bit al lui 10110111 este '1', numărul este negativ.\n\nPentru a găsi magnitudinea, luăm complementul față de unu al numărului: inversăm toți biții lui 10110111 pentru a obține 01001000. Acest număr binar este egal cu 72 în zecimal.\n\nPrin urmare, numărul..."
        },
        {
          "id": 4,
          "text": "Dati pe 8 biti (in hexazecimal) reprezentarea in complement fata de 2 (cod complementar) a valorii  \nintregi negative -32.",
          "options": {
            "A": "E3",
            "B": "E0;",
            "C": "E1;",
            "D": "E2;",
            "E": "DF;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a găsi reprezentarea în complement față de doi pe 8 biți a numărului întreg negativ -32, urmați acești pași:\n\n1. **Găsiți reprezentarea binară a numărului întreg pozitiv 32**:  \n   Reprezentarea binară a lui 32 este `00100000`.\n\n2. **Inversați cifrele (găsiți complementul față de unu)**:  \n   Inversați fiecare bit al lui `00100000` pentru a obține `11011111`.\n\n3. **Adăugați 1 la complementul față de unu pentru a găsi complementul față de doi**:  \n   Adăugați 1 la `11011111`:\n\n   ```\n   11011111\n+        1\n   --------\n   11100000\n   ```\n\n4. **Convertiți rezultatul binar în hexazecimal**:"
        },
        {
          "id": 5,
          "text": "Dati sub forma a x 2ᵇ (a si b in sistemul zecimal) valoarea care corespunde reprezentarii in VMSP \n(virgula mobila simpla precizie, adica: 1 bit = semnul mantisei, 8 biti = exponentul decalat, \n23 biti = mantisa normalizata), 27660000000₈",
          "options": {
            "A": "0.8 x 2⁴;",
            "B": "-0.5 x 2⁻³;",
            "C": "-8.8 x 2⁴;",
            "D": "-8.8125 x 2⁻⁴;",
            "E": "-100;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a determina valoarea reprezentată de numărul octal 27660000000₈ în formatul de virgulă mobilă cu precizie simplă (VMSP), trebuie să urmăm acești pași:\n\n1. **Convertiți numărul octal în binar:**\n   Numărul octal 27660000000₈ se convertește în binar ca 010 111 110 110 000 000 000 000 000 000₂. Eliminăm zerourile de început pentru a obține 1011111011000000000000000000₂.\n\n2. **Identificați componentele reprezentării în virgulă mobilă:**\n   - **Bitul de semn (1 bit):** Primul bit este 1, indicând un număr negativ.\n   - **Exponentul (8 biți):** Următorii"
        },
        {
          "id": 6,
          "text": "Dati reprezentarea interna, exprimata in hexazecimal), in VMSP (virgula mobila simpla precizie, \nadica: 1 bit = semnul mantisei,8 biti = exponentul decalat,\n23 biti = mantisa normalizata) pentru \nvaloarea zecimala -6.25.",
          "options": {
            "A": "44C58000;",
            "B": "C1E40000;",
            "C": "C4B59000;",
            "D": "C4C58000;",
            "E": "CDFAA000;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a găsi reprezentarea internă a valorii zecimale -6.25 în formatul de virgulă mobilă cu precizie simplă (VMSP), trebuie să urmăm acești pași:\n\n1. **Bitul de semn**: Deoarece numărul este negativ, bitul de semn este 1.\n\n2. **Conversie în binar**: Valoarea absolută a lui -6.25 este 6.25. În binar, 6 este reprezentat ca 110, iar 0.25 este reprezentat ca 0.01. Prin urmare, 6.25 în binar este 110.01.\n\n3. **Normalizarea numărului binar**: Normalizați reprezentarea binară pentru a se potrivi formei 1.xxxxx... × 2^n. Pentru 110.01, îl normalizăm la"
        },
        {
          "id": 7,
          "text": "Fie o transmisie care utilizeaza codul lui Hamming cu paritate para. Gasiti mesajul transmis ( in octal) \nstiind ca reprezentarea datelor de transmis (pe 16 biti) este 7B₁₆",
          "options": {
            "A": "3724",
            "B": "3723;",
            "C": "3726;",
            "D": "3725;",
            "E": "3727;"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Pentru a rezolva această problemă, trebuie să înțelegem cum funcționează codurile Hamming și paritatea, apoi să aplicăm aceste cunoștințe datelor hexadecimale furnizate.\n\n1. **Conversia din Hexazecimal în Binar**:\n   Datele furnizate pentru a fi transmise sunt 7B₁₆. Mai întâi, convertim acest număr hexazecimal într-o reprezentare binară.\n\n   - 7₁₆ = 0111₂\n   - B₁₆ = 1011₂\n\n   Astfel, 7B₁₆ în binar este 01111011₂.\n\n2. **Conversia din Binar în Octal**:\n   Numărul binar 01111011₂ trebuie convertit în octal. Pentru a face acest lucru, grupăm cifrele binare în seturi de"
        },
        {
          "id": 8,
          "text": "Fie o transmisie care utilizeaza codul lui Hamming cu paritate impara. Regasiti ( in octal) mesajul \ninitial (corectand eventualele erori daca mesajul primit (pe 21 biti) este 6130014 (in octal).",
          "options": {
            "A": "140441₈;",
            "B": "141441₈;",
            "C": "142442₈;",
            "D": "C522₁₆;",
            "E": "C321₁₆;"
          },
          "correct_answer": [
            "B",
            "E"
          ],
          "explanation": "Pentru a rezolva această problemă, trebuie să înțelegem cum funcționează codurile Hamming cu paritate impară și cum să decodificăm mesajul octal dat pentru a identifica și corecta eventualele erori.\n\n1. **Înțelegerea codului Hamming și a parității**: Codurile Hamming sunt utilizate pentru detectarea și corectarea erorilor. În acest caz, codul folosește paritate impară, ceea ce înseamnă că numărul de biți de 1 într-un grup de biți trebuie să fie impar.\n\n2. **Conversia din octal în binar**: Mesajul primit este dat în octal (baza 8), așa că mai întâi îl convertim în binar (baza 2) pentru o manipulare mai ușoară. Fiecare cifră octală corespunde unei secvențe binare de 3 biți. De exemplu, cifra octală '6' este '110' în binar."
        },
        {
          "id": 9,
          "text": "Fie o transmisie care utilizeaza metoda codurilor polinomiale (CRC) prin intermediul polinomului \ngenerator G(x) = x³ + x + 1. Daca se doreste transmiterea datelor (7 biti) cu reprezentarea octala \n131, care va fi mesajul trimis?",
          "options": {
            "A": "25DC₁₆",
            "B": "1313₈;",
            "C": "2CB₁₆;",
            "D": "22734₈;",
            "E": "22735₁₀;"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "Pentru a rezolva această problemă, trebuie să înțelegem cum funcționează Verificarea Redundanței Ciclice (CRC) folosind un polinom generator dat. Polinomul generator furnizat este \\( G(x) = x^3 + x + 1 \\), care corespunde numărului binar 1011.\n\n1. **Convertiți datele octale în binar**: Datele date sunt 131 în octal, care se convertesc în binar după cum urmează:\n   - 1 în octal este 001 în binar.\n   - 3 în octal este 011 în binar.\n   - 1 în octal din nou este 001 în binar.\n   - Prin urmare, 131 în octal este 001 011 001 în binar, care se simplifică la 101."
        },
        {
          "id": 10,
          "text": "Fie o transmisie care utilizeaza metoda codurilor polinomiale (CRC) prin intermediul polinomului \ngenerator G(x) = x² + x + 1. Daca s-a receptionat mesajul T = 2332₈ (11 biti) sa se stabileasca \ndaca a fost trimis corect, iar daca raspunsul este afirmativ sa se afle mesajul M initial.",
          "options": {
            "A": "132₁₀;",
            "B": "464₈;",
            "C": "134₁₆;",
            "D": "136₁₆;",
            "E": "466₈;"
          },
          "correct_answer": [
            "D",
            "E"
          ],
          "explanation": "Pentru a determina dacă mesajul a fost transmis corect folosind metoda CRC cu polinomul generator \\( G(x) = x^2 + x + 1 \\), trebuie să efectuăm o verificare CRC asupra mesajului primit.\n\n1. **Convertirea Mesajului Primit în Binar**: Mesajul primit \\( T = 2332_8 \\) trebuie convertit în binar. \\( 2332_8 \\) este reprezentat în binar ca \\( 010011011010_2 \\).\n\n2. **Efectuarea Verificării CRC**: Pentru a verifica dacă mesajul a fost transmis corect, efectuați o diviziune binară a mesajului binar primit cu echivalentul binar al polinomului generator. Polinomul generator \\( G(x) = x^2 + x + 1 \\) se traduce"
        },
        {
          "id": 11,
          "text": "Reduceti expresia formei normale disjunctive (cu mintermeni) a functiei logice \nf(a, b, c) = ābc + ab̄c + ab̄c̄ + abc̄ + abc",
          "options": {
            "A": "ā + bc",
            "B": "a + bc;",
            "C": "a + b̄c;",
            "D": "ā + b;",
            "E": "a + b̄."
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a reduce funcția logică dată \\( f(a, b, c) = \\overline{a}bc + ab̄c + ab̄c̄ + abc̄ + abc \\) la forma sa cea mai simplă, putem aplica regulile algebrei booleene.\n\n1. **Combinarea Termenilor prin Teorema Consensului**:\n   - Termenii \\( abc \\) și \\( abc̄ \\) pot fi combinați în \\( ab \\) folosind teorema consensului: \\( abc + abc̄ = ab \\).\n   - Termenii \\( ab̄c \\) și \\( ab̄c̄ \\) pot fi combinați în \\( ab̄ \\) folosind teorema consensului: \\( ab̄c + ab̄c̄ \\)."
        },
        {
          "id": 12,
          "text": "Reduceti expresia formei normale disjunctive (cu mintermeni) a functiei logice de 4 variabile care \nia valoarea 1 daca pqrs vazut ca numar binar are o valoare mai mica deca 10.",
          "options": {
            "A": "p̄ + q̄r̄;",
            "B": "p̄qr + pq̄ + pq;",
            "C": "p + p̄q̄s;",
            "D": "pqr + r̄;",
            "E": "pq + qr + rs."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a rezolva această problemă, trebuie să exprimăm condiția ca numărul binar cu 4 variabile \\( pqrs \\) să fie mai mic decât 10 în formă normală disjunctivă (DNF) folosind mintermi.\n\nÎn binar, numerele de la 0 la 9 sunt reprezentate astfel:\n- 0: 0000\n- 1: 0001\n- 2: 0010\n- 3: 0011\n- 4: 0100\n- 5: 0101\n- 6: 0110\n- 7: 0111\n- 8: 1000\n- 9: 1001\n\nPentru valorile mai mici decât 10, bitul de început"
        },
        {
          "id": 13,
          "text": "Se considera urmatorul continut al registrelor si al memoriei: (XR1) = 1; (1000) = 0; (3000) = 4;\n(B2) = 2000; (2000) = 2; (B1) = 1000; (1001) = 1; (3001) = 5; (2001) = 3; (0) = 1000.\nCare este valoarea lui F dupa executia programului urmator: 1) LOAD 3000; 2) LOAD 2000,\nXR1; 3) SUB 2001,B1 4) MPY 1001,B2; 5) DIV 2000; 6) ADD 1000, IM; 7) SUB 0,I,XR1;\n8) STA F;",
          "options": {
            "A": "1001;",
            "B": "1002;",
            "C": "1003;",
            "D": "1004;",
            "E": "1005;"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Pentru a determina valoarea lui F după executarea programului dat, trebuie să urmărim fiecare instrucțiune pas cu pas, luând în considerare condițiile inițiale furnizate:\n\n1. **LOAD 3000**: Încarcă valoarea din adresa de memorie 3000 în acumulator. (3000) = 4, deci acumulatorul = 4.\n\n2. **LOAD 2000, XR1**: Încarcă valoarea din adresa de memorie (2000 + XR1) în acumulator. XR1 = 1, deci adresa = 2000 + 1 = 2001. (2001) = 3, deci acumulatorul = 3.\n\n3. **SUB 2001, B1**: Scade valoarea de la adresa de memorie (2001 +"
        },
        {
          "id": 14,
          "text": "Se considera o memorie centrala unde fiecare octet este adresat separat. Calculati in hexazecimal adresa \ncelui de-al 7-lea element al unui tablou cu adresa primului element 1000 si fiecare element 16 are 16 biti.",
          "options": {
            "A": "1008;",
            "B": "1009;",
            "C": "100A;",
            "D": "100B;",
            "E": "100C;"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Pentru a rezolva această problemă, trebuie să determinăm adresa celui de-al 7-lea element dintr-un tablou în care fiecare element are 16 biți, iar adresa primului element este dată ca fiind 1000 în hexazecimal.\n\n1. **Înțelegerea dimensiunii fiecărui element**: Fiecare element are 16 biți, ceea ce este echivalent cu 2 octeți (deoarece 1 octet = 8 biți).\n\n2. **Calcularea decalajului de adresă pentru al 7-lea element**:\n   - Primul element este la adresa 1000.\n   - Al doilea element este la 2 octeți după primul element, deci este la adresa 1000 + 2.\n   - Al treilea element este la 2 octeți..."
        },
        {
          "id": 15,
          "text": "Se considera o memorie intretesuta constituita din doua unitati de cate 4 Mo. \nStiind ca adresa de memorie se constituie pe 23 de biti astfel: 1 bit identifica superunitatea, 20 biti specifica adresa in \ncadrul unitatii, iar ultimii 2 biti octetul din cadrul cuvantului), sa se identifice ( in zecimal) linia  \nintr-o memorie cache de 1Ko precum si bitii de pondere mare ai adresei de memorie A = 10000.",
          "options": {
            "A": "600; 42;",
            "B": "600; 2;",
            "C": "452; 42;",
            "D": "600; 24;",
            "E": "452; 2;"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Pentru a rezolva această problemă, trebuie să analizăm structura memoriei și a sistemului de cache, folosind formatul de adresă de 23 de biți dat:\n\n1. **Înțelegerea structurii adresei:**\n   - Adresa are 23 de biți.\n   - Primul bit (1 bit) identifică superunitatea.\n   - Următorii 20 de biți specifică adresa din cadrul unității.\n   - Ultimii 2 biți specifică octetul din cadrul cuvântului.\n\n2. **Calcularea liniei de cache:**\n   - Cache-ul are 1 Ko (care este 1024 octeți).\n   - Deoarece fiecare unitate este de 4 Mo, fiecare unitate are \\(4 \\times 1024 \\times 1024 = 4194304\\) octeți."
        },
        {
          "id": 16,
          "text": "Presupunem ca o adresa in memoria virtuala paginata, necesita 20 de biti organizati astfel: offset\n(cuvant): bitii de la 0 la 11; pagina: bit¸ii de la 12 la 19; Care este adresa octala a celui de-al 970-lea\ncuvant de la pagina 213 ?",
          "options": {
            "A": "3251718;",
            "B": "3251711;",
            "C": "3261711;",
            "D": "3261811;",
            "E": "3271711;"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a determina adresa octală a celui de-al 970-lea cuvânt de pe pagina 213 într-un sistem de memorie virtuală paginată, urmați acești pași:\n\n1. **Înțelegeți Structura Adresei:**\n   - Adresa virtuală este compusă din două părți:\n     - **Numărul paginii**: biții 12 până la 19\n     - **Offset**: biții 0 până la 11\n\n2. **Convertiți Pagina și Offset-ul în Binar:**\n   - Numărul paginii este 213 în zecimal.\n   - Convertiți 213 în binar: \\(213_{10} = 11010101_2\\). Acesta se potrivește în 8 biți (biții 12-19).\n   - Offset-ul pentru cel de-al 970-lea cuvânt este 970 în zecimal."
        },
        {
          "id": 17,
          "text": "Presupunem ca o adresa in memoria virtuala paginata, necesita 20 de biti organizati astfel: \noffset (cuvant): bitii de la 0 la 11; pagina: bitii de la 12 la 19; Care este numarul cuvantului si numarul \nde pagina pentru adresa hexazecimala ABCDE? Dati rezultatul in zecimal.",
          "options": {
            "A": "4000; 171;",
            "B": "3295; 170;",
            "C": "3294; 171;",
            "D": "4500; 200;",
            "E": "2951; 117;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a rezolva această problemă, trebuie să descompunem adresa hexazecimală ABCDE în echivalentul său binar și apoi să extragem biții relevanți așa cum sunt definiți de problemă.\n\n1. **Convertirea Hexazecimalului în Binar:**\n   - Adresa dată este ABCDE în hexazecimal.\n   - Convertirea fiecărei cifre în binar:\n     - A = 1010\n     - B = 1011\n     - C = 1100\n     - D = 1101\n     - E = 1110\n   - Deci, ABCDE în binar este: 1010 1011 1100 1101 1110\n\n2. **Extrageți Biții Relevanți:**\n   - Conform problemei, adresa este împărțită în:"
        },
        {
          "id": 18,
          "text": "Presupunem ca o adresa in memoria virtuala segmentatasi paginata, necesita 24 de biti organizati \nastfel: offset (cuvant): bitii de la 0 la 7; pagina: bitii de la 8 la 17; segment: bitii de la 18 la 23; \nCare este adresa octala a celui de-al 145-lea cuvant de la pagina 111 a segmentului al 32-lea?",
          "options": {
            "A": "37067620;",
            "B": "32517180;",
            "C": "32517160;",
            "D": "37007620;",
            "E": "37062620;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a determina adresa octală pentru cuvântul, pagina și segmentul specificat, trebuie să înțelegem cum este structurată adresa virtuală și apoi să o convertim într-o reprezentare octală. Adresa este organizată în trei părți, fiecare cu o alocare specifică de biți:\n\n1. **Offset (cuvânt):** Biții 0 până la 7. Acesta este un câmp de 8 biți.\n2. **Pagina:** Biții 8 până la 17. Acesta este un câmp de 10 biți.\n3. **Segment:** Biții 18 până la 23. Acesta este un câmp de 6 biți.\n\nDat fiind:\n- Al 145-lea cuvânt corespunde unei valori de offset de 144 (deoarece offset-ul începe de la 0).\n- A 111-a pagină este"
        },
        {
          "id": 19,
          "text": "Presupunem ca o adresa in memoria virtuala segmentatasi paginata, necesita 24 de biti organizati \nastfel: offset (cuvant): bitii de la 0 la 7; pagina: bitii de la 8 la 17; segment: bitii de la 18 la 23; \nCare este numarul cuvantuluisi numarul de pagina pentru adresa hexazecimala ABCDE? Dati rezultatul in zecimal.",
          "options": {
            "A": "144; 111; 31;",
            "B": "150; 120; 131;",
            "C": "119; 053; 33;",
            "D": "150; 111; 131;",
            "E": "155; 120; 131;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a rezolva problema, trebuie să descompunem adresa hexazecimală ABCDE în forma sa binară și apoi să separăm segmentele conform pozițiilor de biți specificate pentru offset, pagină și segment.\n\n1. **Conversia ABCDE în Binar**: Numărul hexazecimal ABCDE se convertește în binar astfel:\n   - A = 1010\n   - B = 1011\n   - C = 1100\n   - D = 1101\n   - E = 1110\n   Prin urmare, ABCDE în binar este: 1010 1011 1100 1101 1110.\n\n2. **Organizarea într-o Adresă Virtuală de 24 de biți**: Deoarece problema specifică o adresă de 24 de biți, ia în considerare doar"
        },
        {
          "id": 20,
          "text": "Care este efectul urmatoarei secvente de instructiuni care se executa pe o masina cu programare \npe zero adrese: 1) LOAD B; 2) LOAD C; 3) LOAD D 4) LOAD E; 5) DIV ; 6) ADD ;\n7) LOAD F; 8) LOAD G; 9) MPY ; 10) ADD ; 11) MPY ; STA R;",
          "options": {
            "A": "R = B × (C + D/E + F × G);",
            "B": "R = B/(C + D/E + F × G);",
            "C": "R = B × (C + D/E − F × G);",
            "D": "R = B × (C + D/E + F/G);",
            "E": "R = B × (C + D × E + F × G);"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Secvența de instrucțiuni operează într-un mediu bazat pe stivă, tipic pentru mașinile cu zero adrese, ceea ce înseamnă că se bazează pe o stivă implicită pentru a gestiona operanzii pentru operații precum înmulțirea, împărțirea și adunarea. Iată o descriere pas cu pas a instrucțiunilor:\n\n1. `LOAD B`: Împinge B pe stivă.\n2. `LOAD C`: Împinge C pe stivă.\n3. `LOAD D`: Împinge D pe stivă.\n4. `LOAD E`: Împinge E pe stivă.\n5. `DIV`: Scoate ultimele două valori (D și E), împarte D la E și împinge rezultatul înapoi pe stivă.\n6. `ADD`: Scoate ultimele două valori (C și rezultatul lui D/E), le adună și împinge rezultatul pe stivă."
        }
      ]
    },
    {
      "name": "Sisteme de operare si Proiectarea sistemelor de operare",
      "questions": [
        {
          "id": 1,
          "text": "Apelul sistem SLEEP produce:",
          "options": {
            "A": "trecerea producatorului in starea BLOCAT daca buffer-ul este gol",
            "B": "blocarea procesului pana cand un altul il trezeste prin WAKEUP",
            "C": "blocarea procesului pana cand un altul lanseaza apelul SLEEP",
            "D": "trecerea procesului precizat de parametrul apelului in starea GATA"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Răspunsul corect este B. În sistemele de operare, apelul de sistem `SLEEP` este utilizat pentru a bloca sau suspenda execuția unui proces până când o anumită condiție este îndeplinită sau are loc un eveniment extern. În acest context, opțiunea B este explicația corectă deoarece descrie comportamentul în care un proces este blocat sau pus în așteptare până când un alt proces îl trezește folosind apelul `WAKEUP`. Acest mecanism este utilizat frecvent în sincronizarea proceselor pentru a preveni consumul de resurse CPU de către un proces în timp ce așteaptă ca o anumită condiție sau resursă să devină disponibilă."
        },
        {
          "id": 2,
          "text": "Planificarea preemptiva este strategia de planificare conform careia:",
          "options": {
            "A": "un proces nu poate fi suspendat temporar daca este in starea GATA",
            "B": "un proces care din punct de vedere logic poate fi executat este temporar suspendat",
            "C": "unprocesodatalansat inexecutienumaiestesuspendatatuncicandpoatefi inexecutie",
            "D": "un proces nu poate fi suspendat temporar daca este in starea BLOCAT"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Planificarea preemptivă este o strategie în care sistemul de operare poate suspenda temporar un proces care rulează în prezent pentru a aloca CPU-ul unui alt proces. Această abordare permite o utilizare mai eficientă a resurselor CPU, asigurându-se că procesele cu prioritate mai mare sau cele care sunt pregătite să fie executate pot avea prioritate față de altele. În contextul opțiunilor date, opțiunea B descrie corect acest comportament, evidențiind capacitatea de a suspenda temporar un proces care ar putea fi executat logic, în favoarea unui alt proces. Acest lucru asigură că sistemul rămâne receptiv și se poate adapta la cerințe sau priorități în schimbare."
        },
        {
          "id": 3,
          "text": "Planificarea Round-Robin:",
          "options": {
            "A": "determina atribuirea unei cunate de timp in care procesului ii este permis sa ruleze",
            "B": "determina suspendarea unui proces intr-un moment arbitrar",
            "C": "determina atribuirea unei prioritati fixe pentru executia unui proces",
            "D": "determina lansarea in executie a unui proces daca nu exista altul mai prioritar in executie"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Planificarea Round-Robin este o tehnică de management al proceselor în sistemele de operare care implică alocarea fiecărui proces activ unui interval de timp fix, numit cota de timp sau \"time slice\". Aceasta permite fiecărui proces să ruleze pentru această perioadă determinată înainte de a trece la următorul proces în coadă, asigurându-se astfel o distribuție echitabilă a resurselor procesorului între toate procesele. De aceea, răspunsul corect este A, deoarece descrie exact acest mecanism de alocare a timpului pentru execuția proceselor."
        },
        {
          "id": 4,
          "text": "Care din urmatoarele functiuni sunt indeplinite de sistemul calculator hardware generator de baza:",
          "options": {
            "A": "functia de conservare a informatiei",
            "B": "functia de generare a informatiei",
            "C": "functia de prelucrare a informatiei",
            "D": "functia de receptionare a informatiei"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "Un sistem calculator hardware generator de bază îndeplinește mai multe funcții esențiale legate de gestionarea informației.\n\n- **Funcția de conservare a informației (A):** Aceasta implică stocarea datelor în memoria sistemului pentru utilizare ulterioară. Hardware-ul, cum ar fi hard disk-urile sau SSD-urile, este responsabil pentru păstrarea informațiilor pe termen lung sau scurt.\n\n- **Funcția de prelucrare a informației (C):** Aceasta se referă la capacitatea sistemului de a procesa datele introduse, transformându-le în informații utile. Unitatea centrală de procesare (CPU) este componenta principală responsabilă pentru această funcție."
        },
        {
          "id": 5,
          "text": "Subunitatile de intrerupere sunt:",
          "options": {
            "A": "un mijloc de intrerupere al sistemului calculator",
            "B": "un mecanism de transmitere a informatillor intre dispozitivele de intrare-iesire",
            "C": "un mijloc de terminare a unei operatii de intrare-iesire",
            "D": "un mijloc de comunicatie  intre sistemul calculator hardware si sistemul de operare"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "de a gestiona eficient interacțiunile dintre hardware și software, permițând sistemului să prioritizeze și să aloce resursele în mod optim. Acest lucru este crucial pentru performanța și stabilitatea generală a sistemului de calcul."
        },
        {
          "id": 6,
          "text": "La declansarea unei intreruperi prima actiune desfasurata in sistemul calculator este:",
          "options": {
            "A": "salvarea registrelor procesului intrerupt in tabela de procese",
            "B": " incarcarcarea registrului program counter cu continutul vectorului de intrerupere",
            "C": "salvarea starii programului intrerupt in stiva",
            "D": "modificarea starii procesului intrerupt"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Când apare o întrerupere într-un sistem de calcul, prioritatea imediată este de a păstra starea programului care rulează în acel moment, astfel încât acesta să poată fi reluat corect după ce întreruperea a fost gestionată. Acest lucru implică salvarea stării curente, care include conținutul registrelor procesorului, pe stivă. Procedând astfel, sistemul se asigură că nu se pierde nicio dată și că programul întrerupt poate continua de unde a rămas. Opțiunea C, \"salvarea stării programului întrerupt în stivă\", descrie cu acuratețe acest pas inițial în gestionarea unei întreruperi, făcând-o alegerea corectă."
        },
        {
          "id": 7,
          "text": "Mecanismul de adresare al memoriei este:",
          "options": {
            "A": "mecanismul prin care se incarca programele in memorie",
            "B": "mecanismul prin care se traduce memoria virtuala in memorie reala",
            "C": "mecanismul prin care se construiesc adresele de memorie",
            "D": "mecanismul prin care se depun datele in memoria operativa"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Răspunsul corect este B deoarece mecanismul de adresare a memoriei implică traducerea adreselor de memorie virtuală în adrese de memorie reale (fizice). Acest proces este crucial în calculatoarele moderne, deoarece permite programelor să utilizeze un spațiu de adrese mare și flexibil, care poate depăși memoria fizică disponibilă. Sistemul de operare, împreună cu unitatea de gestionare a memoriei (MMU), se ocupă de această traducere pentru a asigura că adresele virtuale utilizate de aplicații sunt corect mapate la locațiile fizice din RAM, permițând utilizarea eficientă a resurselor de memorie."
        },
        {
          "id": 8,
          "text": "Apelurile sistem DOWN si UP actioneaza asupra unei variabile de tip:",
          "options": {
            "A": "contor",
            "B": "semafor",
            "C": "contor de evenimente",
            "D": "conditie"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În informatică, termenii \"DOWN\" și \"UP\" sunt adesea asociați cu operațiunile asupra semaforului. Un semafor este un mecanism de sincronizare utilizat pentru a controla accesul la o resursă comună în programarea concurentă. Operațiunea \"DOWN\", cunoscută și sub numele de \"P\" (proberen, în olandeză înseamnă \"a testa\"), scade valoarea semaforului și poate bloca dacă valoarea nu este pozitivă, indicând că resursa nu este disponibilă. În schimb, operațiunea \"UP\", sau \"V\" (verhogen, în olandeză înseamnă \"a crește\"), mărește valoarea semaforului, semnalând că resursa a devenit disponibilă. Astfel, răspunsul corect este B, deoarece aceste operațiuni se referă în mod specific la semafoare."
        },
        {
          "id": 9,
          "text": "Un proces este:",
          "options": {
            "A": "activitatea unitatii de prelucrare",
            "B": "un program compilat",
            "C": "un program in executie",
            "D": "un program link-editat"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Un proces este cel mai bine descris ca „un program în execuție”, motiv pentru care răspunsul corect este C. Când un program este încărcat în memorie și începe execuția, devine un proces. Acesta include codul programului și activitatea sa curentă, reprezentată de contorul de program, registre și variabile. Spre deosebire de celelalte opțiuni, un proces nu este pur și simplu un program compilat sau legat (opțiunile B și D), și nici doar activitatea unei unități de procesare (opțiunea A). În schimb, este contextul de execuție dinamic al unui program, utilizând activ resursele sistemului pentru a îndeplini sarcini."
        },
        {
          "id": 10,
          "text": "Registrul “contor program” contine:",
          "options": {
            "A": "adresele opereanzilor operatiei ce trebuie executata",
            "B": "adresa urmatoarei instructiuni ce trebuie executata",
            "C": "chiar operanzii operatiei ce trebuie executata",
            "D": "numarul instructiunii ce trebuie executata"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "„Contorul de program” sau program counter este un registru în unitatea centrală de procesare (CPU) a unui computer care deține adresa următoarei instrucțiuni ce urmează să fie executată într-o secvență de program. Acest lucru permite CPU-ului să urmărească unde se află în program și să știe ce instrucțiune să preia și să execute în continuare. Prin urmare, răspunsul corect este B: conține adresa următoarei instrucțiuni ce urmează să fie executată."
        },
        {
          "id": 11,
          "text": "Sectiunile critice sunt:",
          "options": {
            "A": "secvente de program care trebuie tratate cu mare atentie",
            "B": "secvente de tratare a intreruperilor importante",
            "C": "secvente din activitatea sistemului calculator cand resursele sunt insuficiente",
            "D": "secvente de program unde se acceseaza date partajate"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "O secțiune critică este un segment de cod într-un program unde resursele partajate, cum ar fi variabilele sau structurile de date, sunt accesate și potențial modificate. Răspunsul corect, D, identifică aceste secțiuni ca locuri unde datele partajate sunt accesate. Gestionarea corectă a secțiunilor critice este crucială pentru a preveni coruperea datelor și pentru a asigura sincronizarea, în special în programarea concurentă, unde mai multe fire de execuție sau procese ar putea încerca să citească sau să scrie în aceeași resursă simultan. Opțiunile A, B și C nu abordează în mod specific aspectul accesării datelor partajate, care definește o secțiune critică."
        },
        {
          "id": 12,
          "text": "Planificatorul este componenta sistemului de operare care decide:",
          "options": {
            "A": "care proces trece in starea de executie si pentru cat timp",
            "B": "care proces trebuie terminat si care proces trebuie inceput",
            "C": "care dispozitiv periferic va fi folosit de catre program",
            "D": "care dintre fisierele deschise trebuie inchis la un moment dat"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A. Planificatorul, sau scheduler-ul, este o componentă crucială a sistemului de operare responsabilă pentru gestionarea execuției proceselor. Acesta determină care proces va trece în starea de execuție și pentru cât timp va rula, gestionând eficient alocarea timpului procesorului. Acest lucru asigură utilizarea eficientă a resurselor procesorului și ajută la menținerea performanței și receptivității sistemului. Opțiunile B, C și D se referă la terminarea proceselor, gestionarea dispozitivelor și manipularea fișierelor, respectiv, care sunt gestionate de alte părți ale sistemului de operare."
        },
        {
          "id": 13,
          "text": "Criteriile generale urmarite de algoritmii de planificare sunt:",
          "options": {
            "A": "corectitudinea (echitabilitatea)",
            "B": "respectarea politicii SO",
            "C": "eficienta",
            "D": "mentenabilitatea"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "Iată traducerea textului în limba română:\n\nCriteriile generale urmate de algoritmii de planificare se concentrează pe asigurarea unei performanțe optime a sistemului și a satisfacției utilizatorului.\n\nA. Corectitudinea (echitabilitatea): Acest criteriu asigură că toate procesele sunt tratate corect și primesc timp de procesor adecvat, prevenind monopolizarea resurselor de către un singur proces, ceea ce este crucial pentru menținerea unei funcționări echilibrate a sistemului.\n\nB. Respectarea politicii SO: Algoritmii de planificare trebuie să respecte politicile și regulile sistemului de operare pentru a asigura îndeplinirea obiectivelor sistemului, cum ar fi gestionarea priorităților și alocarea resurselor.\n\nC. Eficiența: Eficiența este esențială pentru maximizarea performanței sistemului prin minimizarea timpului de execuție a proceselor, a timpului de răspuns și maximizarea utilizării procesorului, asigurând utilizarea eficientă a resurselor.\n\nD. Mentenabilitatea: Deși mentenabilitatea este importantă pentru dezvoltarea software-ului,"
        },
        {
          "id": 14,
          "text": "Un sistem de operare asigura indeplinirea urmatoarelor functii: ",
          "options": {
            "A": "cresterea performantelor unitatii de prelucrare",
            "B": "un management eficient al resurselor fizice si logice",
            "C": "asistarea utilizatorului printr-un sistem dezvoltat de comunicatie",
            "D": "protectia informatiei"
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "Un sistem de operare (OS) este responsabil pentru gestionarea resurselor hardware și software pe un computer. Acesta asigură o gestionare eficientă a resurselor (B), inclusiv a memoriei, puterii de procesare și stocării, pentru a optimiza performanța și alocarea resurselor. În plus, un OS oferă asistență utilizatorului printr-un sistem de comunicare dezvoltat (C), cum ar fi interfețele utilizatorului și instrumentele de linie de comandă, pentru a facilita interacțiunea cu computerul. De asemenea, implementează măsuri de securitate pentru a proteja informațiile (D) de accesul neautorizat și amenințări. Deși un OS poate îmbunătăți performanța indirect prin gestionarea eficientă a resurselor, funcțiile sale principale nu includ creșterea directă a performanței unității de procesare (A)."
        },
        {
          "id": 15,
          "text": "Care din urmatoarele resurse fizice este “preemptibila”:",
          "options": {
            "A": "banda magnetica",
            "B": "memoria",
            "C": "scanerul",
            "D": "imprimanta"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În contextul sistemelor de operare și al gestionării resurselor, o resursă preemptibilă este o resursă care poate fi întreruptă sau reatribuită de la un proces la altul fără a cauza probleme majore sau pierderi de date. Memoria (B) este considerată o resursă preemptibilă deoarece sistemul de operare poate gestiona dinamic alocarea și eliberarea memoriei între procese, permițându-i să fie reatribuită rapid și eficient. În schimb, resursele precum banda magnetică, scanerul și imprimanta sunt, de obicei, non-preemptibile, deoarece întreruperea utilizării lor poate duce la pierderi de date sau la necesitatea de a repeta operațiuni."
        },
        {
          "id": 16,
          "text": "Exceptiile program sunt:",
          "options": {
            "A": "evenimente care se produc la nivelul dispozitivelor fizice tratate prin intermediul unor\nsecvente de program",
            "B": "\nintreruperi ale masinii abstracte reprezentate prin programul care se executa\npe un sistem calculator real",
            "C": "mijloace de auto intrerupere a unui program pentru a solicita executarea unor \nfunctii de catre sistemul de operare",
            "D": "evenimente datorate executiei unei anume instructiuni din programul care ruleaza"
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "Excepțiile în programare se referă la evenimente care perturbă fluxul normal de execuție al unui program. Ele pot apărea din diverse motive, cum ar fi erori sau condiții specifice care necesită un tratament special.\n\n- Opțiunea B este corectă deoarece excepțiile sunt, în esență, întreruperi în mașina abstractă reprezentată de programul care rulează pe un sistem real de calcul. Ele acționează ca semnale că s-a întâmplat ceva neașteptat, necesitând ca programul să gestioneze situația.\n\n- Opțiunea C este corectă deoarece excepțiile servesc ca un mecanism de auto-întrerupere într-un program. Când apare o excepție, aceasta declanșează, de obicei, sistemul de operare sau runtime-ul să execute funcții specifice sau gestionari de excepții pentru a rezolva problema.\n\n- Opțiunea D este corectă deoarece excepțiile sunt adesea rezultatul executării unei instrucțiuni specifice în programul care rulează. De exemplu, încercarea de a"
        },
        {
          "id": 17,
          "text": "Care dintre urmatoarele operatii se pot efectua asupra variabilelor contor?",
          "options": {
            "A": "ADVANCE",
            "B": "AWAIT",
            "C": "READ",
            "D": "AWAKE"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "În contextul programării, în special atunci când se lucrează cu variabile folosite ca numărătoare, anumite operațiuni sunt de obicei permise.\n\n- **AVANSARE**: Această operațiune este adesea folosită pentru a incrementa valoarea unei numărători. Este o acțiune comună pentru a muta numărătoarea la starea sa următoare, prin urmare este validă.\n- **AȘTEPTARE**: Această operațiune implică așteptarea ca o anumită condiție să fie îndeplinită înainte de a continua. Deși nu modifică direct numărătoarea, poate fi asociată cu fluxul de control care implică numărători, astfel încât poate fi aplicată în scenarii în care aștepți ca numărătoarea să atingă o valoare specifică.\n- **CITIRE**: Aceasta este acțiunea de a accesa valoarea curentă a numărătorii fără a o modifica. Este o operațiune fundamentală care poate fi efectuată pe orice variabilă, inclusiv"
        },
        {
          "id": 18,
          "text": "Principalele functiuni ale sistemelor de operare sunt:",
          "options": {
            "A": "managementul fisierelor",
            "B": "managementul serverelor",
            "C": "managementul memoriei",
            "D": "managementul dispozitivelor periferice",
            "E": "managementul proceselor"
          },
          "correct_answer": [
            "A",
            "C",
            "D",
            "E"
          ],
          "explanation": "Sistemele de operare sunt esențiale pentru gestionarea resurselor hardware și software ale unui computer. Funcțiile principale ale acestora includ:\n\nA. **Managementul fișierelor**: Organizarea, stocarea, accesarea și protejarea datelor pe unități de stocare.\n\nC. **Managementul memoriei**: Alocarea și eliberarea memoriei RAM pentru procese, asigurând eficiența și evitarea conflictelor între aplicații.\n\nD. **Managementul dispozitivelor periferice**: Controlul și coordonarea interacțiunilor între computer și dispozitivele externe, cum ar fi imprimantele, tastaturile și mouse-urile."
        },
        {
          "id": 19,
          "text": "Prin constructia sistemului calculator fiecarui nivel de intrerupere i se asociaza:",
          "options": {
            "A": "un registru de adresare",
            "B": "o instructiune de calcul",
            "C": "o adresa de memorie specifica",
            "D": "un registru general"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "În proiectarea sistemelor de calcul, fiecare nivel de întrerupere este asociat cu o adresă specifică de memorie (opțiunea C), deoarece atunci când apare o întrerupere, sistemul trebuie să știe unde să găsească rutina de serviciu a întreruperii (ISR) corespunzătoare. Această rutină gestionează întreruperea, iar adresa sa este stocată într-o locație predefinită în memorie. Acest lucru permite procesorului să localizeze și să execute rapid ISR-ul, asigurând o gestionare eficientă a întreruperilor. Opțiunile A, B și D nu oferă mecanismul necesar pentru a lega direct o întrerupere de rutina sa de gestionare în memorie."
        },
        {
          "id": 20,
          "text": "Tranzitia unui proces din starea “ in execu?ie” in starea “blocat” are loc atunci cand:",
          "options": {
            "A": "planificatorul decide suspendarea procesului pentru a lansa un altul mai prioritar",
            "B": "planificatorul decide blocarea procesului din cauza unei erori",
            "C": "procesul asteapta aparitia unor date de care depinde continuarea executiei",
            "D": "procesul nu mai poate continua executia din cauza unei erori"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "În contextul sistemelor de operare și al gestionării proceselor, un proces trece din starea de \"executare\" în starea de \"blocare\" atunci când nu poate continua execuția deoarece așteaptă să fie îndeplinite anumite condiții sau să devină disponibile resurse specifice. Opțiunea C descrie cu exactitate acest scenariu: procesul așteaptă disponibilitatea datelor necesare pentru a-și continua execuția. Aceasta este o situație tipică în care un proces este blocat, deoarece trebuie să se oprească până când datele sau evenimentul necesar are loc, cum ar fi operațiunile de intrare/ieșire sau sincronizarea cu alte procese."
        },
        {
          "id": 21,
          "text": "Subsistemul memorie satisface urmatoarele proprietati:",
          "options": {
            "A": "permite accesul direct la fisiere",
            "B": "permite extensia modulara",
            "C": "permite alocarea dinamica",
            "D": "permite lucrul in paralel"
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "În contextul sistemelor de calcul, subsistemul de memorie este conceput pentru a gestiona și organiza resursele de memorie în mod eficient. De obicei, acesta satisface următoarele proprietăți:\n\nB. Permite extensia modulară: Subsistemul de memorie poate fi extins sau modificat într-un mod modular, permițând actualizări sau modificări ușoare ale capacității de memorie fără a afecta întregul sistem.\n\nC. Permite alocarea dinamică: Alocarea dinamică este o caracteristică cheie a gestionării memoriei, permițând sistemului să aloce și să dezaloce memorie după cum este necesar, optimizând utilizarea resurselor disponibile.\n\nD. Permite lucrul în paralel: Subsistemele de memorie moderne suportă procesarea în paralel, permițând accesul simultan al mai multor procese sau fire de execuție la memorie, ceea ce îmbunătățește performanța și eficiența.\n\nOpțiunea A, care se referă la accesul direct la fișiere, este"
        },
        {
          "id": 22,
          "text": "Planificarea pe doua nivele se utilizeaza atunci cand:",
          "options": {
            "A": "procesele din sistemul calculator nu ocupa intreaga memorie operativa existenta",
            "B": " in memoria operativa nu se poate pastra la un moment dat decat un singur proces",
            "C": "procesele active la un moment dat au prioritati diferite",
            "D": "memoria necesara proceselor active la un moment dat depaseste dimensiunea memoriei existente"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Planificarea pe două niveluri este utilizată atunci când memoria necesară de procesele active la un moment dat depășește dimensiunea memoriei disponibile. Această abordare ajută la gestionarea resurselor limitate prin schimbarea proceselor în și din memoria principală, permițând sistemului să gestioneze mai multe procese decât ar putea încăpea simultan în memorie. Acest lucru asigură o utilizare eficientă a resurselor de memorie și CPU, chiar și atunci când cererea depășește capacitatea imediată a sistemului."
        },
        {
          "id": 23,
          "text": "In sistemele de operare de tip client-server nucleul acestuia realizeaza:",
          "options": {
            "A": "servirea proceselor server",
            "B": "servirea proceselor client",
            "C": "transportul mesajelor de la procesele client catre procesele server",
            "D": "accesul la resursele proceselor client si ale proceselor server"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Într-un sistem de operare client-server, nucleul este responsabil pentru gestionarea comunicării între clienți și servere. Răspunsul corect este C: \"transportul mesajelor de la procesele client către procesele server\". Acest lucru se datorează faptului că nucleul facilitează schimbul de informații asigurându-se că mesajele sunt direcționate și livrate corect între procesele client și server, permițându-le să comunice și să funcționeze eficient. Celelalte opțiuni (deservirea proceselor client sau server, sau accesarea resurselor) nu descriu cu acuratețe rolul principal al nucleului în acest context."
        },
        {
          "id": 24,
          "text": "Fiecare nivel al ierarhiei sistemului de calcul este un sistem calculator caracterizat de:",
          "options": {
            "A": "structuri de informatie",
            "B": "relatia intre nivele",
            "C": "tipuri de date",
            "D": "operatii primitive"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "În contextul sistemelor de calcul, fiecare nivel al ierarhiei este caracterizat de aspecte specifice care îi definesc funcționalitatea și scopul.\n\n- **Structuri de informație (A)**: Acest termen se referă la structurile de date utilizate la fiecare nivel, care definesc modul în care informația este organizată și manipulată în cadrul acelui nivel.\n\n- **Tipuri de date (C)**: Fiecare nivel se ocupă de anumite tipuri de date care sunt adecvate pentru operațiunile sale, reflectând abstractizarea și funcționalitatea acelui nivel.\n\n- **Operații primitive (D)**: Acestea sunt operațiile de bază care pot fi efectuate la un anumit nivel, formând acțiunile fundamentale pe care se construiesc procese mai complexe.\n\nOpțiunea incorectă:\n\n- **Relația între nivele (B)**: Deși relațiile între niveluri sunt importante pentru înțelegerea..."
        },
        {
          "id": 25,
          "text": "Un vector de intrerupere reprezinta:",
          "options": {
            "A": "adresele punctelor de intrerupere a activitatii sistemului calculator",
            "B": "punctul de intrare in sistemul de operare relativ la evenimentul care a deter- minat aparitia intreruperii",
            "C": "directia catre care se indreapta sistemul de operare",
            "D": "o colectie de registre la care au acces toate subunitatile care pot fi intrerupte de unitatea centrala"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "cu adresa rutinei corespunzătoare de tratare a întreruperii. Fiecare intrare din tabelul vectorului de întrerupere corespunde unui tip specific de întrerupere și conține adresa de memorie a codului care trebuie executat pentru a gestiona acea întrerupere. Acest mecanism permite sistemului de operare să răspundă rapid și eficient la evenimentele care necesită atenție imediată, asigurând astfel o funcționare corectă și continuă a sistemului."
        },
        {
          "id": 26,
          "text": "Fie un sistem cu 5 procese, notate A,B,C,D,E si 4 resurse R,S,T,U pentru care cunoastem ca: \n- procesul A este blocat pe resursa T si detine U \n- procesul B solicita pe U si detine S \n- procesul C detine R \n- procesul D este blocat pe S si R si detine T \n- procesul E este blocat pe R \nProcesele si resursele implicate in interblocare sunt:",
          "options": {
            "A": "nu exista interblocare",
            "B": "A-S-D-U-C-T-B",
            "C": "A-U-B-S-D-R",
            "D": "B-U-A-T-D-R",
            "E": "D-S-B-U-A-T"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Pentru a determina care procese și resurse sunt implicate într-un blocaj, trebuie să identificăm un ciclu în graful de alocare a resurselor. Un blocaj apare atunci când un set de procese sunt blocate deoarece fiecare proces deține o resursă și așteaptă o altă resursă într-un lanț circular.\n\nSă examinăm relațiile date:\n\n1. Procesul A este blocat la resursa T și deține U.\n2. Procesul B solicită U și deține S.\n3. Procesul C deține R.\n4. Procesul D este blocat la S și R și deține T.\n5. Procesul E este blocat la R.\n\nAcum să analizăm opțiunile pentru a găsi ciclul corect:\n\n- **E. D-S-B-U-A-T**: Această opțiune sugerează un ciclu:\n  - D așteaptă S,"
        },
        {
          "id": 27,
          "text": "Evacuarea-re incarcarea proceselor (swapping) este procesul de:",
          "options": {
            "A": "terminare, respectiv incepe a proceselor",
            "B": "transfer al datelor in fisiere pe disc",
            "C": "lansare in executie a programelor",
            "D": "transfer al proceselor intre memorie si disc"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Swap-ul este o tehnică de gestionare a memoriei utilizată în sistemele de operare, unde procesele sunt transferate între memoria principală și stocarea pe disc. Acest proces ajută la gestionarea memoriei fizice limitate prin mutarea temporară a proceselor inactive pe disc, eliberând astfel memorie pentru procesele active. Răspunsul corect este D, deoarece swap-ul implică în mod specific transferul proceselor între memorie (RAM) și stocarea pe disc, permițând sistemului să gestioneze mai multe procese decât poate acomoda simultan memoria fizică disponibilă."
        },
        {
          "id": 28,
          "text": "Functia unui operator al unitatii de prelucrare reprezinta:",
          "options": {
            "A": "multimea operatiilor de verificare a operanzilor operatorului respectiv",
            "B": "multimea operatiilor primitive diferite care pot fi executate de operatorul respectiv",
            "C": "multimea operatiilor binare ale sistemului calculator",
            "D": "multimea subprogramelor pe care le poate executa un operator"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Răspunsul corect este B. Funcția unui operator al unității de procesare se referă la setul de operațiuni primitive diferite pe care operatorul le poate executa. Aceasta înseamnă că include toate sarcinile de bază sau instrucțiunile pe care operatorul este capabil să le îndeplinească. Spre deosebire de opțiunile A, C și D, care se concentrează pe verificarea operanzilor, operațiuni binare și execuția subprogramelor, opțiunea B surprinde cu acuratețe esența capacităților operatorului în ceea ce privește operațiunile fundamentale."
        },
        {
          "id": 29,
          "text": "Un subsistem functional al sistemului calculator este compus din:",
          "options": {
            "A": "unitate functionala propriu-zisa",
            "B": "unitate de control",
            "C": "unitate de legatura",
            "D": "unitate de comanda"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "În contextul arhitecturii calculatoarelor, un subsistem funcțional al unui sistem de calcul este compus din mai multe componente care îndeplinesc funcții specifice. Opțiunile corecte sunt:\n\nA. Unitate funcțională propriu-zisă - aceasta se referă la componentele hardware sau software care realizează efectiv sarcini specifice, cum ar fi procesarea datelor.\n\nB. Unitate de control - aceasta coordonează funcționarea diferitelor componente ale sistemului, asigurându-se că toate părțile funcționează în armonie pentru a îndeplini sarcinile cerute.\n\nCelelalte opțiuni, C"
        },
        {
          "id": 30,
          "text": "Operatorii unitatii de prelucrare sunt:",
          "options": {
            "A": "operatorul binar",
            "B": "operatorul virgula fixa",
            "C": "operatorul virgula mobila",
            "D": "operatorul zecimal"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "Întrebarea se referă la tipurile de operatori utilizați într-o unitate de procesare. Iată o explicație succintă pentru fiecare opțiune:\n\nA. **Operatorul binar** - Acesta este un tip fundamental de operator în informatică care lucrează cu date binare, efectuând operații precum adunarea, scăderea și operațiile logice pe numere binare.\n\nB. **Operatorul cu virgulă fixă** - Acesta este utilizat de obicei în aplicații specifice unde este necesară aritmetica cu virgulă fixă, dar nu este un operator standard în unitățile de procesare cu scop general.\n\nC. **Operatorul cu virgulă mobilă** - Acești operatori se ocupă de aritmetica cu virgulă mobilă, care este esențială pentru o gamă largă de sarcini de calcul, în special cele care necesită precizie cu numere reale.\n\nD. **Operatorul**"
        },
        {
          "id": 31,
          "text": "Tranzitia unui proces din starea “ in executie” in starea “gata” are loc atunci cand:",
          "options": {
            "A": "planificatorul decide suspendarea procesului pentru ca i-a expirat cuanta de timp alocata",
            "B": "planificatorul, in urma analizei proceselor active stabileste ca un proces nu poate continua executia",
            "C": "procesul nu mai are date de prelucrat si trebuie sa-si termine executia",
            "D": "procesul nu mai are date de transferat si poate sa-si continue executia"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În contextul sistemelor de operare și al managementului proceselor, un proces trece din starea de \"execuție\" în starea de \"pregătit\" în principal atunci când planificatorul intervine pentru a gestiona alocarea timpului de CPU între procese. Opțiunea A descrie corect acest scenariu: planificatorul suspendă execuția unui proces deoarece timpul său alocat (sau cuanta) a expirat. Acesta este un comportament tipic în sistemele de multitasking preemptiv, unde CPU-ul este împărțit între procese pentru a asigura o execuție receptivă și echitabilă. Procesul trece în starea de \"pregătit\", așteptându-și următoarea rundă de execuție. Opțiunile B, C și D descriu scenarii care nu se aliniază cu tranzițiile standard ale stării proceselor bazate pe expirarea cuantei de timp."
        },
        {
          "id": 32,
          "text": "Intr-un sistem de operare de tip client-server procesele server lucreaza in modul de lucru:",
          "options": {
            "A": "supervizor",
            "B": "kernel",
            "C": "utilizator",
            "D": "privilegiat"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Într-un sistem de operare client-server, procesele serverului operează de obicei în modul utilizator, care este distinct de modul kernel. Acest lucru se întâmplă deoarece modul utilizator restricționează accesul la resursele critice ale sistemului și la funcțiile kernel, asigurând astfel că, chiar dacă un proces server întâmpină o eroare sau este compromis, nu poate afecta direct operațiunile de bază ale sistemului de operare. Operarea în modul utilizator oferă un strat suplimentar de securitate și stabilitate prin prevenirea executării de către procesele server a unor operațiuni potențial dăunătoare care ar putea perturba întregul sistem. Acesta este motivul pentru care răspunsul corect este C. utilizator."
        },
        {
          "id": 33,
          "text": "Cuvantul de stare al programului (PSW):",
          "options": {
            "A": "asigura interfata intre sistemul calculator si program",
            "B": "asigura interfata intre sistemul de operare si program",
            "C": "asigura interfata intre unitatea de prelucrare si program",
            "D": "asigura interfata intre sistemul calculator si sistemul de operare"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Cuvântul de stare al programului (PSW) este o componentă cheie în arhitectura calculatoarelor, care conține informații de stare despre programul aflat în execuție. Este folosit de sistemul de operare pentru a gestiona și controla execuția programelor. PSW include informații precum adresa instrucțiunii, coduri de condiție și biți de control care afectează execuția instrucțiunilor. Prin urmare, răspunsul corect este B, deoarece PSW oferă o interfață între sistemul de operare și program, permițând sistemului să gestioneze eficient execuția programelor și să se ocupe de sarcini precum întreruperile și comutarea contextului."
        },
        {
          "id": 34,
          "text": "Pentru a se evita “conditiile de competitie” este nevoie sa utilizam:",
          "options": {
            "A": "variabile partajate",
            "B": "fisiere partajate",
            "C": "excludere mutuala",
            "D": "sectiuni critice"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Textul este deja în limba română. Dacă ai nevoie de ajutor suplimentar sau de o traducere în altă limbă, te rog să îmi spui."
        },
        {
          "id": 35,
          "text": "Planificarea cu cozi multiple se aplica la:",
          "options": {
            "A": "sistemele calculator la care comutarea intre procese este foarte rapida",
            "B": "sistemele calculator la care comutarea intre procese este foarte lenta",
            "C": "sistemele calculator cu doua procesoare",
            "D": "sistemele calculator pentru conducerea proceselor industriale"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "resurselor disponibile. În acest fel, procesele sunt clasificate și gestionate în funcție de necesitățile lor specifice, ceea ce permite alocarea mai eficientă a resurselor și îmbunătățirea performanței generale a sistemului. Fiecare coadă poate avea propriile reguli de planificare, adaptate la tipul de procese pe care le gestionează, asigurând astfel o mai bună adaptare la cerințele specifice ale fiecărui proces."
        }
      ]
    },
    {
      "name": "Retele de calculatoare",
      "questions": [
        {
          "id": 1,
          "text": "O retea de calculatoare reprezinta:",
          "options": {
            "A": "o colectie de calculatoare autonome interconectate prin cablu UTP",
            "B": "o colectie de calculatoare personale conectate la Internet",
            "C": "o colectie de calculatoare autonome interconectate folosind o singura tehnologie",
            "D": "o colectie de calculatoare autonome interconectate folosind o arhitectura client-server",
            "E": "o colectie de calculatoare personale interconectate folosind o tehnologie orientata pe conexiuni"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "O rețea de calculatoare este definită ca o colecție de calculatoare autonome care sunt interconectate pentru a partaja resurse și informații. Aspectul cheie al opțiunii C este utilizarea unei \"tehnologii unice\" pentru interconectare, ceea ce se aliniază cu definiția de bază a unei rețele, unde calculatoarele sunt conectate folosind o tehnologie de rețea specifică (cum ar fi Ethernet, Wi-Fi etc.) pentru a facilita comunicarea și partajarea resurselor. Acest lucru o deosebește de alte opțiuni care fie specifică tipuri particulare de conexiuni (de exemplu, cablu UTP) sau arhitecturi (de exemplu, client-server), care nu sunt condiții necesare pentru formarea unei rețele de calculatoare."
        },
        {
          "id": 2,
          "text": "O retea de calculatoare a carei raspandire este la nivelul unui campus este:",
          "options": {
            "A": "o retea locala",
            "B": "o retea metropolitana",
            "C": "o retea de tip stea",
            "D": "o retea cu difuzare",
            "E": "o retea larg raspandita geografic"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "O rețea de calculatoare a cărei răspândire este la nivelul unui campus este clasificată drept \"o rețea locală\" (LAN - Local Area Network). Aceasta acoperă o suprafață geografică limitată, cum ar fi un campus universitar, o clădire de birouri sau un grup de clădiri apropiate. Rețelele locale sunt utilizate pentru a conecta computerele și alte dispozitive într-o zonă restrânsă, permițând partajarea resurselor și facilitând comunicarea rapidă între dispozitivele conectate. Opțiunile B, D și E se referă la rețele cu o arie de acoperire mai extinsă."
        },
        {
          "id": 3,
          "text": "O retea de tip inel:",
          "options": {
            "A": "conecteaza printr-un singur cablu toate calculatoarele din retea",
            "B": "conecteaza fiecare calculator de alte doua",
            "C": "foloseste un calculator central care va fi conectat cu toate celelalte prin conexiuni directe",
            "D": "conecteaza toate calculatoarele intre ele fara ca vreunul sa aiba rol coodonator",
            "E": "are un singur canal de comunicatie care este partajat de toate masinile din retea"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "O rețea inelară este un tip de topologie de rețea în care fiecare calculator este conectat la exact alte două calculatoare, formând un traseu circular pentru date. Această configurație permite datelor să circule într-o direcție sau în ambele direcții în jurul inelului, fiecare dispozitiv având exact doi vecini pentru scopuri de comunicare. Această configurație asigură că nu este nevoie de un calculator central pentru a coordona rețeaua și diferă de alte topologii precum rețelele stea sau magistrală. Prin urmare, răspunsul corect este B, deoarece descrie cu acuratețe cum fiecare calculator dintr-o rețea inelară este conectat la alte două, creând un circuit închis."
        },
        {
          "id": 4,
          "text": "Retelele care dispun de numeroase conexiuni intre perechi de masini individuale sunt:",
          "options": {
            "A": "retele cu difuzare",
            "B": "retele de tip stea",
            "C": "retele de tip plasa",
            "D": "retele de tip punct-la-punct",
            "E": "retele de tip magistrala"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Răspunsul corect este C, nu D. Iată explicația:\n\nRețelele de tip plasă (C) se caracterizează prin faptul că au numeroase conexiuni între perechi de mașini individuale. Într-o rețea de tip plasă, fiecare dispozitiv este, de obicei, conectat la mai multe alte dispozitive, permițând existența mai multor căi prin care datele pot circula. Această configurare crește fiabilitatea și redundanța, deoarece datele pot urma rute alternative dacă o conexiune eșuează. Pe de altă parte, \"rețelele de tip punct-la-punct\" (D) se referă la o legătură directă între două dispozitive individuale, nu la numeroase conexiuni între multe dispozitive."
        },
        {
          "id": 5,
          "text": "Stiva de protocoale reprezinta:",
          "options": {
            "A": "o structura de date de tip ultimul intrat – primul servit folosita de protocoalele retelei",
            "B": "o lista de protocoale folosite de un anumit sistem cate un protocol pentru fiecare nivel",
            "C": "stiva folosita pentru transmiterea parametrilor functiilor realizate de protocoalele unei retele"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "O \"stivă de protocoale\" se referă la o colecție organizată de protocoale de rețea, unde fiecare protocol operează la un anumit nivel al modelului de referință OSI (Open Systems Interconnection) sau al modelului TCP/IP. Aceasta nu este o structură de date de tip \"ultimul intrat – primul servit\" și nici nu se referă la transmiterea parametrilor funcțiilor. În schimb, reprezintă un set de protocoale folosite de un sistem, fiecare având un rol specific la diferite niveluri de comunicație. Astfel, răspunsul corect este B, deoarece descrie corect o listă."
        },
        {
          "id": 6,
          "text": "Pentru a utiliza un serviciu orientat pe conexiuni beneficiarul trebuie sa:",
          "options": {
            "A": "stabileasca o conexiune, sa foloseasca aceasta conexiune si apoi sa o elibereze",
            "B": "se conecteze la retea folosind un nume de utilizator si o parola corespunzatoare",
            "C": "sa nu foloseasca medii de comunicatie fara fir (wireless)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În contextul serviciilor de rețea, un serviciu orientat pe conexiuni necesită stabilirea unei conexiuni dedicate între două puncte înainte de a putea începe transferul de date. Aceasta presupune trei pași principali: mai întâi, trebuie să se stabilească o conexiune între sursă și destinație; ulterior, această conexiune este utilizată pentru transmiterea datelor; și, în final, după ce transferul de date este complet, conexiunea trebuie eliberată sau închisă. Acești pași asigură un flux de comunicare controlat și securizat între părțile implicate. Variantele B și C nu sunt relevante pentru serviciu."
        },
        {
          "id": 7,
          "text": "Un serviciu este",
          "options": {
            "A": "un set de primitive (operatii) pe care un nivel le furnizeaza entitatii pereche de pe calculatorul cu care comunica",
            "B": "un set de primitive (operatii) pe care un nivel le furnizeaza nivelului de deasupra sa",
            "C": "un set de primitive (operatii) pe care un nivel le furnizeaza nivelului fizic",
            "D": "un set de primitive (operatii) pe care un nivel le pune la dispozitia utilizatorului",
            "E": "un set de primitive (operatii) pe care un nivel le furnizeaza interfetelor de retea"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În contextul arhitecturii de rețea și al modelelor pe straturi (cum ar fi modelul OSI), un \"serviciu\" se referă la funcționalitățile sau operațiunile oferite de un strat către stratul direct de deasupra sa. Acesta este un concept fundamental în arhitecturile pe straturi, unde fiecare strat servește stratul de deasupra sa prin oferirea unui set definit de operațiuni care ajută la abstractizarea detaliilor proceselor și protocoalelor care au loc la niveluri inferioare. Astfel, opțiunea B este alegerea corectă deoarece descrie cu acuratețe relația ierarhică dintre straturi, unde un strat oferă servicii stratului de deasupra sa."
        },
        {
          "id": 8,
          "text": "Un protocol este",
          "options": {
            "A": "un set de reguli folosit pentru apelul primitivelor de serviciu",
            "B": "un set de reguli care guverneaza formatul si semnificatia cadrelor, pachetelor \nsau mesajelor schimbate intre ele de entitatile pereche de pe un anumit nivel",
            "C": "un set de reguli care guverneaza formatul pachetelor transmise nivelelor superioare",
            "D": "un set de reguli care guverneaza formatul pachetelor transmise nivelului fizic"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Explicație: În rețelistică, un protocol este un set de reguli care guvernează comunicarea între entități într-o rețea. Opțiunea B este corectă deoarece descrie cu acuratețe un protocol ca fiind un set de reguli care dictează formatul și semnificația cadrelor, pachetelor sau mesajelor schimbate între entități de același nivel la un anumit strat. Aceasta cuprinde nu doar structura, ci și interpretarea datelor comunicate, asigurându-se că ambele părți înțeleg și procesează informația corect. Opțiunile A, C și D sunt incorecte deoarece fie limitează domeniul de aplicare al unui protocol la o funcție sau un context specific care nu surprinde pe deplin rolul larg al protocoalelor în comunicarea de rețea."
        },
        {
          "id": 9,
          "text": "Care dintre urmatoarele niveluri nu face parte din modelul ISO-OSI?",
          "options": {
            "A": "nivelul fizic",
            "B": "nivelul legatura de date",
            "C": "nivelul internet",
            "D": "nivelul transport",
            "E": "nivelul sesiune"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Modelul ISO-OSI (Open Systems Interconnection) este un cadru conceptual utilizat pentru a înțelege și implementa protocoale de rețea în șapte straturi distincte. Aceste straturi sunt:\n\n1. Nivelul fizic (Physical Layer)\n2. Nivelul legătura de date (Data Link Layer)\n3. Nivelul rețea (Network Layer)\n4. Nivelul transport (Transport Layer)\n5. Nivelul sesiune (Session Layer)\n6. Nivelul prezentare (Presentation Layer)\n7. Nivelul aplicație (Application Layer)\n\nRăspunsul corect este C, \"nivelul internet,\" deoarece nu corespunde niciunuia dintre cele șapte straturi din modelul ISO-OSI. În schimb, \"nivelul internet\" este mai strâns asociat cu modelul TCP/IP."
        },
        {
          "id": 10,
          "text": "Care dintre urmatoarele niveluri nu face parte din modelul TCP/IP?",
          "options": {
            "A": "nivelul internet",
            "B": "nivelul transport",
            "C": "nivelul prezentare",
            "D": "nivelul aplicatie",
            "E": "nivelul gazda-la-retea"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Explicație scurtă: Modelul TCP/IP este compus din patru niveluri principale: nivelul aplicație, nivelul transport, nivelul internet și nivelul gazdă-la-rețea. Nivelul de prezentare nu face parte din modelul TCP/IP; acesta este un nivel din modelul OSI, care include șapte niveluri. Modelul OSI are niveluri suplimentare, cum ar fi prezentare și sesiune, care nu sunt prezente în modelul TCP/IP."
        },
        {
          "id": 11,
          "text": "Care dintre urmatoarele sarcini NU apartine nivelului legatura de date?",
          "options": {
            "A": "tratarea erorilor",
            "B": "tratarea secventialitatii",
            "C": "controlul traficului",
            "D": "controlul accesului la mediu"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Nivelul legăturii de date din modelul OSI este responsabil pentru stabilirea unei conexiuni de date fără erori între două noduri adiacente. Funcțiile sale principale includ gestionarea erorilor, controlul traficului și controlul accesului la mediu. Tratarea secvențialității, însă, este o funcție asociată cu nivelul de transport, care se ocupă de asigurarea livrării corecte a pachetelor în ordinea corectă. Prin urmare, opțiunea B, tratarea secvențialității, nu aparține nivelului legăturii de date."
        },
        {
          "id": 12,
          "text": "Care dintre urmatoarele sarcini NU apartine nivelului retea?",
          "options": {
            "A": "dirijarea pachetelor",
            "B": "controlul congestiei",
            "C": "calitatea serviciilor",
            "D": "refacerea ordinii de transmisie a pachetelor",
            "E": "interconectarea retelelor eterogene"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "În cadrul modelului OSI (Open Systems Interconnection), nivelul rețea este responsabil pentru funcții precum dirijarea pachetelor (A), controlul congestiei (B), calitatea serviciilor (C) și interconectarea rețelelor eterogene (E). Aceste funcții sunt esențiale pentru asigurarea unei comunicări eficiente și fiabile între dispozitivele din rețea. Cu toate acestea, refacerea ordinii de transmisie a pachetelor (D) nu aparține nivelului rețea, ci nivelului transport. Nivelul transport, cum ar fi protocolul TCP (Transmission Control Protocol), se ocupă de asigurarea că pachetele sunt livrate în ordinea corectă și fără erori."
        },
        {
          "id": 13,
          "text": "Care dintre urmatoarele sarcini NU apartine nivelului sesiune?",
          "options": {
            "A": "difuzarea mesajelor",
            "B": "controlul dialogului",
            "C": "sincronizarea",
            "D": "gestiunea jetonului"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "La nivelul sesiunii, sarcinile principale includ controlul dialogului, sincronizarea și gestionarea jetonului, care se referă la gestionarea modului în care se desfășoară comunicarea între două puncte finale într-o rețea. Aceste sarcini asigură că comunicarea este ordonată și eficientă. Difuzarea mesajelor (opțiunea A) este o sarcină care aparține, de obicei, nivelului de rețea sau de transport, unde mesajele sunt transmise prin rețea către mai multe destinații. Astfel, difuzarea mesajelor nu este o sarcină tipică pentru nivelul sesiunii."
        },
        {
          "id": 14,
          "text": "Care dintre urmatoarele afirmatii este FALSA?",
          "options": {
            "A": "Modelul OSI suporta ambele tipuri de comunicatii – orientata pe conexiuni respectiv fara\nconexiuni – la nivelul retea",
            "B": "Modelul OSI suporta numai comunicatia orientata pe conexiuni la nivelul transport",
            "C": "Modelul TCP/IP suporta ambele tipuri de comunicatii – orientata pe conexiuni \nrespectiv fara conexiuni – la nivelul transport",
            "D": "Modelul TCP/IP suporta numai comunicatia fara conexiuni la nivelul retea",
            "E": "Modelul OSI suporta numai comunicatia fara conexiuni la nivelul transport"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Răspunsul corect este E.\n\nExplicație: În modelul OSI (Open Systems Interconnection), stratul de transport este conceput pentru a susține atât comunicarea orientată pe conexiune, cât și cea fără conexiune. Aceasta înseamnă că modelul OSI este capabil să gestioneze transmisia de date care necesită stabilirea unei conexiuni înainte de transferul de date (orientată pe conexiune) și transmisia de date care nu necesită o astfel de conexiune (fără conexiune). Prin urmare, afirmația că modelul OSI suportă doar comunicarea fără conexiune la stratul de transport este falsă.\n\nIată o scurtă prezentare a celorlalte opțiuni:\n\nA. Modelul OSI într-adevăr suportă atât comunicarea orientată pe conexiune, cât și cea fără conexiune la stratul de rețea, ceea ce face ca această afirmație să fie adevărată.\n\nB. Așa cum s-a menționat anterior, stratul de transport din modelul OSI suportă ambele tipuri de comunicare."
        },
        {
          "id": 15,
          "text": "Care dintre protocoalele urmatoare nu este de nivel aplicatie?",
          "options": {
            "A": "HTTP",
            "B": "UDP",
            "C": "FTP",
            "D": "SMTP",
            "E": "DNS"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "UDP (User Datagram Protocol) nu este un protocol de nivel aplicație; acesta operează la nivelul de transport al modelului OSI (Open Systems Interconnection). În timp ce HTTP, FTP, SMTP și DNS sunt protocoale care operează la nivelul aplicației și sunt utilizate pentru a facilita diferite tipuri de comunicare de date prin internet, UDP este responsabil pentru permiterea transmiterii de datagrame între dispozitive prin rețele, oferind o bază pentru ca protocoalele de nivel aplicație să funcționeze."
        },
        {
          "id": 16,
          "text": "Care dintre urmatoarele afirmatii este ADEVARATA?",
          "options": {
            "A": "TCP este un protocol sigur orientat pe conexiuni",
            "B": "TCP este un protocol sigur fara conexiuni",
            "C": "UDP este un protocol sigur fara conexiuni",
            "D": "UDP este un protocol nesigur orientat pe conexiuni",
            "E": "TCP este un protocol nesigur orientat pe conexiuni"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "TCP (Transmission Control Protocol) este un protocol de comunicație orientat pe conexiuni, ceea ce înseamnă că stabilește o conexiune fiabilă între două dispozitive înainte de a transfera datele. Acesta asigură livrarea corectă și în ordine a pachetelor de date, oferind mecanisme de verificare a erorilor și retransmisie a pachetelor pierdute. De aceea, TCP este considerat un protocol \"sigur\" în sensul fiabilității transferului de date, fiind orientat pe conexiuni. Celelalte opțiuni nu descriu corect caracteristicile fundamentale ale TCP sau UDP (User Datagram Protocol)."
        },
        {
          "id": 17,
          "text": "Serviciile de baza, oferite in mod curent de catre nivelul legatura de date sunt:",
          "options": {
            "A": "serviciu neconfirmat fara conexiune",
            "B": "serviciu neconfirmat orientat-conexiune",
            "C": "serviciu confirmat fara conexiune",
            "D": "serviciu confirmat orientat-conexiune"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "În contextul serviciilor stratului de legătură de date, funcțiile cheie includ asigurarea unui transfer de date fiabil peste un link fizic și gestionarea modului în care pachetele de date sunt încadrate și transmise între noduri.\n\n- **Serviciu neconfirmat fără conexiune (A)**: Acest serviciu oferă transfer de date fără necesitatea stabilirii unei conexiuni și fără confirmarea primirii, similar cu o abordare de tip \"trimite și uită\".\n\n- **Serviciu confirmat fără conexiune (C)**: Acest serviciu permite transferul de date fără o configurare prealabilă a conexiunii, dar include un mecanism pentru a confirma primirea datelor, asigurându-se că informația a ajuns la destinație.\n\n- **Serviciu confirmat orientat-conexiune (D)**: Acest serviciu implică stabilirea unei conexiuni înainte de transferul datelor."
        },
        {
          "id": 18,
          "text": "Controlul fluxului in nivelul legatura de date se face prin",
          "options": {
            "A": "controlul erorilor",
            "B": "reactie inversa",
            "C": "controlul retransmisiilor",
            "D": "detectarea coliziunilor"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În contextul nivelului legătură de date al modelului OSI, controlul fluxului se referă la gestionarea ratei de transmitere a datelor între două dispozitive, astfel încât să se evite supraîncărcarea receptorului. Opțiunea corectă, \"B. reacție inversă\", se referă la mecanismul prin care receptorul trimite feedback către expeditor pentru a ajusta viteza de transmitere a datelor. Această reacție inversă asigură că expeditorul nu trimite mai multe date decât poate receptorul să proceseze în mod eficient, prevenind astfel pierderea de date și asigurând o comunicare eficientă."
        },
        {
          "id": 19,
          "text": "Protocoalele folosite pentru a determina cine urmeaza sa transmita intr-un canal multiacces apartin",
          "options": {
            "A": "subnivelul MAC",
            "B": "subnivelului LLC",
            "C": "nivelului fizic",
            "D": "nivelului legatura de date"
          },
          "correct_answer": [
            "A",
            "D"
          ],
          "explanation": "În rețelele de calculatoare, comunicarea într-un mediu de acces multiplu necesită un mecanism de control pentru a decide ce dispozitiv poate transmite date la un moment dat, pentru a preveni coliziunile. Aceste mecanisme sunt gestionate de protocoalele de control al accesului la mediu (MAC), care fac parte din subnivelul MAC al nivelului de legătură de date. Subnivelul MAC se ocupă de aspectele legate de accesul la canal și de controlul accesului la mediu. În cadrul modelului OSI, nivelul de legătură de date (nivelul 2) este responsabil pentru transferul de date între nodurile conectate."
        },
        {
          "id": 20,
          "text": "Care dintre campurile de mai jos apartin unui cadru (frame) Ethernet?",
          "options": {
            "A": "adresa destinatie",
            "B": "date",
            "C": "suma de control",
            "D": "port sursa"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "Un cadru Ethernet este format din mai multe componente esențiale care asigură transmiterea corectă a datelor între dispozitivele dintr-o rețea. Răspunsurile corecte includ:\n\nA. **Adresa destinație** - Aceasta face parte din antetul unui cadru Ethernet și indică adresa hardware (MAC) a dispozitivului destinatar pentru a asigura livrarea corectă a datelor.\n\nB. **Date** - Acesta este câmpul care conține efectiv informațiile transmise, fiind partea centrală a cadrului Ethernet.\n\nC. **Suma de control** - Cunoscută și sub numele de FCS (Frame Check Sequence), aceasta este utilizată pentru a verifica integritatea datelor transmise și pentru a detecta eventualele erori care pot apărea în timpul transmisiei."
        },
        {
          "id": 21,
          "text": "Adresele subnivelului MAC Ethernet se reprezinta pe",
          "options": {
            "A": "4 octeti",
            "B": "5 octeti",
            "C": "6 octeti",
            "D": "8 octeti"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Răspunsul corect este C: 6 octeți. O adresă MAC (Media Access Control) Ethernet este un identificator unic atribuit interfețelor de rețea pentru comunicațiile la nivelul legăturii de date al unui segment de rețea. Aceasta este de obicei reprezentată ca un număr pe 48 de biți, ceea ce este echivalent cu 6 octeți sau bytes. Fiecare octet este format din 8 biți, ceea ce face un total de 48 de biți pentru întreaga adresă MAC. Acest format este standardizat și utilizat în diverse tehnologii de rețea, inclusiv Ethernet."
        },
        {
          "id": 22,
          "text": "Lungimea minima a unui cadru Ethernet valid este de:",
          "options": {
            "A": "40 octeti",
            "B": "80 octeti",
            "C": "64 octeti",
            "D": "128 octeti"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Lungimea minimă a unui cadru Ethernet valid este determinată de necesitatea de a asigura detectarea corectă a coliziunilor într-o rețea CSMA/CD. Cadrele Ethernet trebuie să aibă cel puțin 64 de octeți, incluzând atât antetul, cât și încărcătura utilă. Această dimensiune minimă permite ca cadrul să fie transmis suficient de mult timp pentru ca stația de emisie să detecteze orice coliziuni potențiale pe rețea. Dacă cadrul ar fi mai scurt, mecanismul de detectare a coliziunilor nu ar funcționa corect, ceea ce ar putea duce la probleme de comunicare în rețea. Prin urmare, răspunsul corect este C, 64 de octeți."
        },
        {
          "id": 23,
          "text": "Care dintr eregulile urmatoare sunt utilizate pentru dirijarea traficului in cadrul puntilor \ntransparente (transparent bridges)?",
          "options": {
            "A": "Daca LAN-ul sursa este acela si cu LAN-ul destinatie, atunci abandoneaza cadrul",
            "B": "Daca LAN-ul sursa si cel destinatie sunt diferite, atunci transmite cadrul",
            "C": "Daca LAN-ul destinatie nu este cunoscut, atunci foloseste inundarea",
            "D": "Daca LAN-ul destinatie nu este cunoscut, atunci abandoneaza cadrul"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "Iată traducerea textului în limba română:\n\nPodurile transparente sunt dispozitive de rețea utilizate pentru a filtra și a redirecționa traficul între diferite segmente ale unei rețele locale (LAN). Ele funcționează prin menținerea unei tabele de redirecționare pentru a lua decizii inteligente despre unde să trimită traficul, pe baza sursei și destinației cadrelor de date. Să analizăm opțiunile corecte:\n\nA. \"Dacă LAN-ul sursă este același cu LAN-ul destinație, atunci abandonează cadrul\": Această regulă este folosită deoarece, dacă sursa și destinația sunt pe același LAN, nu este nevoie să se redirecționeze cadrul prin pod, deoarece ar crea trafic inutil.\n\nB. \"Dacă LAN-ul sursă și cel destinație sunt diferite,"
        },
        {
          "id": 24,
          "text": "Serviciile nivelului retea au fost proiectate avand in vedere urmatoarele scopuri:",
          "options": {
            "A": "serviciile trebuie sa fie independente de tehnologia ruterului",
            "B": "nivelul transport trebuie sa fie independent de numarul, tipul si topologia \nruterelor existente",
            "C": "adresele de retea disponibile la nivelul transport trebuie sa foloseasca o schema \nde numerotare uniforma, chiar in cadrul retelelor LAN si WAN",
            "D": "serviciile trebuie sa asigure evitarea coliziunilor"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "Întrebarea se referă la obiectivele de proiectare ale serviciilor de la nivelul de rețea, care sunt esențiale pentru asigurarea unei comunicări eficiente și eficace a datelor prin rețele diverse.\n\nA. \"Serviciile trebuie să fie independente de tehnologia ruterului\" este corect, deoarece serviciile de la nivelul de rețea trebuie să funcționeze indiferent de hardware-ul sau tehnologia rutelor subiacente, pentru a asigura interoperabilitatea și flexibilitatea între diferite sisteme.\n\nB. \"Nivelul transport trebuie să fie independent de numărul, tipul și topologia rutelor existente\" este corect, deoarece nivelul de transport ar trebui să poată livra date fără a fi necesar să cunoască detaliile infrastructurii de rețea, permițând o comunicare fără întreruperi."
        },
        {
          "id": 25,
          "text": "Care dintre urmatoarele campuri fac parte din datagrama IP?",
          "options": {
            "A": "versiunea",
            "B": "tip serviciu",
            "C": "port destinatie",
            "D": "timp de viata"
          },
          "correct_answer": [
            "A",
            "B",
            "D"
          ],
          "explanation": "O datagramă IP este un pachet de date utilizat în rețelele de calculatoare care folosesc Protocolul Internet (IP) pentru transmiterea informațiilor. Structura datagramei IP include mai multe câmpuri esențiale pentru a asigura corectitudinea și eficiența transmiterii datelor. Câmpurile \"versiunea\" și \"tip serviciu\" fac parte din antetul IP, având rolul de a specifica versiunea protocolului și calitatea serviciului dorit. \"Timp de viață\" este un alt câmp important care previne ciclarea infinită a pachetelor în rețea prin limitarea duratei de viață a acestora."
        },
        {
          "id": 26,
          "text": "Multimea adreselor IP de clasa A se regaseste in intervalul de adrese:",
          "options": {
            "A": "10.0.0.0 – 127.255.255.255",
            "B": "128.0.0.0 – 191.255.255.255",
            "C": "1.0.0.0 - 127.255.255.255",
            "D": "1.0.0.0 – 127.0.0.1"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Răspunsul corect este C: 1.0.0.0 - 127.255.255.255.\n\nExplicație: În sistemul original de adresare IPv4, adresele IP sunt împărțite în cinci clase (A, B, C, D și E) pe baza primilor biți. Adresele din clasa A sunt destinate rețelelor mari și pot fi identificate prin primul octet, care variază de la 1 la 127. Prin urmare, intervalul adreselor IP din clasa A începe de la 1.0.0.0 și ajunge până la 127.255.255.255. Adresele de la 127.0.0.0 la 127.255.255.255 sunt rezervate pentru funcțiile de loopback și nu sunt utilizate pentru adrese de rețea."
        },
        {
          "id": 27,
          "text": "Multimea adreselor IP de clasa B se regaseste in intervalul de adrese:",
          "options": {
            "A": " 128.0.0.0 – 192.0.0.0",
            "B": "128.0.0.0 - 191.255.255.255",
            "C": "127.255.255.255 – 191.255.255.255",
            "D": "127.0.0.1 – 192.0.0.0"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Adresele IP sunt împărțite în diferite clase, iar fiecare clasă are un interval specific. Adresele IP de Clasă B sunt utilizate pentru rețele de dimensiuni medii până la mari. Intervalul Clasei B este definit de primul octet al adresei, care începe de la 128 până la 191. Intervalul complet pentru adresele IP de Clasă B este de la 128.0.0.0 la 191.255.255.255. Acest lucru se datorează faptului că primele două biți ale unei adrese de Clasă B sunt '10', ceea ce corespunde intervalului zecimal de 128-191 în primul octet. Prin urmare, răspunsul corect este B, deoarece reprezintă cu acuratețe intervalul complet pentru adresele IP de Clasă B."
        },
        {
          "id": 28,
          "text": "Multimea adreselor IP de clasa C se regaseste in intervalul de adrese:",
          "options": {
            "A": "191.255.255.255 – 223.255.255.255",
            "B": "192.0.0.0 – 224.0.0.0",
            "C": "191.255.255.255 – 224.0.0.0",
            "D": "192.0.0.0 - 223.255.255.255"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Răspunsul corect este D: 192.0.0.0 - 223.255.255.255.\n\nExplicație: În sistemul original de clasificare a adreselor IPv4, adresele IP erau împărțite în cinci clase (A, B, C, D și E) pentru diferite tipuri de rețele. Adresele de Clasă C sunt concepute pentru rețele mici și au o gamă specifică de adrese IP.\n\nAdresele de Clasă C încep de la 192.0.0.0 și se termină la 223.255.255.255. Această gamă este definită de primii trei biți ai primului octet fiind setați la \"110\", ceea ce restricționează valorile de la 192 la 223. Prin urmare, opțiunea D descrie corect gama de adrese IP de Clasă C."
        },
        {
          "id": 29,
          "text": "Multimea adreselor IP de clasa D se regaseste in intervalul de adrese:",
          "options": {
            "A": "224.0.0.0 – 239.255.255.255",
            "B": "223.255.255.255 – 239.255.255.255",
            "C": "223.255.255.255 – 240.0.0.0",
            "D": "224.0.0.0 – 240.0.0.0"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Adresele IP de Clasa D sunt destinate multicast-ului, care este o metodă utilizată pentru a trimite date către mai multe calculatoare simultan. Intervalul pentru adresele de Clasa D este în mod specific de la 224.0.0.0 la 239.255.255.255. Acest interval este definit de primii patru biți ai adresei fiind '1110', ceea ce se traduce într-o valoare zecimală începând de la 224 până la 239. Prin urmare, intervalul corect pentru adresele IP de Clasa D este 224.0.0.0 la 239.255.255.255, făcând ca opțiunea A să fie alegerea corectă."
        },
        {
          "id": 30,
          "text": "Multimea adreselor IP de clasa E se regaseste in intervalul de adrese:",
          "options": {
            "A": "240.0.0.0 – 255.255.255.255",
            "B": "239.255.255.255 – 255.255.255.255",
            "C": "240.0.0.0 – 255.0.0.0",
            "D": "239.255.255.255 – 255.0.0.0"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Mulțimea adreselor IP de clasa E este rezervată pentru uz experimental și nu este utilizată în mod obișnuit pentru traficul public de internet. Intervalul de adrese IP de clasa E începe de la 240.0.0.0 și se extinde până la 255.255.255.255. Acest interval este destinat în principal pentru cercetare și dezvoltare și nu ar trebui să fie asignat dispozitivelor din rețelele standard. Variantele B, C și D nu acoperă corect întregul interval al clasei E sau includ adrese care nu fac parte din clasa E. Astfel, răspunsul corect este A."
        },
        {
          "id": 31,
          "text": "Bitii cei mai semnificativi ai unei adrese valide de clasa A au valorile:",
          "options": {
            "A": "0",
            "B": "1",
            "C": "01",
            "D": "10"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În contextul adresării IPv4, adresele IP sunt împărțite în clase (A, B, C, D și E) pe baza primelor biți. Pentru o adresă IP de Clasa A, cel mai semnificativ bit (primul bit) este întotdeauna setat la 0. Acest lucru permite un număr mare de rețele posibile cu un număr relativ mic de gazde per rețea. Prin urmare, răspunsul corect este A, deoarece cei mai semnificativi biți ai unei adrese valide de Clasa A sunt 0."
        },
        {
          "id": 32,
          "text": "Bitii cei mai semnificativi ai unei adrese valide de clasa B au valorile:",
          "options": {
            "A": "10",
            "B": "1",
            "C": "01",
            "D": "11"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În contextul adresării IP, în special IPv4, adresele sunt împărțite în clase. Fiecare clasă este definită de biții de început ai adresei.\n\nPentru o adresă IP de Clasa B, cei mai semnificativi biți (primii câțiva biți ai adresei) sunt întotdeauna \"10\". Aceasta diferențiază Clasa B de alte clase:\n- Adresele de Clasa A încep cu \"0\",\n- Adresele de Clasa C încep cu \"110\", și așa mai departe.\n\nPrin urmare, răspunsul corect este A, deoarece \"10\" este modelul de biți care identifică o adresă IP de Clasa B."
        },
        {
          "id": 33,
          "text": "Bitii cei mai semnificativi ai unei adrese valide de clasa C au valorile:",
          "options": {
            "A": "110",
            "B": "111",
            "C": "100",
            "D": "10"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În contextul adresării IP, adresele IP sunt împărțite în clase, iar fiecare clasă este identificată prin cei mai semnificativi biți ai adresei. Pentru o adresă IP de Clasa C, cei mai semnificativi biți sunt întotdeauna \"110\". Astfel, rețeaua este identificată ca o rețea de Clasa C. Formatul adresei de Clasa C permite un număr mare de rețele, fiecare cu un număr mai mic de gazde. Prin urmare, răspunsul corect este A, deoarece cei mai semnificativi biți pentru o adresă de Clasa C sunt \"110\"."
        },
        {
          "id": 34,
          "text": "Bitii cei mai semnificativi ai unei adrese valide de clasa D au valorile:",
          "options": {
            "A": "1110",
            "B": "110",
            "C": "01",
            "D": "10"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Adresele IP de Clasa D sunt utilizate pentru multicast, ceea ce permite livrarea unui singur pachet către multiple destinații. Caracteristica definitorie a adreselor de Clasa D în contextul IPv4 este că cei mai semnificativi biți (MSB) sunt setați la \"1110\". Acest tipar de biți diferențiază adresele de Clasa D de celelalte clase (A, B, C) și stabilește intervalul pentru adresele multicast de la 224.0.0.0 la 239.255.255.255. Prin urmare, răspunsul corect este A."
        },
        {
          "id": 35,
          "text": "Carei clase de adrese apartine adresa IP 88.100.10.23?",
          "options": {
            "A": "A",
            "B": "B",
            "C": "C",
            "D": "D"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Întrebarea se referă la tipul de clasă al adresei IP 88.100.10.23. Adresele IP sunt împărțite în diferite clase pe baza primelor biți, care determină intervalul și scopul adresei.\n\n- Adresele de **Clasă A** variază de la 0.0.0.0 la 127.255.255.255. Ele se caracterizează prin faptul că primul bit este setat la 0, ceea ce înseamnă că primul octet variază de la 0 la 127.\n- Adresele de **Clasă B** variază de la 128.0.0.0 la 191.255.255.255, având primii doi biți setați la 10.\n- Adresele de **Clasă C** variază de la 192.0.0.0 la"
        },
        {
          "id": 36,
          "text": "Carei clase de adrese apartine adresa IP 163.21.84.12?",
          "options": {
            "A": "A",
            "B": "B",
            "C": "C",
            "D": "D"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Adresa IP dată, 163.21.84.12, aparține Clasei B. Iată cum determinăm acest lucru:\n\nAdresele IPv4 sunt împărțite în diferite clase (A, B, C, D și E) pe baza primelor biți:\n\n- Adresele **Clasa A** variază de la 0.0.0.0 la 127.255.255.255. Ele au primul octet cuprins între 0 și 127.\n- Adresele **Clasa B** variază de la 128.0.0.0 la 191.255.255.255. Ele au primul octet cuprins între 128 și 191.\n- Adresele **Clasa C** variază de la 192.0.0.0 la 223."
        },
        {
          "id": 37,
          "text": "Carei clase de adrese apartine adresa IP 231.2.4.1?",
          "options": {
            "A": "A",
            "B": "B",
            "C": "C",
            "D": "D"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "The IP addresses are divided into several classes (A, B, C, D, and E) based on the first octet of the address. Each class has a specific range of addresses. Class D is used for multicast and includes IP addresses that have the first octet in the range 224-239. In the case of the IP address 231.2.4.1, the first octet is 231, which means that it belongs to class D, which is intended for multicast transmissions."
        },
        {
          "id": 38,
          "text": "Protocolul ARP se utilizeaza pentru a afla,",
          "options": {
            "A": "adresa Ethernet pe baza adresei IP",
            "B": "adresa IP pe baza adresei Ethernet",
            "C": "adresa IP pe baza claselor de adrese",
            "D": "adresa IP destinatie pe baza algoritmilor de dirijare"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Protocolul de Rezoluție a Adreselor (ARP) este utilizat în rețelele de calculatoare pentru a mapa o adresă IP la o adresă fizică a unei mașini, cunoscută și sub numele de adresă MAC (Media Access Control) sau adresă Ethernet. Când un dispozitiv dorește să comunice cu alt dispozitiv în aceeași rețea locală, trebuie să cunoască adresa MAC asociată cu adresa IP a dispozitivului de destinație. ARP facilitează acest lucru prin trimiterea unei cereri în rețea, solicitând adresa MAC corespunzătoare unei adrese IP specifice. Prin urmare, răspunsul corect este A: este utilizat pentru a găsi adresa Ethernet pe baza adresei IP."
        },
        {
          "id": 39,
          "text": "Care dintre obiectivele de mai jos sunt vizate de protocolul IPv6?",
          "options": {
            "A": "reducerea dimensiunii tabelelor de dirijare",
            "B": "extinderea adreselor Ethernet la 128 de biti",
            "C": "posibilitatea ca un calculator gazda sa migreze fara a-si schimba adresa IP",
            "D": "asigurarea unei securitati sporite prin mecanisme de autentificare si confidentialitate"
          },
          "correct_answer": [
            "A",
            "C",
            "D"
          ],
          "explanation": "IPv6 a fost creat pentru a aborda limitările IPv4 și a aduce îmbunătățiri semnificative.\n\nA. Reducerea dimensiunii tabelelor de rutare: IPv6 utilizează o structură mai eficientă de adresare și agregare, ceea ce permite o reducere a complexității și dimensiunii tabelelor de rutare.\n\nC. Posibilitatea ca un calculator gazdă să migreze fără a-și schimba adresa IP: IPv6 suportă mobilitatea IP, permițând dispozitivelor să-și păstreze adresa IP în timp ce se deplasează între diferite rețele.\n\nD."
        },
        {
          "id": 40,
          "text": "Care dintre campurile urmatoare fac parte din antetul obligatoriu IPv6?",
          "options": {
            "A": "urmatorull antent",
            "B": "eticheta fluxului",
            "C": "limita de salturi",
            "D": "tipul nodului: client sau server"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "În IPv6, câmpurile de antet obligatorii includ \"Next Header\" (următorul antet), \"Flow Label\" (eticheta fluxului) și \"Hop Limit\" (limita de salturi). Aceste câmpuri sunt esențiale pentru funcționalitatea de bază a protocolului IPv6. Câmpul \"Next Header\" indică tipul antetului următor care urmează după antetul IPv6, \"Flow Label\" este folosit pentru identificarea și gestionarea pachetelor care aparțin aceluiași flux, iar \"Hop Limit\" specifică numărul maxim de salturi pe care un pachet le poate face înainte de a fi eliminat. Opțiunea D, \"Tipul nodului: client sau server,\" nu este un câmp în antetul IPv6."
        }
      ]
    },
    {
      "name": "Securitatea retelelor de calculatoare",
      "questions": [
        {
          "id": 1,
          "text": "Un sistem criptografic este",
          "options": {
            "A": "Un tuplu format dintr-o functie de criptare, una de decriptare, domeniile de \ndefinitie si chei",
            "B": "Un tuplu format din functie de criptare decriptare, domenii de definitie si chei",
            "C": "Un tuplu format din functie de criptare si chei",
            "D": "Un aparat special de transformare a caracterelor",
            "E": "O metoda de codificare"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Un sistem criptografic, cunoscut și sub numele de criptosistem, este definit ca o structură sau o schemă formată din mai multe componente care lucrează împreună pentru a asigura o comunicare securizată. Răspunsul corect, A, specifică faptul că un sistem criptografic este un tuplu care include o funcție de criptare, o funcție de decriptare, un set de chei posibile și domenii definite pentru aceste funcții. Această definiție cuprinzătoare evidențiază componentele cheie esențiale pentru procesele de criptare și decriptare: funcția de criptare transformă textul clar în text cifrat folosind o cheie, iar funcția de decriptare inversează acest proces, folosind o cheie pentru a transforma textul cifrat înapoi în text clar. Includerea domeniilor și a cheilor asigură că sistemul funcționează corect și în siguranță în cadrul parametrilor specificați. Această înțelegere este crucială pentru implementarea eficientă a sistemelor criptografice."
        },
        {
          "id": 2,
          "text": "Un sistem de criptare prin shift-are are o cheie compusa din",
          "options": {
            "A": "doua numere intregi",
            "B": "un numar natural",
            "C": "un numar intreg si unul real",
            "D": "un numar irational",
            "E": "doua numere"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Un cifru de substituție, cunoscut și sub numele de cifru Caesar, este un tip de tehnică de criptare în care fiecare literă din textul clar este mutată cu un anumit număr de poziții în jos sau în sus în alfabet. Cheia pentru un cifru de substituție este un singur număr care indică numărul de poziții cu care este mutată fiecare literă din textul clar. Deoarece acest număr trebuie să fie o valoare întreagă și nenegativă pentru a reprezenta eficient mutările, este caracterizat ca un număr natural. Prin urmare, răspunsul corect este B, deoarece cheia de criptare pentru un cifru de substituție este compusă dintr-un număr natural."
        },
        {
          "id": 3,
          "text": "Autentificarea unui mesaj reprezinta",
          "options": {
            "A": "verificarea integritatii mesajului primit de un destinatar",
            "B": "modul prin care expeditorul nu poate nega faptul ca a transmis mesajul",
            "C": "destinatarul unui mesaj trebuie sa dispuna de modalitati de a verifica \nidentitatea expeditorului si originea mesajului"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Autentificarea unui mesaj implică verificarea identității expeditorului și asigurarea că mesajul provine dintr-o sursă autentică. Aceasta înseamnă că destinatarul trebuie să aibă mijloace pentru a confirma cine a trimis mesajul și că acesta nu a fost modificat de la expediere. Opțiunea C descrie acest proces prin sublinierea nevoii destinatarului de a putea verifica identitatea expeditorului și originea mesajului, ceea ce este esențial pentru autentificare. Opțiunile A și B descriu alte aspecte ale securității mesajelor, cum ar fi integritatea și non-repudierea."
        },
        {
          "id": 4,
          "text": "Non-Repudierea mesajului intr-o retea reprezinta",
          "options": {
            "A": "Modul de a se accepta un mesaj",
            "B": "dupa transmiterea unui mesaj, trebuie ca expeditorul sa nu il poata nega",
            "C": "dupa transmiterea unui mesaj trebuie ca destinatarul sa nu poata sa il refuze"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Non-repudierea într-un context de rețea asigură că, odată ce un mesaj a fost trimis, expeditorul nu poate nega că l-a trimis. Acest lucru este crucial pentru responsabilitate și încredere în sistemele de comunicare. Răspunsul corect este B, deoarece surprinde esența non-repudierii: prevenirea posibilității ca expeditorul să-și nege acțiunea după ce mesajul a fost transmis. Opțiunea C se referă mai mult la acceptarea mesajului de către destinatar, ceea ce nu este focusul non-repudierii. Opțiunea A este incorectă, deoarece se referă la acceptarea unui mesaj, nu la incapacitatea de a nega că a fost trimis."
        },
        {
          "id": 5,
          "text": "Criptologia reprezinta",
          "options": {
            "A": "o metoda de codificare a mesajelor",
            "B": "o metoda de analiza a corectitudinii mesajelor criptate",
            "C": "un mod de criptare",
            "D": "un mod de decriptare",
            "E": "cumulul dintre criptare si analiza criptografica"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Criptologia este un domeniu care cuprinde atât criptografia, cât și criptoanaliza. Criptografia se ocupă de crearea și implementarea metodelor de criptare pentru a asigura confidențialitatea și securitatea mesajelor, în timp ce criptoanaliza se concentrează pe studierea și spargerea acestor metode pentru a analiza corectitudinea și securitatea mesajelor criptate. Prin urmare, criptologia reprezintă cumulul dintre criptare (criptografie) și analiza criptografică (criptoanaliză), ceea ce face ca răspunsul corect să fie E."
        },
        {
          "id": 6,
          "text": "Criptografia este",
          "options": {
            "A": "o metoda de analiza a datelor",
            "B": "un sistem de regasire a mesajelor in clar din mesaje criptate",
            "C": "stiinta matematica care asigura confidentialitatea datelor"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Criptografia este, în esență, știința matematică care asigură confidențialitatea datelor. Aceasta implică tehnici și metode de criptare a informațiilor, făcându-le accesibile doar celor care au autorizația corespunzătoare sau cheia de decriptare. Acest lucru este distinct de analiza datelor (opțiunea A) și de recuperarea textului simplu din mesaje criptate (opțiunea B), care nu sunt funcții primare ale criptografiei. În schimb, criptografia se concentrează pe securizarea datelor împotriva accesului sau modificărilor neautorizate, protejând astfel informațiile sensibile."
        },
        {
          "id": 7,
          "text": "Sistemul de criptare cu cheie simetrica foloseste",
          "options": {
            "A": "o cheie pentru criptare si una pentru decriptare, diferite",
            "B": "o cheie pentru criptare si una pentru decriptare, a doua fiind obtinuta prin transformarea primei chei",
            "C": "o cheie la criptare si una la decriptare, identice",
            "D": "o singura cheie, pentru criptare, decriptarea fiind facuta de destinatar, fara cheie"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Sistemul de criptare cu cheie simetrică utilizează aceeași cheie atât pentru criptarea, cât și pentru decriptarea datelor. Aceasta înseamnă că cheia folosită pentru a transforma mesajul clar într-un mesaj criptat este identică cu cea folosită pentru a transforma mesajul criptat înapoi în mesajul clar. Această metodă necesită ca atât expeditorul, cât și destinatarul să dețină aceeași cheie secretă, care trebuie păstrată în siguranță pentru a menține confidențialitatea informațiilor. De aceea, răspunsul corect este C: o cheie la criptare și una la decriptare."
        },
        {
          "id": 8,
          "text": "Criptarea de tip stream este o criptare",
          "options": {
            "A": "simetrica, cu doua chei diferite",
            "B": "asimetrica, cu o singura cheie",
            "C": "nu este o criptare, este o codificare",
            "D": "este inversa criptarii de tip bloc",
            "E": "simetrica"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Criptarea cu cifru de flux este un tip de criptare simetrică deoarece utilizează aceeași cheie atât pentru criptare, cât și pentru decriptare. În criptarea simetrică, atât expeditorul, cât și receptorul împărtășesc aceeași cheie secretă, care este folosită pentru a cripta și decripta datele. Cifrele de flux criptează datele câte un bit sau un byte pe rând, ceea ce le face diferite de cifrele bloc, care criptează datele în blocuri de dimensiuni fixe. Prin urmare, răspunsul corect este E."
        },
        {
          "id": 9,
          "text": "Criptarea de tip bloc, este",
          "options": {
            "A": "o criptare asimetrica, cu doua chei identice",
            "B": "o criptare asimetrica",
            "C": "o codificare a mesajului, pentru autentificare",
            "D": "un mod de semnare",
            "E": "o criptare simetrica"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Criptarea cu cifru bloc este un tip de criptare simetrică, ceea ce înseamnă că folosește aceeași cheie atât pentru criptare, cât și pentru decriptare. Această metodă procesează datele în blocuri de dimensiuni fixe, transformându-le în blocuri de text cifrat de aceeași dimensiune. Spre deosebire de criptarea asimetrică, care folosește o pereche de chei publice și private, criptarea simetrică, precum cifrurile bloc, se bazează pe o singură cheie secretă partajată pentru ambele părți implicate. Acest lucru face ca opțiunea E să fie răspunsul corect, deoarece descrie cu acuratețe criptarea cu cifru bloc."
        },
        {
          "id": 10,
          "text": "Sniffer este un termen care defineste",
          "options": {
            "A": "un sistem criptografic simetric",
            "B": "un sistem criptografic asimetric",
            "C": "un mod de analiza a puterii unui algoritm criptografic",
            "D": "un mod de analiza a datelor transferate intr-o retea de calculatoare"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Un \"sniffer\" este un instrument sau un software folosit pentru a monitoriza și analiza datele pe măsură ce sunt transmise printr-o rețea de calculatoare. Acesta capturează pachetele de rețea și decodează datele pentru analiză, permițând utilizatorilor să înțeleagă informațiile care sunt trimise și primite. Acest lucru poate fi util pentru depanarea rețelei, analiza securității și gestionarea rețelei. Spre deosebire de celelalte opțiuni, care se referă la metode criptografice, un sniffer se concentrează în mod specific pe observarea și analizarea traficului de rețea, făcând ca opțiunea D să fie răspunsul corect."
        },
        {
          "id": 11,
          "text": "SSL si TLS sunt",
          "options": {
            "A": "unul si acelasi protocol",
            "B": "doua protocoale criptografice pentru retele",
            "C": "doua modele de criptare locale, al doilea se bazeaza pe primul"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "SSL (Secure Sockets Layer) și TLS (Transport Layer Security) sunt două protocoale criptografice utilizate pentru a securiza comunicațiile în rețelele de calculatoare, cum ar fi internetul. SSL a fost inițial dezvoltat de Netscape și a evoluat în timp, iar TLS a fost introdus ca succesor al SSL pentru a oferi îmbunătățiri de securitate și performanță. Deși TLS este bazat pe SSL și îndeplinește funcții similare, ele sunt versiuni distincte, nu sunt unul și același protocol, și nu sunt modele de criptare locale. De aceea, opțiunea corectă este B, care menționează aceste diferențe."
        },
        {
          "id": 12,
          "text": "Intr-o retea de calculatoare un sniffer are acces la datele",
          "options": {
            "A": "toate datele care tranziteaza reteaua",
            "B": "datele de la computerele legate indirect la acelasi server",
            "C": "datele din computerele care sunt in aceeasi zona geografica",
            "D": "datele de la computerelec are comunica in orice fel cu un computer care ares niffer instalat",
            "E": "datele din subreteaua primului switch de deasupra sa, in ierahia retelei"
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Într-o rețea de calculatoare, un sniffer este un instrument utilizat pentru a monitoriza și captura pachete de date pe măsură ce acestea circulă prin rețea. Răspunsul la această întrebare este E, deoarece un sniffer capturează de obicei pachete în cadrul aceluiași subnet sau segment de rețea la care este conectat. În majoritatea configurațiilor de rețea, un switch este folosit pentru a conecta mai multe dispozitive într-o rețea locală (LAN). Sniffer-ul poate captura pachete de date doar de la dispozitivele conectate la același switch, cu excepția cazului în care are privilegii sau capabilități suplimentare pentru a intercepta date din alte părți ale rețelei. Prin urmare, sniffer-ul are acces la datele din subrețeaua gestionată de primul switch direct deasupra sa în ierarhia rețelei."
        },
        {
          "id": 13,
          "text": "O semnatura electronica are la baza",
          "options": {
            "A": "un algoritm simetric de criptare",
            "B": "un algoritm asimetric de criptare, in care semnatarul foloseste cheia publica",
            "C": "un algoritm asimetric de criptare, in care semnatarul foloseste cheia privata",
            "D": "o cheie pentru fiecare utilizator si fiecare mesaj"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "O semnătură digitală se bazează pe un algoritm de criptare asimetrică, unde semnatarul folosește cheia sa privată pentru a crea semnătura. Acest lucru asigură că semnătura este unică pentru semnatar și poate fi verificată de oricine are acces la cheia publică corespunzătoare. Opțiunea C este corectă deoarece descrie cu acuratețe acest proces, în care cheia privată este folosită pentru a semna mesajul, oferind autenticitate și integritate."
        },
        {
          "id": 14,
          "text": "O retea de calculatoare are ca mod de comunicare standard un modul numit placa de retea. \nAceasta comunica date",
          "options": {
            "A": "criptat, cu un algoritm simetric",
            "B": "criptat, cu un algoritm asimetric",
            "C": "semnate de destinatar",
            "D": "in clar"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Răspunsul corect este D: \"în clar.\"\n\nExplicație: Într-o rețea de calculatoare standard, plăcile de rețea (NIC-uri) sunt responsabile pentru facilitarea comunicării între calculatoare. În mod implicit, datele transmise prin rețea sunt trimise \"în clar,\" ceea ce înseamnă că nu sunt criptate. Acest lucru se întâmplă deoarece comunicarea de bază în rețea nu include în mod inerent procese de criptare. Opțiunile A și B implică metode de criptare (algoritmi simetrici și asimetrici), care nu sunt caracteristici standard ale comunicării de bază printr-o placă de rețea. Opțiunea C se referă la datele fiind semnate de către destinatar, ceea ce nu este o practică standard în comunicarea de rețea. Prin urmare, alegerea corectă este că datele sunt comunicate în forma lor clară, necriptată, cu excepția cazului în care sunt implementate în mod explicit măsuri suplimentare de securitate."
        }
      ]
    },
    {
      "name": "Baze de Date",
      "questions": [
        {
          "id": 1,
          "text": "Intre avantajele bazelor de date se numara:",
          "options": {
            "A": "nepartajarea datelor intre utilizatori",
            "B": "organizarea datelor pe doua niveluri - fizic si logic",
            "C": "gestionarea centralizata a datelor printr-un SGBD",
            "D": "integrarea in aceeasi structura a tuturor datelor pertinente ale unui sistem informatic",
            "E": "independenta datelor fata de programele de aplicatii"
          },
          "correct_answer": [
            "B",
            "C",
            "E"
          ],
          "explanation": "B. Organizarea datelor pe două niveluri - fizic și logic: Acest avantaj se referă la separarea modului în care datele sunt stocate fizic de modul în care sunt percepute logic, permițând o gestionare mai flexibilă și eficientă a datelor.\n\nC. Gestionarea centralizată a datelor printr-un SGBD: Sistemele de gestionare a bazelor de date (SGBD) permit centralizarea datelor, ceea ce facilitează administrarea, securitatea și accesul controlat la date de către utilizatori.\n\nE. Independența datelor față de programele de aplicații: Acest avantaj indică faptul că modificările în structura datelor nu afectează programele de aplicații care le utilizează, permițând astfel o adaptabilitate și o întreținere mai ușoară a sistemelor informatice."
        },
        {
          "id": 2,
          "text": "O entitate se caracterizeaza prin:",
          "options": {
            "A": "este identificata unic printr-un nume",
            "B": "cuprinde, in general, mai multe valori sau realizari",
            "C": "administreaza obiecte",
            "D": "semnifica un obiect concret sau abstract, reprezentat prin proprietatile sale",
            "E": "semnifica o caracteristica a unui obiect concret"
          },
          "correct_answer": [
            "A",
            "B",
            "D"
          ],
          "explanation": "O entitate este un concept fundamental în modelarea datelor și se referă la un obiect sau un lucru care poate fi identificat în mod unic și despre care vrem să stocăm informații.\n\nA. Este identificată unic printr-un nume - Această opțiune este corectă deoarece fiecare entitate trebuie să aibă un identificator unic, cum ar fi un nume sau un ID, care o distinge de alte entități.\n\nB. Cuprinde, în general, mai multe valori sau realizări - Această opțiune este corectă deoarece o entitate este de obicei descrisă printr-un set de atribute sau proprietăți, fiecare având valori."
        },
        {
          "id": 3,
          "text": "O entitate din modelul Entitate-Asociere are urmatoarele caracteristici:",
          "options": {
            "A": "are o existenta proprie",
            "B": "este intotdeauna concreta",
            "C": "trebuie definita fara ambiguitati",
            "D": "este intotdeauna legata de o alta entitate printr-o asociatie",
            "E": "este identificata unic prin ansamblul atributelor sale"
          },
          "correct_answer": [
            "C",
            "E"
          ],
          "explanation": "În modelul Entitate-Asociere (Entity-Relationship, ER), o \"entitate\" reprezintă un obiect distinct sau un concept din lumea reală care poate fi identificat și descris în sistemul de baze de date.\n\nC. trebuie definită fără ambiguități: Entitățile trebuie să fie clar definite pentru a evita confuziile și pentru a asigura integritatea datelor. Fiecare entitate trebuie să fie descrisă astfel încât să nu existe dubii cu privire la ceea ce reprezintă.\n\nE. este identificată unic prin ansamblul atributelor sale: Fiecare entitate trebuie să aibă unul sau mai multe atribute care să permită identificarea sa unică."
        },
        {
          "id": 4,
          "text": "Administratorul bazei de date asigura:",
          "options": {
            "A": "scrierea programelor in cod-masina",
            "B": "autorizarea accesului la date",
            "C": "realizarea obiectivelor si functiilor sistemului",
            "D": "definirea strategiei de salvare si restaurare a bazei de date",
            "E": "crearea programelor de aplicatii"
          },
          "correct_answer": [
            "B",
            "D"
          ],
          "explanation": "În contextul managementului bazelor de date, un administrator de baze de date (DBA) este responsabil pentru asigurarea securității și integrității datelor dintr-o bază de date. Opțiunea B, \"autorizarea accesului la date\", se referă la controlul asupra persoanelor care pot accesa sau modifica datele, ceea ce reprezintă o responsabilitate cheie a unui DBA pentru a menține securitatea și confidențialitatea datelor. Opțiunea D, \"definirea strategiei de salvare și restaurare a bazei de date\", implică planificarea și implementarea procedurilor de backup și restaurare a datelor în caz de pierdere a acestora, asigurând disponibilitatea și durabilitatea datelor. Aceste sarcini sunt esențiale pentru managementul și operarea corespunzătoare a unei baze de date, aliniindu-se cu atribuțiile de bază ale unui administrator de baze de date."
        },
        {
          "id": 5,
          "text": "Se da tabelul: ANGAJATI (CodAngaj, Nume, DataAngajare, Compartiment, Profesia, Salariu) Care dintre urmatoarele instructiuni SQL permite afisarea numarului de salariati pe fiecare com- partiment care incepe cu litera ”A”?",
          "options": {
            "A": "SELECT CodAngajat, Nume, Compartiment FROM ANGAJATI WHERE Nume like A* ;",
            "B": "SELECT COUNT(CodAngajat) AS Numar, Nume, Compartiment FROM ANGAJATI WHERE Nume like \"A*\" GROUP BY Compartiment ;",
            "C": "SELECT CodAngajat, Nume, Compartiment FROM ANGAJATI WHERE Compartiment like A*;",
            "D": "SELECT COUNT(CodAngajat) AS Numar, Compartiment FROM ANGAJATI WHERE Compartiment like \"A*\" GROUP BY Compartiment;",
            "E": "Niciuna dintre cele de mai sus"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Răspunsul corect este D.\n\nExplicație: Întrebarea cere o instrucțiune SQL care afișează numărul de angajați din fiecare compartiment unde numele compartimentului începe cu litera \"A\".\n\n- Opțiunea A este incorectă deoarece selectează coloane individuale fără a agrega numărul pe compartiment.\n- Opțiunea B este incorectă deoarece grupează după \"Compartiment\", dar folosește incorect un filtru pe \"Nume\" cu o sintaxă wildcard care nu este validă în SQL (A* ar trebui să fie 'A%').\n- Opțiunea C este incorectă deoarece selectează coloane individuale fără a număra angajații sau a grupa după compartiment.\n- Opțiunea D este alegerea corectă deoarece numără numărul de angajați pe compartiment (folosind COUNT(CodAngajat)) și grupează rezultatele după compartiment."
        },
        {
          "id": 6,
          "text": "Urmatoarele operatii sunt echivalente:",
          "options": {
            "A": "R3= R1U R2 si R3= APPEND(R1,R2);",
            "B": "R3= R1-R2 si R3 = R1 OR R2;",
            "C": "R3 = R1XR2 si R3 = PRODUCT(R1,R2);",
            "D": "R3=R1U R2 si R3= UNION(R1,R2);",
            "E": "R3=R1-(R1-R2) si AND(R1,R2);"
          },
          "correct_answer": [
            "C",
            "D",
            "E"
          ],
          "explanation": "Întrebarea se referă la determinarea operațiilor pe mulțimi sau relații care sunt echivalente. Iată o scurtă explicație de ce opțiunile C, D și E sunt corecte:\n\nC. R3 = R1 × R2 și R3 = PRODUS(R1, R2):\n   - Ambele operații descriu produsul cartezian al două mulțimi sau relații, asociind fiecare element din R1 cu fiecare element din R2. Astfel, ele sunt echivalente.\n\nD. R3 = R1 ∪ R2 și R3 = UNIUNEA(R1, R2):\n   - Ambele operații descriu uniunea a două mulțimi sau relații, care combină toate elementele unice din R1 și R2 în R3. Prin urmare, ele sunt echivalente.\n\nE. R3 = R1 - (R..."
        },
        {
          "id": 7,
          "text": "Se da tabelul:\nCHITANTE (NrChitanta, Suma, DataChitanta, NrGhiseu )\nCare dintre urmatoarele instructiuni SQL are ca efect afisarea zilelor in care s-au emis mai mult de\n2 chitante?\n",
          "options": {
            "A": "SELECT Nrchitanta, Suma, Data FROM CHITANTE WHERE COUNT(NrChitanta)>2;",
            "B": "SELECT Nrchitanta, Suma, Data FROM CHITANTE HAVING COUNT(NrChitanta)>2;",
            "C": "SELECT CHITANTE.Data FROM CHITANTE GROUP BY Data HAVING COUNT(NrChitanta)>2;",
            "D": "SELECT COUNT(Data), COUNT(NrChitanta) FROM CHITANTE WHERE Data IS Unique;",
            "E": "SELECT Data FROM CHITANTE WHERE COUNT(NrChitanta) > 2;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a determina zilele în care au fost emise mai mult de două chitanțe, trebuie să grupăm datele după dată (`DataChitanta`) și apoi să numărăm chitanțele (`NrChitanta`) pentru fiecare dată. Instrucțiunea SQL care realizează acest lucru este:\n\nC. `SELECT CHITANTE.Data FROM CHITANTE GROUP BY Data HAVING COUNT(NrChitanta)>2;`\n\nExplicație:\n- `GROUP BY Data`: Această clauză grupează înregistrările din tabelul `CHITANTE` după coloana `DataChitanta`, care reprezintă data.\n- `HAVING COUNT(NrChitanta) > 2`: Clauza `HAVING` filtrează grupurile create de `GROUP BY` pentru a afișa doar acelea unde numărul de chitanțe este mai mare de două."
        },
        {
          "id": 8,
          "text": "Se da entitatea ANGAJATI, cu urmatoarele atribute: ANGAJATI (CodAngaj, Nume, DataAngajare, compartiment, profesia, salariu) Care dintre urmatoarele instructiuni SQL permite stergerea salariatilor angajati inainte de inceputul anului 2007, cu profesia ”profesor”.",
          "options": {
            "A": "DELETE FROM Angajati WHERE DataAngajare < ”1/1/2006” AND profesia = ”pro- fesor” ;",
            "B": "DELETE * FROM Angajati WHERE profesia LIKE ”profesor” HAVING YEAR(DataAngajare) <2007;",
            "C": "DELETE Angajati WHERE DataAngajare < \"1/1/2007\" AND profesia LIKE \"*profesor*\";",
            "D": "UPDATE Angajati SET CodAngaj = Null WHERE DataAngajare < ”1/1/2006” AND profesia = ”profesor”;",
            "E": "niciuna"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Răspunsul corect este C. Să analizăm de ce:\n\nÎntrebarea cere instrucțiunea SQL care va șterge angajații (salariații) care au fost angajați înainte de începutul anului 2007 și au profesia \"profesor.\"\n\n- Opțiunea A folosește incorect o comparație de dată pentru înainte de \"1/1/2006\" în loc de \"1/1/2007.\"\n- Opțiunea B folosește o sintaxă incorectă prin combinarea necorespunzătoare a clauzelor WHERE și HAVING și folosește, de asemenea, o funcție (YEAR) care nu este de obicei utilizată în acest mod într-o instrucțiune DELETE.\n- Opțiunea C specifică corect condiția pentru ștergere: angajații angajați înainte de \"1/1/2007\" cu o profesie similară cu \"profesor.\" Utilizarea operatorului LIKE cu wildcard"
        },
        {
          "id": 9,
          "text": "Fie tabelul proiecte(CodProiect;CodAng;functie;suma)cu cheia(CodProiect;CodAng), de stocare a informatiilor privind repartizarea pe proiecte a salariatilor unei firme. Suma obtinuta depinde de CodAng si de functia in acel proiect (CodAng;functie) -> suma. Aplicand a doua forma normala care din schemele urmatoare este corecta?",
          "options": {
            "A": "R1=(CodProiect,CodAng,functie),R2=(CodProiect,functie,suma)",
            "B": "R1=(CodProiect,CodAng, suma), R2=(CodAng,functie)",
            "C": "R1=(CodProiect,CodAng, suma), R2=(CodProiect,functie)",
            "D": "R1=(CodProiect,CodAng), R2=(CodProiect,functie)",
            "E": "Niciuna"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a determina schema corectă în contextul celei de-a doua forme normale (2NF), trebuie să ne asigurăm că toate atributele non-cheie sunt complet dependente funcțional de cheia primară. În tabelul dat, cheia primară este (CodProiect, CodAng), și se menționează că \"suma\" depinde de CodAng și \"funcție\". Acest lucru sugerează că \"funcție\" este parțial dependentă de CodAng, ceea ce încalcă 2NF deoarece nu este complet dependentă de întreaga cheie primară.\n\nPentru a atinge 2NF, trebuie să eliminăm dependențele parțiale prin crearea unor tabele separate:\n\n- În opțiunea A, primul tabel R1=(CodProiect, CodAng, funcție) descompune dependența de"
        },
        {
          "id": 10,
          "text": "Fie relatia r de schema R si X ⊂  R, Y ⊂  R si dependenta tranzitiva K -> X -> Y. Care din urmatoarele descompuneri sunt in forma normala trei?",
          "options": {
            "A": "R1=K(R-Y), R2=(KY)",
            "B": "R1=K(R-Y), R2=(XY)",
            "C": "R1=K(R-Y), R2=(XX)",
            "D": "R1=(R-Y), R2=(XX)",
            "E": "R1=KY, R2=(XX)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Pentru a determina care descompunere este în a treia formă normală (3NF), trebuie să ne asigurăm că descompunerea respectă condițiile 3NF, care sunt:\n\n1. Relația trebuie să fie în a doua formă normală (2NF).\n2. Fiecare atribut non-prim (un atribut care nu face parte din nicio cheie candidat) trebuie să depindă doar de cheile candidat și nu de niciun alt atribut non-prim (adică nu ar trebui să existe dependențe tranzitive).\n\nAvând dependența tranzitivă K -> X -> Y, dorim să descompunem relația astfel încât aceste dependențe să fie păstrate și să nu existe dependențe tranzitive.\n\nÎn opțiunea B, R1=K(R-Y) și R2=(XY), descompunerea este structurată astfel încât:"
        },
        {
          "id": 11,
          "text": "Fie relatia r de schema R, X ⊂ R, Y ⊂ R, Z = R - XY si dependenta multivoca X ->> Y. Care din urmatoarele descompuneri sunt in forma normala patru?",
          "options": {
            "A": "R1=XZ , R2=(XY)",
            "B": "R1=XZ, R2=(X)",
            "C": "R1=K(R-Y), R2=(XZ)",
            "D": "R1=XY, R2=(XZ)",
            "E": "R1=KX, R2=(XZ)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a determina care descompunere este în a patra formă normală (4NF), trebuie să luăm în considerare dependența multivaluată (MVD) X ->> Y. 4NF cere ca pentru fiecare dependență multivaluată netrivială X ->> Y într-o relație, X să fie o supercheie sau relația să fie descompusă.\n\nÎn opțiunile date, avem relația R, cu submulțimile X, Y și Z = R - XY, și dependența multivaluată X ->> Y.\n\nÎn descompunerea A:\n- R1 = XZ și R2 = XY.\n- R1 (XZ) include X, dar exclude Y, în timp ce R2 (XY) include atât X, cât și Y.\n- Această descompunere asigură"
        },
        {
          "id": 12,
          "text": "Fie tabelul Studenti(NrLeg, LimbaStraina, M asina)\n111 Engleza Logan\n111 Franceza Logan\n111 Spaniola Logan\n111 Engleza Cielo\n111 Franceza Cielo\n112 Engleza Logan\n112 Franceza Logan\nsi dependentele multivoce NrLeg \u0010 LimbaStraina, NrLeg \u0010 M asina. Care este reprezentarea\nFN4 determinata de aceste MV-dependente.",
          "options": {
            "A": "R1= NrLeg, LimbaStraina, R2= NrLeg, Masina",
            "B": "R1= Masina,LimbaStraina, R2= NrLeg, LimbaStraina,",
            "C": "R1= NrLeg,LimbaStraina R2= NrLeg,LimbaStraina,Masina",
            "D": "R1= NrLeg,Masina R2= NrLeg,LimbaStraina",
            "E": "R1= NrLeg,Masina R2= NrLeg,LimbaStraina,Masina"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În scenariul dat, avem un tabel numit \"Studenti\" cu atributele NrLeg, LimbaStraina și Masina. Ne sunt furnizate dependențele multivaluate (MVD-uri) NrLeg →→ LimbaStraina și NrLeg →→ Masina.\n\nPentru a atinge Forma Normală Patru (4NF), o relație nu trebuie să aibă dependențe multivaluate netriviale, altele decât o cheie candidat. Aceasta înseamnă că trebuie să descompunem tabelul astfel încât fiecare relație din descompunere să aibă cel mult o dependență multivaluată netrivială.\n\nAvând în vedere MVD-urile:\n1. NrLeg →→ LimbaStraina\n2. NrLeg →→ Masina\n\nDescompunem tabelul original în două"
        },
        {
          "id": 13,
          "text": "Restrictiile referentiale intre 2 tabele sunt date de:",
          "options": {
            "A": "Cheile primare si cheile externe",
            "B": "Coloanele commune",
            "C": "Coloanele din clauza CHECK",
            "D": "Coloanele din SELECT",
            "E": "Chei externe"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A. Cheile primare și cheile externe sunt componente fundamentale ale integrității referențiale în bazele de date relaționale. Integritatea referențială este un concept care asigură că relațiile dintre tabele rămân consistente. O cheie primară este un identificator unic pentru fiecare înregistrare dintr-un tabel, în timp ce o cheie externă este un câmp (sau o colecție de câmpuri) într-un tabel care identifică în mod unic un rând dintr-un alt tabel. Cheia externă creează o legătură între cele două tabele, asigurându-se că orice valoare din coloana cheii externe corespunde unei valori din coloana cheii primare a tabelului asociat. Acest mecanism impune integritatea și acuratețea datelor între tabele."
        },
        {
          "id": 14,
          "text": "Fie baza de date formata din tabelele: studenti(NrLeg, Nume, Pren, Fac,An,grupa) cataloage(NrLeg,CodDis,dat,nota), discipline(CodDis,Denumire,NrOreC, NrOreL, NrOreS, NrOreP,Credite,An,Sectie). Care din expresiile algebrei relationale determina studentii din anul II:",
          "options": {
            "A": "πAn(studenti)",
            "B": "σAn=2(studenti)",
            "C": "πAn(σAn=2(studenti))",
            "D": "σAn(πAn=2(studenti))",
            "E": "πNume(studenti)"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În algebra relațională, simbolurile și operatorii sunt folosiți pentru a manipula și interoga baze de date relaționale. În acest context:\n\n- Operatorul σ (sigma) reprezintă selecția, care se folosește pentru a extrage rândurile (tupluri) dintr-o relație care satisfac o anumită condiție.\n- În expresia σAn=2(studenti), operatorul σ este utilizat pentru a selecta doar acei studenți din tabelul \"studenti\" care sunt în anul II (An=2).\n\nAlte opțiuni nu sunt corecte pentru că:\n\n- A. πAn(studenti) ar returna doar o proiecție a"
        },
        {
          "id": 15,
          "text": "Pentru o baza de date relationala algebra relationala este:",
          "options": {
            "A": "Completa (permite sa extrag orice informatii din baza)",
            "B": "Procedurala (Arata si modul cum se obtin informatiile din baza de date)",
            "C": "Complexa (permite sa extrag informatii obiectuale)",
            "D": "Limbaj formal",
            "E": "Limbaj de interogare"
          },
          "correct_answer": [
            "A",
            "B",
            "D",
            "E"
          ],
          "explanation": "Întrebarea se referă la caracteristicile algebrei relaționale în contextul bazelor de date relaționale. Iată o scurtă explicație pentru fiecare opțiune corectă:\n\nA. Completă (permite extragerea oricăror informații din bază) - Algebra relațională este considerată completă deoarece oferă un set de operații care pot fi utilizate pentru a interoga și manipula datele în orice mod necesar pentru a extrage toate informațiile posibile dintr-o bază de date relațională.\n\nB. Procedurală (arată și modul în care se obțin informațiile din baza de date) - Algebra relațională este procedurală, ceea ce înseamnă că specifică o secvență de operații care trebuie efectuate pentru a obține datele dorite. Ea descrie cum poate fi obținut rezultatul, spre deosebire de limbajele declarative care se concentrează pe ce rezultat este necesar.\n\nD. Limbaj formal -"
        },
        {
          "id": 16,
          "text": "Restrictiile date de dependentele functionale pentru un tabel se testeaza cu ajutorul:",
          "options": {
            "A": "Axiomelor de inferenta",
            "B": "Algoritmul de satisfacere(satisfie)",
            "C": "Algoritmul de inchidere",
            "D": "Algoritmul de sortare",
            "E": "Algoritmul de normalizare"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Răspunsul corect este B. Algoritmul de satisfacere (satisfie) deoarece este conceput special pentru a verifica dacă un set de dependențe funcționale poate fi satisfăcut sau menținut într-o schemă de bază de date dată. Acest lucru implică verificarea dacă dependențele sunt valabile pentru datele din tabel. Acest proces asigură respectarea constrângerilor impuse de dependențele funcționale, ceea ce este esențial pentru menținerea integrității și consistenței datelor. Celelalte opțiuni, cum ar fi axiomele de inferență, algoritmii de închidere, algoritmii de sortare și algoritmii de normalizare, au scopuri diferite în gestionarea bazelor de date și nu sunt utilizate direct pentru testarea constrângerilor de dependență funcțională."
        },
        {
          "id": 17,
          "text": "Fiind data apriori o multime de restrictii data de o multime de dependente funtionale F. Elaborarea\nunei reguli de validare pentru o dependenta functionala X → Y presupune:",
          "options": {
            "A": "Verificarea deductibilitatii din F",
            "B": "Verificarea incluziunii X ⊂ Y",
            "C": "Verificarea incluziunii X ⊂ X+",
            "D": "Normalizarea schemei de relatie XY",
            "E": "Toate"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "Pentru a elabora o regulă de validare pentru o dependență funcțională \\( X \\rightarrow Y \\), trebuie să ne asigurăm că această dependență este consistentă cu setul dat de dependențe funcționale \\( F \\).\n\n- **A. Verificarea deductibilității din F**: Aceasta înseamnă verificarea dacă dependența \\( X \\rightarrow Y \\) poate fi dedusă logic din setul \\( F \\). Acest lucru asigură că dependența este validă conform constrângerilor existente.\n\n- **C. Verificarea incluziunii \\( X \\subseteq X^+ \\)**: Aceasta implică verificarea dacă setul \\( X \\) este inclus în închiderea sa \\( X^+ \\) cu privire la \\( F \\). Acest lucru este întotdeauna adevărat prin definiție, dar în contextul validării,"
        },
        {
          "id": 18,
          "text": "Fiind data apriori o multime de restrictii data de o multime de dependente funtionale F. Elaborarea\nunei proceduri pentru a verifica dependenta functionala X → Y presupune mai intai:",
          "options": {
            "A": "Verificarea redundantei acesteia",
            "B": "Inlaturarea atributelor eliminabile din determinantul X",
            "C": "Inlaturarea atributelor eliminabile din determinantul Y",
            "D": "Inlaturarea atributelor eliminabile din X si Y",
            "E": "Niciuna"
          },
          "correct_answer": [
            "A",
            "B",
            "C",
            "D"
          ],
          "explanation": "Pentru a verifica o dependență funcțională \\( X \\rightarrow Y \\) dat un set de dependențe funcționale \\( F \\), procesul implică asigurarea că dependența este atât necesară, cât și ireductibilă. Aceasta include verificarea redundanței și simplificarea atributelor implicate. Iată o explicație succintă pentru fiecare pas:\n\nA. **Verificarea redundanței acesteia**: Acest pas implică verificarea dacă dependența \\( X \\rightarrow Y \\) este redundantă în raport cu celelalte dependențe din \\( F \\). Dacă poate fi derivată din alte dependențe, poate fi inutil să o includem explicit.\n\nB. **Înlăturarea atributelor eliminabile din determinantul X**: Acest pas implică eliminarea oricăror atribute din determinantul \\( X \\) care nu afectează dependența. Dacă..."
        },
        {
          "id": 19,
          "text": "Fiind data apriori o multime de restrictii data de o multime de dependente funtionale F. Aceasta este folosita la:",
          "options": {
            "A": "Normalizarea bazei de date",
            "B": "La validarea starii bazei de date",
            "C": "Crearea bazei de date",
            "D": "Crearea procedurilor de interogare",
            "E": "Constructia algebrei relationale"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "În contextul bazelor de date, un set de dependențe funcționale (F) este esențial pentru înțelegerea și organizarea structurii datelor. Iată o scurtă explicație pentru fiecare opțiune:\n\nA. Normalizarea bazei de date: Dependențele funcționale sunt fundamentale în normalizarea bazelor de date, care este procesul de organizare a unei baze de date pentru a reduce redundanța și a îmbunătăți integritatea datelor. Ele ajută la determinarea formelor normale ale unei scheme de baze de date prin identificarea relațiilor dintre diferite atribute.\n\nB. Validarea stării bazei de date: Dependențele funcționale sunt utilizate pentru a asigura că starea curentă a bazei de date respectă anumite reguli și constrângeri. Prin validarea acestor dependențe, se poate verifica dacă datele din baza de date sunt consistente cu regulile definite, asigurând astfel integritatea datelor."
        },
        {
          "id": 20,
          "text": "Interogarile din SQL sunt la fel de expresive cu:",
          "options": {
            "A": "Algebra relationala",
            "B": "Calculul relational al tuplurilor",
            "C": "Calculul relational al domeniilor",
            "D": "Calculul procedural",
            "E": "Calculul bazat pe tablouri"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "În SQL, interogările sunt concepute pentru a fi la fel de expresive ca cele din algebra relațională și calculul relațional. Algebra relațională oferă o modalitate procedurală de a interoga bazele de date, concentrându-se pe operațiuni precum selecția, proiecția și îmbinările. Calculul relațional, pe de altă parte, este neprocedural și vine în două forme: calculul relațional pe tupluri (TRC) și calculul relațional pe domenii (DRC). Atât TRC, cât și DRC descriu ce rezultate sunt dorite fără a specifica modul de calcul al acestora. SQL combină expresivitatea acestor abordări, permițând utilizatorilor să recupereze și să manipuleze datele eficient. Prin urmare, interogările SQL sunt la fel de expresive ca cele din algebra relațională (A), calculul relațional pe tupluri (B) și calculul relațional pe domenii (C). Calculul procedural (D) și calculul baz..."
        }
      ]
    },
    {
      "name": "Fundamentele bazelor de date",
      "questions": [
        {
          "id": 1,
          "text": "O baza de date distribuita este:",
          "options": {
            "A": "O colectie de date si de scheme partajate si interconectate logic, distribuite fizic pe calculatoarele unei retele,",
            "B": "O colectie de date impartita in mai multe fragmente,",
            "C": "O colectie de date impartita in mai multe replici,",
            "D": "O colectie de fragmente mixte.",
            "E": "Niciuna."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "O bază de date distribuită este un sistem în care baza de date nu este stocată într-o singură locație, ci este răspândită pe mai multe calculatoare sau site-uri conectate printr-o rețea. Opțiunea A definește corect acest concept afirmând că este o \"colecție de date și scheme care sunt partajate și interconectate logic, distribuite fizic pe calculatoarele unei rețele.\" Aceasta înseamnă că, deși datele sunt separate fizic, ele sunt integrate logic pentru a funcționa ca un sistem unic de baze de date. Prin urmare, răspunsul corect este A, deoarece surprinde esența a ceea ce o bază de date distribuită este menită să realizeze: stocare descentralizată cu acces și gestionare centralizate."
        },
        {
          "id": 2,
          "text": "O tranzactie este:",
          "options": {
            "A": "O unitate de program ce realizeaza citiri si scrieri,",
            "B": "O multime finita si ordonata de operatii de citire, scriere si terminare,",
            "C": "O multime de instructiuni executabile dintr-un limbaj gazda,",
            "D": "O serie finita de opeartii de modificare a datelor dintr-o baza de date ORACLE",
            "E": "O multime finita de operatii coerente, executate de un SGBD, care\n manipuleaza datele unei baze de date."
          },
          "correct_answer": [
            "E"
          ],
          "explanation": "Răspunsul corect este E, deoarece o tranzacție în contextul unui sistem de gestiune a bazelor de date (SGBD) se referă la un set finit de operațiuni coerente care sunt executate pentru a manipula datele dintr-o bază de date. Tranzacțiile asigură că operațiunile asupra bazei de date sunt finalizate cu succes și mențin integritatea datelor, urmând de obicei proprietățile ACID (Atomicitate, Coerență, Izolare, Durabilitate). Opțiunea E surprinde cel mai bine această definiție, subliniind coerența și natura finită a acestor operațiuni, precum și executarea lor de către un sistem de gestiune a bazelor de date. Alte opțiuni fie nu cuprind pe deplin conceptul de tranzacție, fie descriu procese conexe, dar distincte."
        },
        {
          "id": 3,
          "text": "Numele unei coloane dintr-un tabelin ORACLE :",
          "options": {
            "A": "trebuie sa fie unic in cadrul tabelului,",
            "B": "trebuie sa fie unicin cadrul bazei de date,",
            "C": "are asociat un index ,",
            "D": "trebuie sa aparaa in instructiunea CREATE TABLE,",
            "E": "rebuie sa fie specificat a in instructiunea ALTER TABLE."
          },
          "correct_answer": [
            "A",
            "D"
          ],
          "explanation": "În Oracle, numele unei coloane dintr-un tabel trebuie să respecte anumite reguli pentru a asigura o gestionare și o integritate corespunzătoare a bazei de date.\n\nA. Numele coloanei trebuie să fie unic în cadrul tabelului pentru a evita confuzia și a asigura că fiecare coloană poate fi identificată distinct prin numele său. Această cerință de unicitate este specifică tabelului, permițând existența aceluiași nume de coloană în tabele diferite din aceeași bază de date.\n\nD. Un nume de coloană trebuie să apară în instrucțiunea CREATE TABLE deoarece aici este definită structura tabelului, inclusiv coloanele sale și tipurile de date corespunzătoare. Fără a specifica numele și tipurile coloanelor în instrucțiunea CREATE TABLE, tabelul nu poate fi creat sau utilizat corespunzător.\n\nOpțiunile B, C și E sunt incorecte deoarece:\n- B. Numele coloanelor nu au"
        },
        {
          "id": 4,
          "text": "O tranzactie urmeaza un protocol in doua faze daca:",
          "options": {
            "A": "Blocheaza accesul la un element de date,",
            "B": "Toate opratiile de blocare preced prima operatie de deblocare,",
            "C": "Cere mai intai deblocarea si apoi realizeaza blocarea accesului la un element de date,",
            "D": "Blocheaza tabelul la care are acces,",
            "E": "Blocheaza accesul altor utilizatori la o baza de date."
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Răspunsul corect, B, se referă la protocolul de blocare în două faze, care este o metodă de control al concurenței utilizată în sistemele de baze de date pentru a asigura serializabilitatea tranzacțiilor. În acest protocol, o tranzacție urmează două faze distincte:\n\n1. **Faza de creștere**: În timpul acestei faze, tranzacția poate obține blocări, dar nu poate elibera nicio blocare. Acest lucru asigură că toate blocările necesare sunt obținute înainte de a modifica orice date.\n\n2. **Faza de descreștere**: Odată ce tranzacția eliberează prima sa blocare, intră în faza de descreștere, în care nu mai poate obține noi blocări.\n\nOpțiunea B, care afirmă că toate operațiunile de blocare preced prima operațiune de deblocare, descrie cu acuratețe acest comportament în două faze, asigurând că tranzacțiile sunt executate într-un mod serializabil, fără a provoca conflicte sau inconsistențe în sistem."
        },
        {
          "id": 5,
          "text": "Proprietatea de consistenta a tranzactiei consta din:",
          "options": {
            "A": "Transformarea unei stari consistente intr-o stare consistenta,",
            "B": "Eliminarea redundantelor,",
            "C": "Izolarea tranzactiilor in executie,",
            "D": "Transparenta,",
            "E": "Durabilitate."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Proprietatea de consistență într-o tranzacție se referă la principiul conform căruia o tranzacție a bazei de date trebuie să tranziționeze baza de date de la o stare validă la o altă stare validă. Aceasta înseamnă că, dacă baza de date se află într-o stare consistentă înainte de începerea tranzacției, trebuie să rămână într-o stare consistentă după finalizarea tranzacției, presupunând că nu există alte tranzacții care să interfereze. Acest lucru este crucial pentru menținerea integrității datelor. Prin urmare, răspunsul corect este A, deoarece abordează direct transformarea unei stări consistente într-o altă stare consistentă."
        },
        {
          "id": 6,
          "text": "Un cursor este:",
          "options": {
            "A": "Un pointer catre un set de rezultate,",
            "B": "un set de rezultate ale instructiunii select,",
            "C": "o metoda de analiza a performantei,",
            "D": "o colectie de randuri ale unei tabele,",
            "E": "Sun buffer care pastreaza rezultatul unei istructiuni SELECT."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Un cursor este un obiect de bază de date utilizat pentru a prelua, manipula și naviga printr-un set de rezultate returnate de o interogare. Acesta acționează ca un indicator către setul de rezultate, permițând procesarea rând cu rând. Acest lucru face ca opțiunea A să fie alegerea corectă, deoarece descrie cu acuratețe rolul cursorului în gestionarea bazelor de date. Un cursor nu este setul de rezultate în sine (B), nu este o metodă pentru analiza performanței (C), o colecție de rânduri de tabel (D) sau un tampon pentru stocarea rezultatelor interogării (E)."
        },
        {
          "id": 7,
          "text": "Abordarea distribuita a unei baze de date oglindeste:",
          "options": {
            "A": "Structura organizationala,",
            "B": "Paralelismul prelucrarilor",
            "C": "Gestiunile locale ale bazelor de date,",
            "D": "Seriabilitatea tranzactiilor,",
            "E": "Toate."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A. O abordare bazată pe baze de date distribuite reflectă structura organizațională deoarece permite diferitelor părți ale unei organizații să își gestioneze și să acceseze datele în mod independent, fiind în același timp parte a unui sistem mai mare și coerent. Această structură poate reflecta diviziunile geografice, funcționale sau departamentale din cadrul organizației, permițând controlul și eficiența localizată, menținând totodată integritatea și coordonarea generală a datelor."
        },
        {
          "id": 8,
          "text": "O baza de date distribuita se gaseste implementata numai:",
          "options": {
            "A": "Intr-o retea de calculatoare,",
            "B": "Pe un calculator performant,",
            "C": "Pe mai multe calculatoare izolate, conectate la Internet,",
            "D": "Pe un Calculator client,",
            "E": "Pe un laptop."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "O bază de date distribuită este implementată în mai multe locații, în principal pentru a îmbunătăți performanța, fiabilitatea și disponibilitatea. Opțiunea A, \"Într-o rețea de calculatoare\", este corectă deoarece o bază de date distribuită necesită coordonarea și comunicarea între mai multe calculatoare dintr-o rețea pentru a gestiona și stoca datele. Această configurație permite ca baza de date să fie distribuită pe diferite noduri, asigurându-se că, chiar dacă un nod eșuează, datele pot fi accesate în continuare de la alte noduri din rețea. Opțiunile B, C, D și E nu oferă infrastructura necesară pentru o bază de date distribuită, deoarece sugerează fie medii de calcul izolate, fie singulare."
        },
        {
          "id": 9,
          "text": "Tranzactiile se numesc in 2 faze daca :",
          "options": {
            "A": "Satisfac protocolul in 2 faze,",
            "B": "Sunt formate numai din citiri si scrieri,",
            "C": "Contin comenzile commit si rollback,",
            "D": "Contin 2 faze de executie,",
            "E": "Contin 2 faze, una de definire a datelor, si alta de prelucrare a lor."
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În contextul bazelor de date, tranzacțiile „în 2 faze” se referă la un protocol specific de control al tranzacțiilor, cunoscut sub numele de protocolul în două faze (Two-Phase Commit Protocol). Acest protocol este utilizat pentru a asigura că toate părțile implicate într-o tranzacție distribuită sunt de acord să o finalizeze sau să o anuleze, menținând astfel integritatea datelor. Prima fază implică pregătirea și votul tuturor participanților pentru a comite sau a anula tranzacția, iar a doua fază se ocupă de finalizarea efectivă a tranzacției pe baza deciziei luate."
        },
        {
          "id": 10,
          "text": "Se dau tabelele\nPERSONAL(Marca, Numepren, Compart, Datasv, Salorar,Salorarco, Compart)\nPONTAJE(Marca, Data, Orelucrate, Oreco, Orenoapte, Oreabsnem)\nCe afiseaza urmatoarea interogare?\n\nWITH VENITURI AS\n(SELECT Numepren, SUM(Orelucrate*Salorar+Oreco*Salorarco) AS Venit_Baza\nFROM PONTAJE po INNER JOIN PERSONAL pe ON po.Marca=pe.Marca GROUP BY Numepren),\nrasp AS\n(SELECT MAX(SUM(Orelucrate*Salorar+Oreco*Salorarco)) AS Venit_Max from PONTAJE po\nINNER JOIN PERSONAL pe ON po.Marca=pe.Marca GROUP BY Numepren)\nSELECT Numepren,Venit_Baza from VENITURI INNER JOIN rasp ON Venit_Baza=Venit_Max",
          "options": {
            "A": "Venitul maxim al unui angajat dintr-un compartiment utilizand expresii tabela",
            "B": "Angajatul sau angajatii cu cel mai mare venit utilizand expresii tabela",
            "C": "Venitul de baza al unui angajat utilizand operatorul INNER JOIN",
            "D": "Veniturile angajatilorin ordine descrescatoare utilizand expresii tabela",
            "E": "Numele angajatului din fiecare compartiment cu venitul cel mai mare"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Interogarea utilizează expresii tabelare comune (CTE) pentru a calcula și identifica angajații cu cele mai mari câștiguri. Prima CTE, `VENITURI`, calculează venitul de bază (`Venit_Baza`) pentru fiecare angajat prin însumarea muncii lor normale și a orelor suplimentare înmulțite cu ratele lor salariale respective. A doua CTE, `rasp`, determină câștigul maxim din aceste sume calculate. Instrucțiunea finală `SELECT` extrage numele și veniturile de bază ale angajaților ale căror câștiguri se potrivesc cu câștigul maxim calculat în `rasp`. Prin urmare, interogarea identifică și afișează în mod eficient angajatul sau angajații cu cele mai mari câștiguri, ceea ce corespunde opțiunii B: \"Angajatul sau angajații cu cel mai mare venit utilizând expresii tabelare\" (The employee or employees with the highest earnings using table expressions)."
        },
        {
          "id": 11,
          "text": "Se da tabelul\nPREZENTA(Marca, Data, Orelucrate, Oreco, Orenoapte, Oreabsnem)\nCe executa urmatoarea secventa?\n\nDECLARE an salarii.an\\%TYPE := 2015;\nluna salarii.luna\\%TYPE := 1;\nprima_zi DATE ; zi DATE; BEGIN prima_zi :=\nTO_DATE(’01/’||luna||’/’||an, ’DD/MM/YYYY’); zi:= prima_zi; WHILE\nzi <= LAST_DAY(prima_zi) LOOP IF RTRIM(TO_CHAR(zi,’DAY’)) IN\n(’SATURDAY’, ’SUNDAY’) THEN NULL;\n ELSE\n BEGIN\n  INSERT INTO pontaje (marca, data)\n   SELECT marca, zi FROM personal;\n   EXCEPTION\n   WHEN DUP_VAL_ON_INDEX THEN\n   DELETE FROM pontaje WHERE data=zi;\n   INSERT INTO pontaje (marca, data)\n   SELECT marca, zi FROM personal;\n END;\n END IF;\n  zi:=zi + 1;\n END LOOP;\n COMMIT;\n END;",
          "options": {
            "A": "Introduce inregistrari numai pentru zilele nelucratoare",
            "B": "Populeaza cu inregistrari tabela pe o luna dintr-un an",
            "C": "Nu populeaza tabela datorita exceptiei DUP-VAL-ON-INDEX",
            "D": "Daca se executa de doua ori succesiv, nu produce rezultate",
            "E": "Daca se executa de doua ori succesiv, dubleazainregistrarile din tabela"
          },
          "correct_answer": [
            "B",
            "D"
          ],
          "explanation": "Blocul PL/SQL dat este conceput pentru a popula un tabel numit `pontaje` pentru fiecare zi lucrătoare a unei luni și ani specificați. Iată defalcarea secvenței:\n\n1. **Inițializare**: Variabilele `an` și `luna` sunt inițializate cu valorile `2015` și `1`, respectiv. Aceasta înseamnă că operațiunea este setată pentru ianuarie 2015.\n\n2. **Calculul datei**: `prima_zi` este setată la prima zi a lunii și anului specificate, iar `zi` este inițializată cu această dată.\n\n3. **Parcurgerea zilelor**: Bucla iterează peste fiecare zi a lunii (`zi <= LAST_DAY(prima_zi)`), incrementând `zi` cu o zi în"
        },
        {
          "id": 12,
          "text": "Se da tabelul \nSTUDENT(CNP, Nume, Grupa, Adresa) \nCare secventa creaza un view ce permite ca modificarile in tabela \nsa se reflecte automat siin view?",
          "options": {
            "A": "CREATE VIEW stud AS \nSELECT * FROM STUDENT WHERE Grupa IN (210,220);",
            "B": "CREATE VIEW emp_vu AS \nSELECT * FROM STUDENT WHERE Grupa IN (210,220) \nWITH READ ONLY;",
            "C": "CREATE VIEW stud AS \nSELECT * FROM STUDENT WHERE Grupa IN (210,220) \nWITH CHECK OPTION;",
            "D": "CREATE FORCE VIEW stud AS \nSELECT * FROM STUDENT WHERE Grupa IN (210,220);",
            "E": "CREATE FORCE VIEW stud AS \nSELECT * FROM STUDENT WHERE Grupa=210 OR GRUPA=220;"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Răspunsul corect este C.\n\nExplicație: În SQL, o vizualizare este un tabel virtual bazat pe rezultatul unei interogări SELECT. Pentru a asigura că modificările făcute în tabelul de bază sunt reflectate în vizualizare, vizualizarea trebuie să suporte actualizări. Clauza \"WITH CHECK OPTION\" în definiția vizualizării (opțiunea C) impune ca orice actualizări sau inserții făcute prin vizualizare să satisfacă condițiile de definire ale vizualizării. Aceasta înseamnă că orice modificare în tabelul de bază care ar duce la excluderea unui rând din condiția vizualizării (în acest caz, unde `Grupa` este fie 210, fie 220) nu va fi permisă decât dacă satisface în continuare condiția. Acest lucru asigură că vizualizarea reflectă întotdeauna starea curentă a tabelului conform"
        },
        {
          "id": 13,
          "text": "Se da tabelul \nSTUDENT(CNP, Nume, Grupa, Adresa) \nsi urmatoarea secventa ce reprezinta o tranzactie: \n\nCREATE table STUDENT_NOU ( CNP NUMBER, Nume VARCHAR2(30)); \nINSERT INTO STUDENT_NOU SELECT CNP, Nume from STUDENT; \nSavepoint s1; \nUPDATE STUDENT_NOU SET Nume = UPPER(Nume); \nSavepoint s2; \nDELETE FROM STUDENT_NOU; \nRollback to s2; \nDELETE FROM STUDENT_NOU WHERE CNP=100; \nUPDATE STUDENT_NOU SET Nume = ’Ionescu’; \nRollback to s2; \nUPDATE STUDENT_NOU SET Nume = ’Ionescu’ WHERE CNP=100; \nRollback; \n\nCare este rezultatul acestei tranzactii?",
          "options": {
            "A": "Nu avem linii in tabela",
            "B": "Avem un student cu numele Ionescu",
            "C": "Nu putem sa facem Rollback mai mult de o data pe un punct de reluare",
            "D": "Ultimul UPDATE esueaza deoarece studentul cu CNP-ul 100 a fost sters",
            "E": "Tranzactia esueaza deoarece avem mai multe puncte de reluare"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Întrebarea implică o serie de operațiuni SQL efectuate asupra unui tabel dintr-o bază de date, incluzând utilizarea de puncte de salvare și reveniri. Iată o descriere detaliată:\n\n1. Se creează un nou tabel `STUDENT_NOU`, iar datele sunt copiate din tabelul existent `STUDENT` în `STUDENT_NOU`.\n2. Se creează un punct de salvare `s1` după inserare.\n3. Coloana `Nume` din `STUDENT_NOU` este actualizată pentru a fi cu majuscule pentru toate intrările, urmată de un alt punct de salvare `s2`.\n4. Toate intrările sunt șterse din `STUDENT_NOU`.\n5. Se execută o revenire la `s2`, restaurând tabelul la starea de imediat după ce numele au fost convertite în majuscule, dar înainte de orice..."
        },
        {
          "id": 14,
          "text": "Se dau tabelele \nANGAJATI(ID-Angajat, Nume, ID-Compart, Salariu) \nCOMPARTIMENT (ID-Compart, Nume-Compart) \nsi urmatoarea interogare: \nSELECT e.EMPLOYEE_ID,e.LAST_NAME,e.DEPARTMENT_ID, d.DEPARTMENT_NAME \nFROM EMP e, DEPARTMENT d \nWHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID; \n\nCe operatii implementeaza aceasta interogare?",
          "options": {
            "A": "Diferenta, proiectia si join",
            "B": "Selectia, proiectia si join",
            "C": "Selectia, intersectia si join",
            "D": "Intersectia, proiectia si join",
            "E": "Diferenta, intersectia si join"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "Interogarea furnizată efectuează trei operațiuni principale: selecție, proiecție și îmbinare.\n\n1. **Îmbinare (Join)**: Interogarea utilizează o condiție de îmbinare (`WHERE e.DEPARTMENT_ID = d.DEPARTMENT_ID`) pentru a combina rânduri din tabelele `EMP` (angajați) și `DEPARTMENT` pe baza ID-urilor de departament care se potrivesc. Această operațiune permite extragerea de date corelate din ambele tabele.\n\n2. **Proiecție (Projection)**: Clauza `SELECT` specifică ce coloane să fie extrase din setul de date combinat: `e.EMPLOYEE_ID`, `e.LAST_NAME`, `e.DEPARTMENT_ID` și `d.DEPARTMENT_NAME`. Această operațiune implică selectarea anumitor coloane din setul de rezultate.\n\n3. **Selecție (Selection)**: Îmbinarea"
        },
        {
          "id": 15,
          "text": "Se da tabelul \nSTUDENT(CNP, Nume, Grupa, Adresa) cu cheia primara CNP \nsi urmatoarele doua declansatoare: \n\nD1. CREATE OR REPLACE TRIGGER t1 \n BEFORE INSERT ON STUDENT \n REFERENCING OLD AS OLD NEW AS NEW \n FOR EACH ROW \n BEGIN \n  SELECT NVL(MAX(CNP),100)+1 INTO:NEW.CNP FROM STUDENT; \n END; \nD2. CREATE SEQUENCE secventa INCREMENT BY 1 \n INVALUE 101 MAXVALUE 500 NOCYCLE NOCACHE ORDER; \n\n CREATE OR REPLACE TRIGGER t2 \n BEFORE INSERT ON STUDENT \n REFERENCING OLD AS OLD NEW AS NEW \n FOR EACH ROW \n BEGIN \n  SELECT secventa.NEXTVAL INTO:NEW.CNP FROM STUDENT; \n END; \n\nCare dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Declansatorul D1 atribuie o valoare maxima atributului CNP  inainte de o noua inserare",
            "B": "Cele doua declasatoare produc acelasi rezultat",
            "C": "Declansatorul D2 nu violeaza restrictia de cheie primara",
            "D": "Declansatorul D1 poate viola restrictia de cheie primara",
            "E": "Cele doua declasatoare nu produc acelasi rezultat"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "Pentru a înțelege întrebarea, trebuie să analizăm comportamentul declanșatoarelor și al secvenței:\n\nA. **Declanșatorul D1 atribuie o valoare maximă atributului CNP înainte de o nouă inserare**  \n   Această afirmație este adevărată deoarece Declanșatorul D1 selectează valoarea maximă a CNP din tabelul STUDENT, adaugă 1 la aceasta și atribuie această valoare noului CNP înainte de o inserare.\n\nB. **Cele două declanșatoare produc același rezultat**  \n   Această afirmație nu este adevărată. Deși ambele declanșatoare au ca scop furnizarea unei noi valori CNP înainte de a insera un înregistrare, valorile pe care le produc pot diferi. D1 folosește valoarea maximă existentă a CNP plus unu, în timp ce D2 folosește o secvență care poate..."
        },
        {
          "id": 16,
          "text": "Se dau tabelele \nANGAJATI(ID-Angajat, Nume, ID-Compart, Salariu) \nCOMPARTIMENT (ID-Compart, Nume-Compart) \nsi urmatorul declansator: \n\nCREATE OR REPLACE TRIGGER actual \nAFTER UPDATE OF ID_Compart ON COMPARTIMENT \nREFERENCING OLD AS OLD NEW AS NEW \nFOR EACH ROW \nBEGIN \n UPDATE ANGAJATI SET ID_Compart=:NEW.ID_Compart WHERE ID_Compart=:OLD.ID_Compart; \nEND; \n\nCare dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Comanda UPDATE trebuie sa se limiteze numai la o linie a tabelei COM- PARTIMENT",
            "B": "Declansatorul implementeaza optiunea UPDATE CASCADE din Oracle",
            "C": "Declansatorul se va lansa numai la modificarea atributului ID-Compart din tabela COMPARTIMENT",
            "D": "Comanda UPDATE poate modifica mai multe linii din tabela ANGAJATI",
            "E": "Comanda UPDATE nu poate modifica mai multe linii din tabela ANGAJATI"
          },
          "correct_answer": [
            "A",
            "B",
            "C",
            "D"
          ],
          "explanation": "Declanșatorul dat este conceput pentru a gestiona actualizările coloanei `ID_Compart` din tabelul `COMPARTIMENT`. Iată o explicație a motivului pentru care fiecare dintre afirmațiile selectate este adevărată:\n\nA. Comanda UPDATE trebuie să se limiteze numai la o linie a tabelului COMPARTIMENT  \n   - Adevărat: Declanșatorul este definit să se activeze după o actualizare pe `ID_Compart` pentru fiecare rând din tabelul `COMPARTIMENT`. Acest lucru implică faptul că instrucțiunea de actualizare care declanșează această acțiune ar trebui, ideal, să afecteze doar un singur rând la un moment dat în `COMPARTIMENT` pentru ca acest declanșator să se execute corect.\n\nB. Declanșatorul implementează opțiunea UPDATE CASCADE din Oracle  \n   - Adevărat: Declanșatorul efectiv mimează opțiunea UPDATE CASCADE, care este folosită pentru a asigura că modificările dintr-o tabelă părinte sunt propagate automat la tabelele copil asociate."
        },
        {
          "id": 17,
          "text": "Se da tabelul \nPERSONAL(Marca, Numepren,Compart,Datasv,Salorar,Salorarco,Compart) \nsi urmatorul bloc PL/SQL: \n\nDECLARE \nani_etalon PLS_INTEGER := 15; \nnumar PLS_INTEGER; \n BEGIN \n UPDATE personal SET salorar = salorar + 10 \n WHERE MONTHS_BETWEEN (SYSDATE,datasv) / 12 >= ani_etalon; \n IF SQL%FOUND THEN \n  DBMS_OUTPUT.PUT_LINE(’Exista cel putin un angajat cu vechime de peste ’ || \n  ani_etalon ||’ ani’); \n  numar:= SQL%ROWCOUNT; \n  DBMS_OUTPUT.PUT_LINE(’Numarul lor este ’ || numar); \n ELSE \n  DBMS_OUTPUT.PUT_LINE(’Nici un angajat nu indeplineste conditia’); \n END IF; \n END; \n\nCare dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Blocul mareste cu 10 lei salariul orar al tuturor angajatilor",
            "B": "Este un exemplu de cursor implicit",
            "C": "Blocul mareste cu 10 lei salariul orar al angajatilor cu o vechime de peste 15 ani",
            "D": "Pentru afisarea la ecran a mesajelor din bloc, trebuie lansata comanda SET SERVEROUTPUT",
            "E": "Blocul mareste cu 12 lei salariul orar al tuturor angajatilor"
          },
          "correct_answer": [
            "B",
            "C",
            "D"
          ],
          "explanation": "Blocul PL/SQL furnizat implică actualizarea salariilor angajaților dintr-un tabel de baze de date numit PERSONAL. Iată o explicație pentru fiecare afirmație:\n\nA. **Fals** - Blocul nu mărește salariul orar al tuturor angajaților, ci doar al celor cu mai mult de 15 ani de serviciu.\n\nB. **Adevărat** - Acesta este un exemplu de utilizare a unui cursor implicit. PL/SQL creează automat un cursor implicit pentru instrucțiuni SQL precum UPDATE, iar atributele precum SQL%FOUND și SQL%ROWCOUNT sunt utilizate pentru a verifica rezultatul execuției.\n\nC. **Adevărat** - Blocul actualizează în mod specific salariul orar (salorar) cu 10 pentru angajații care au mai mult de 15 ani de serviciu, așa cum este calculat de condiția `MONTHS_BETWEEN(SYSD...`."
        },
        {
          "id": 18,
          "text": "Se dau tabelele \nPERSONAL(Marca, Numepren, Compart, Datasv, Salorar,Salorarco, Compart) \nPONTAJE(Marca, Data, Orelucrate, Oreco, Orenoapte, Oreabsnem) \nsi urmatoarea procedura: \n\nCREATE OR REPLACE PROCEDURE populare \n(an_ IN salarii.an%TYPE, luna_ IN salarii.luna%TYPE) \nIS \nprima_zi DATE ; \nzi DATE ; \nBEGIN \nprima_zi := TO_DATE(’01/’|| luna_ ||’/’||an_ , ’DD/MM/YYYY’) ; \nzi := prima_zi ; \n WHILE zi <= LAST_DAY(prima_zi) LOOP \n IF RTRIM(TO_CHAR(zi,’DAY’)) IN (’SATURDAY’, ’SUNDAY’) THEN \n  NULL; \n ELSE \n BEGIN \n  INSERT INTO pontaje (marca, data) \n  SELECT marca, zi FROM personal; \n  EXCEPTION \n  WHEN DUP_VAL_ON_INDEX THEN \n  DELETE FROM pontaje WHERE data = zi ; \n  INSERT INTO pontaje (marca, data) \n  SELECT marca, zi FROM personal ; \n END ; \nEND IF ; \nzi:= zi + 1; \n END LOOP; \n COMMIT; \nEND populare; \n\nCare dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Procedura nu permite incalcarea restrictiei de cheie primara",
            "B": "Variabilele an si luna sunt parametrii formali",
            "C": "Procedura populeaza tabela PONTAJE pe o luna si un an cu date din tabela PERSONAL",
            "D": "Apelul se face astfel: populare(07,2008);",
            "E": "Apelul se face astfel: populare(2008,07);"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "Explicație:\n\nA. Procedura nu permite încălcarea restricției de cheie primară - Această afirmație este adevărată. Procedura gestionează potențialele încălcări ale cheii primare folosind un handler de excepții. Dacă o încercare de a insera date încalcă constrângerea de cheie primară (DUP_VAL_ON_INDEX), aceasta șterge intrările conflictuale și apoi reîncearcă inserarea, asigurându-se că restricția de cheie primară nu este încălcată.\n\nB. Variabilele an și luna sunt parametrii formali - Această afirmație este adevărată. În definiția procedurii, `an_` și `luna_` sunt declarate ca parametri de intrare (an_ IN, luna_ IN) și sunt folosiți ca parametri formali în cadrul procedurii.\n\nC. Procedura populează tabela PONTAJE pe o lună"
        },
        {
          "id": 19,
          "text": "Fie tabelul \nANGAJAT(Marca, Numepren, Compart, Datasv, Salorar,Salorarco, Compart)\n cu interogarea \nSELECT marca, Numepren, Datasv, vechime(datasv,2008,7) FROM ANGAJAT) \nsi functia \n\nCREATE OR REPLACE FUNCTION vechime \n(Datasv_ DATE, An_ Number(4), Luna_ Number(2)) \nRETURN Integer \nAS \nprima_zi DATE:=TO_DATE(’01/’||luna_||’/’||an_,’DD/MM/YYYY’); \nBEGIN \n RETURN TRUNC(MONTHS_BETWEEN(prima_zi,Datasv_)/12,0); \nEND; \n\nCare dintre urmatoarele afirmatii sunt adevarate?",
          "options": {
            "A": "Interogarea produce o singura valoare",
            "B": "Apelul functiei nu este plasat corectin interogare",
            "C": "Functia calculeaza numarul de ani dintre o datasi prima zi a lunii de referinta",
            "D": "Functia si interogarea sunt corecte",
            "E": "Interogarea produce mai multe valori"
          },
          "correct_answer": [
            "C",
            "D"
          ],
          "explanation": "Întrebarea implică analiza unei interogări SQL folosind o funcție personalizată PL/SQL. Să descompunem componentele relevante:\n\n1. **Funcția `vechime`:** Această funcție calculează numărul de ani întregi între o dată dată (`Datasv_`) și prima zi a unei luni și ani specificați (`prima_zi`). Folosește `MONTHS_BETWEEN` pentru a găsi diferența în luni și apoi împarte la 12 pentru a o converti în ani, trunchiind pentru a obține anii întregi.\n\n2. **Interogarea:** Interogarea SQL preia câmpurile `marca`, `Numepren` și `Datasv` din tabelul `ANGAJAT` și calculează vechimea folosind funcția `vechime`, cu o dată de referință de"
        },
        {
          "id": 20,
          "text": "In definirea unui cursor explicit exista urmatoarele 5 operatiuni: \n1. Declararea variabilei in care va fi stocata o linie a cursorului \n2. Deschiderea cursorului (OPEN) \n3. Declararea cursorului printr-o fraza SELECT (CURSOR nume IS SELECT ...) \n4. Structura de ciclare ce include, obligatoriu, o comanda deincarcare a \nurmatoarelor linii din cursor altfel bucla se repeta la infinit \n5. Incarcarea urmatoarei linii din cursor (FETCH) Care este ordinea corecta a acestor operatii?",
          "options": {
            "A": "3,2,1,4,5",
            "B": "3,1,2,5,4",
            "C": "2,3,1,5,4",
            "D": "1,3,2,4,5",
            "E": "2,1,3,4,5"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În procesul de definire și utilizare a unui cursor explicit, operațiunile trebuie efectuate într-o ordine specifică pentru a asigura funcționarea corectă a cursorului. Iată ordinea corectă cu o explicație:\n\n1. **Declararea cursorului printr-o frază SELECT (CURSOR nume IS SELECT ...) (Pasul 3):** Înainte de orice altceva, cursorul trebuie declarat. Aceasta implică specificarea interogării SQL pe care cursorul o va executa, stabilind ce date va gestiona cursorul.\n\n2. **Declararea variabilei în care va fi stocată o linie a cursorului (Pasul 1):** După declararea cursorului, trebuie definită o variabilă care să conțină datele din fiecare rând preluat de cursor. Acest pas este esențial pentru procesarea datelor recuperate."
        }
      ]
    },
    {
      "name": "Tehnologii Web",
      "questions": [
        {
          "id": 1,
          "text": "Care este rezultatul urmatoarei operatii in JavaScript: “1” + 2 + 4 ?",
          "options": {
            "A": "124",
            "B": "\"124\"",
            "C": "eroare,asemenea operatii nu pot fi efectuate",
            "D": "“1” si 24",
            "E": "“1” si 6"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "În JavaScript, operatorul `+` poate fi folosit atât pentru adunare, cât și pentru concatenarea șirurilor de caractere. Atunci când se folosește operatorul `+`, dacă unul dintre operanzi este un șir de caractere, JavaScript va converti celălalt operand într-un șir de caractere și va efectua concatenarea. În expresia `\"1\" + 2 + 4`, `\"1\"` este un șir de caractere, astfel încât `2` este convertit într-un șir de caractere și concatenat, rezultând `\"12\"`. Apoi, `4` este de asemenea convertit într-un șir de caractere și concatenat, rezultând șirul final `\"124\"`. Prin urmare, răspunsul corect este B."
        },
        {
          "id": 2,
          "text": "Care este rezultatul urmatoarei operatii in JavaScript: 2 + 5 + “8”?",
          "options": {
            "A": "\"78\"",
            "B": "eroare, asemenea operatii nu pot fi efectuate",
            "C": "78",
            "D": "“258”",
            "E": "258"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În JavaScript, operatorul `+` este folosit atât pentru adunare, cât și pentru concatenarea șirurilor de caractere. Când o expresie conține atât numere, cât și șiruri de caractere, JavaScript efectuează coerciția de tip, convertind numerele în șiruri de caractere, dacă este necesar, pentru a le concatena. În expresia `2 + 5 + \"8\"`, operațiile sunt evaluate de la stânga la dreapta. Mai întâi, `2 + 5` este evaluat, rezultând numărul `7`. Apoi, `7` este concatenat cu șirul `\"8\"`, rezultând șirul `\"78\"`. Prin urmare, răspunsul corect este A: `\"78\"`."
        },
        {
          "id": 3,
          "text": "Ce face operatorul “= = =”in JavaScript?",
          "options": {
            "A": "nu exista acest operator",
            "B": "operatorul este adevarat doar daca operatorii sunt egali fara nicio conversie de tip",
            "C": "este operatorul egal strict",
            "D": "operatorul este adevarat daca operatorii sunt egali dupa o conversie de tip",
            "E": "operatorul se foloseste doarin cazul string-urilor"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "În JavaScript, operatorul \"===\" este cunoscut ca operatorul de egalitate strictă. Acesta verifică egalitatea între două valori fără a efectua vreo conversie de tip, ceea ce înseamnă că valorile trebuie să fie de același tip și să aibă aceeași valoare pentru ca comparația să returneze adevărat. Acest lucru îl deosebește de operatorul \"==\", care efectuează conversia de tip. Prin urmare, explicațiile corecte pentru funcția operatorului \"===\" sunt B, deoarece este adevărat doar dacă operanzii sunt egali fără conversie de tip, și C, deoarece este denumit operatorul de egalitate strictă."
        },
        {
          "id": 4,
          "text": "Ce face urmatoarea regula CSS? p {color: red}",
          "options": {
            "A": "scrie cu rosu toate textele din toate paragrafele",
            "B": "scrie cu rosu textul din paragraful urmator",
            "C": "atribuie variabilei p culoarea rosu",
            "D": "schimba culoarea fundalului in rosu",
            "E": "functia p are ca parametru culoarea rosu"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Explicație: Regula CSS `p {color: red}` vizează toate elementele `<p>` (paragrafe) dintr-un document HTML și setează culoarea textului acestora la roșu. În CSS, proprietatea `color` afectează culoarea textului elementelor selectate. Deoarece `p` este un selector pentru elementele de paragraf, opțiunea A descrie corect efectul regulii ca schimbând culoarea textului tuturor paragrafelor în roșu. Celelalte opțiuni descriu incorect efectul regulii, fie prin interpretarea greșită a sintaxei CSS, fie prin atribuirea proprietății unui aspect greșit (cum ar fi fundalul sau o variabilă)."
        },
        {
          "id": 5,
          "text": "Ce face urmatoarea regula CSS? p em {color:green}",
          "options": {
            "A": "textul scris in stil italic din paragrafe este verde",
            "B": "textele din paragrafe sunt scrise cu culoarea verde",
            "C": "textul scrisin stil italic din paragraful urmator este verde",
            "D": "cuvantul em din paragraful urmator este scris cu verde",
            "E": "regula este scrisa gresit"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Regula CSS `p em {color:green}` vizează toate elementele `<em>` care sunt cuibărite în interiorul elementelor `<p>` (paragraf) și le setează culoarea textului la verde. Eticheta `<em>` este folosită pentru a evidenția textul și, de obicei, se afișează ca text italicizat în majoritatea browserelor. Prin urmare, regula schimbă specific culoarea textului evidențiat (italic) din paragrafe în verde, făcând opțiunea A răspunsul corect."
        },
        {
          "id": 6,
          "text": "Ce rezultat are urmatorul cod HTML?\n<TABLE BORDER=”2” CELLPADDING=”2” WIDTH=”100%”>\n    <TR onMouseover=”this.bgColor=’#EEEEEE’”onMouseout=”this.bgColor=’#FFFFFF’”>\n        <TD>Your Table Data</TD>\n        </TR><TR onMouseover=”this.bgColor=’#EEEEEE’”onMouseout=”this.bgColor=’#FFFFFF’”>\n    <TD>Your Table Data</TD></TR>\n        <TR onMouseover=”this.bgColor=’#EEEEEE’”onMouseout=”this.bgColor=’#FFFFFF’”>\n            <TD>Your Table Data</TD></TR></TABLE>",
          "options": {
            "A": "schimba culoare de background a tabelului cand se trece cu mouse-ul pe deasupra acestuia",
            "B": "creeaza un tabel cu 3 coloane",
            "C": "creeaza un tabel",
            "D": "schimba culoarea de background a paginii din #EEEEEE in #FFFFFF cand se trece cu mouse-ul peste tabel",
            "E": "schimba culoarea de background a paginii din #FFFFFF in #EEEEEE cand se trece cu mouse-ul peste tabel"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "Codul HTML dat creează un tabel HTML cu o bordură și spațiere în jurul celulelor sale. Tabelul este format din trei rânduri (elemente `<TR>`), fiecare conținând o singură celulă (element `<TD>`) cu textul \"Your Table Data\". Atributele `onMouseover` și `onMouseout` din fiecare element `<TR>` sunt gestionari de evenimente JavaScript care schimbă culoarea de fundal a rândului atunci când mouse-ul se află deasupra acestuia sau se îndepărtează de el. Mai exact, când mouse-ul este deasupra unui rând, culoarea de fundal se schimbă în `#EEEEEE`, iar când mouse-ul părăsește rândul, culoarea revine la `#FFFFFF`.\n\nAșadar:\n- **Opțiunea A** este corectă: Se schimbă culoarea de fundal a fiecărui rând (nu a întregului tabel sau a paginii) atunci când utilizatorul trece cu mouse-ul peste el.\n- **Opțiunea C** este de asemenea corectă: Codul creează un tabel cu trei rânduri, fiecare conținând un singur element de date (`<TD>`).\n\nRestul opțiunilor sunt incorecte:\n- **B**: Tabelul are trei rânduri, nu trei coloane.\n- **D și E**: Schimbarea culorii se aplică doar rândurilor individuale, nu întregii pagini.\n\nPrin urmare, răspunsurile corecte sunt **A** și **C**."
        },
        {
          "id": 7,
          "text": "Ce rezultat are urmatorul cod?\n<form>\n    <inputtype=”button”value=”Clickme”onclick=”window.open(’http://www.domain.com’)”>\n    </form>",
          "options": {
            "A": "deschide o noua fereastra de browser cu ajutorul unui buton",
            "B": "nu face nimic, variabila onclick nu este declarata",
            "C": "creeaza un buton",
            "D": "creeaza un link catre o noua fereastra de browser",
            "E": "niciunul dintre raspunsurile de mai sus"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "Codul HTML dat creează un formular care conține un element de tip \"button\". Acest buton are eticheta \"Click me\" și un handler pentru evenimentul \"onclick\" care declanșează deschiderea unei noi ferestre sau file de browser către URL-ul specificat ('http://www.domain.com') atunci când butonul este apăsat. Prin urmare, opțiunea A este corectă deoarece codul va deschide într-adevăr o nouă fereastră de browser când butonul este apăsat. Opțiunea C este, de asemenea, corectă deoarece codul creează un element de tip buton în formular. Celelalte opțiuni sunt incorecte: B este greșită deoarece \"onclick\" este un atribut de eveniment, nu o variabilă care necesită declarare; D este incorectă deoarece codul nu creează un link, ci un buton; E este incorectă deoarece atât A cât și C sunt răspunsuri valide."
        },
        {
          "id": 8,
          "text": "Ce rezultat are urmatorul cod JavaScript?\n<a href=”” onMouseOver=”alert(’Your Message’);return true;”>Linked Text</a>",
          "options": {
            "A": "in momentul in care se trece cu mouse-ul peste link sare o fereastra de alertare",
            "B": "in momentul in care se apasa link-ul sare o fereastra de alertare",
            "C": "in momentul in care se trece peste link cu mouse-ul browserul deschide o noua fereastra",
            "D": "nu are niciun efect",
            "E": "niciunul dintre raspunsurile de mai sus"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A. Evenimentul `onMouseOver` în JavaScript este declanșat atunci când cursorul mouse-ului este mutat peste elementul specificat, în acest caz, hyperlink-ul (eticheta `<a>`). Când mouse-ul este plasat deasupra link-ului, funcția JavaScript `alert('Your Message')` este executată, afișând o casetă de alertă cu textul \"Your Message\". Prin urmare, de îndată ce utilizatorul mută mouse-ul peste link, apare o fereastră de alertă, corespunzând opțiunii A."
        },
        {
          "id": 9,
          "text": "Cum se defineste o constantain PHP?",
          "options": {
            "A": "prin directiva define()",
            "B": "cu ajutorul cuvantului cheie const",
            "C": "cu ajutorul cuvintelor cheie var const",
            "D": "cu ajutorul cuvantului static",
            "E": "cu un Macro"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În PHP, o constantă este definită folosind funcția `define()`, care îți permite să setezi un nume pentru constantă și să îi atribui o valoare. Odată definită, valoarea unei constante nu poate fi schimbată în timpul execuției scriptului. Acest lucru este diferit de variabile, care pot fi modificate. Funcția `define()` este special concepută pentru acest scop, făcând din opțiunea A alegerea corectă. Opțiunea B, folosind cuvântul cheie `const`, este de asemenea o modalitate validă de a defini constante începând cu PHP 5.3, dar deoarece întrebarea specifică utilizarea unei directive, `define()` este răspunsul mai potrivit. Opțiunile C, D și E sunt incorecte deoarece nu au legătură cu definirea constantelor în PHP."
        },
        {
          "id": 10,
          "text": "Cum se poate trimite un formular fara ajutorul unui buton de “Submit”?",
          "options": {
            "A": "cu ajutorul unui hyperlink",
            "B": "cu ajutorul unui hyperlink, dar cu ajutorul JavaScript",
            "C": "<a href=\"javascript: document.myform.submit();\">Submit Me</a>",
            "D": "<a href=” myform.submit();”>Submit Me</a>",
            "E": "nu se poate trimite"
          },
          "correct_answer": [
            "B",
            "C"
          ],
          "explanation": "Pentru a trimite un formular fără a folosi un buton tradițional de \"Trimitere\", se pot utiliza hyperlinkuri în combinație cu JavaScript. Opțiunea B este corectă deoarece menționează folosirea unui hyperlink împreună cu JavaScript, care poate fi folosit pentru a declanșa trimiterea formularului. Opțiunea C demonstrează acest lucru în mod specific prin utilizarea unei etichete de ancorare cu un atribut `href` care apelează o funcție JavaScript pentru a trimite formularul (`document.myform.submit();`). Acest lucru trimite efectiv formularul atunci când hyperlinkul este clicat. Opțiunea D este incorectă din cauza erorilor de sintaxă, iar opțiunea E este incorectă deoarece este într-adevăr posibil să trimiți un formular fără un buton de trimitere folosind JavaScript."
        },
        {
          "id": 11,
          "text": "De ce urmatorul cod nu afiseaza o noua linie corect?\n<?php $str = ‘Hello, there.\\nHow are you?\\nThanks for visiting fyicenter’; print $str; ?>\n",
          "options": {
            "A": "pentru ca \"\n\" nu este interpretat ca o linie noua",
            "B": "afiseaza corect linia noua",
            "C": "\"\\\" si \"n\" sunt afisate ca o secventa de caractere",
            "D": "lipseste directiva newLine();",
            "E": "lipseste directiva println();"
          },
          "correct_answer": [
            "A",
            "C"
          ],
          "explanation": "În PHP, șirurile de caractere delimitate de apostrofuri simple nu interpretează secvențele de escape precum `\\n` ca fiind caractere speciale. În schimb, ele sunt tratate ca text literal. Prin urmare, în codul dat, `\\n` nu este interpretat ca un caracter de linie nouă, ci este afișat ca cele două caractere `\\` și `n`. Acesta este motivul pentru care răspunsurile corecte sunt A și C: secvența de escape pentru linie nouă `\\n` nu este interpretată ca o linie nouă și este afișată ca o secvență de caractere. Pentru a obține comportamentul dorit, ar trebui folosite ghilimele duble în jurul șirului de caractere, sau linia nouă ar trebui adăugată explicit folosind concatenarea sau alte metode."
        },
        {
          "id": 12,
          "text": "Care este lungimea maxima a unui nume de tabel, de baza de date sau camp in MySQL?",
          "options": {
            "A": "tabel: 64 de caractere, baza de date: 64 de caractere, camp: 64 de caractere",
            "B": "48 de caractere, baza de date: 64 de caractere, camp: 48 de caractere",
            "C": "8 de caractere, baza de date: 8 de caractere, camp: 8 de caractere",
            "D": "64 de caractere, baza de date: 64 de caractere, camp: 63 de caractere",
            "E": "nu exista limita de lungime"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În MySQL, lungimea maximă pentru numele tabelelor, bazelor de date și coloanelor (câmpurilor) este definită de sistem. Valorile corecte sunt următoarele:\n\n- **Nume Tabel**: Lungimea maximă pentru un nume de tabel este de 64 de caractere.\n- **Nume Bază de Date**: În mod similar, lungimea maximă pentru un nume de bază de date este de 64 de caractere.\n- **Nume Coloană**: Lungimea maximă pentru un nume de coloană (câmp) este, de asemenea, de 64 de caractere.\n\nAceste limite sunt stabilite pentru a asigura că numele sunt gestionabile și nu cauzează probleme în cadrul sistemului de baze de date. Răspunsul corect este opțiunea A, care afirmă că lungimea maximă pentru toate cele trei—nume de tabel, bază de date și câmp—este de 64 de caractere. Opțiunile B, C, D,"
        },
        {
          "id": 13,
          "text": "Care din urmatoarele functii sunt functii de criptarein PHP?",
          "options": {
            "A": "CRYPT()",
            "B": "MD5()",
            "C": "CRYPTED()",
            "D": "MD6()",
            "E": "ENCRYPT()"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "În PHP, funcțiile legate de criptare și hashing sunt utilizate pentru a securiza datele.\n\n- **A. CRYPT()**: Aceasta este o funcție PHP încorporată folosită pentru hashing-ul șirurilor de caractere folosind algoritmi de hashing unidirecționali. Este utilizată frecvent pentru hashing-ul parolelor. Suportă mai mulți algoritmi în funcție de sistemul de operare (de exemplu, DES, MD5, Blowfish, SHA-256, SHA-512).\n\n- **B. MD5()**: Această funcție generează un număr hexazecimal de 32 de caractere, care este o valoare hash, dintr-un șir de intrare dat. Deși nu este recomandată pentru criptare sigură din cauza vulnerabilităților cunoscute (coliziuni), este totuși considerată o funcție de hashing, deci relevantă în contextul criptării ușoare sau verificării integrității datelor.\n\n- **C. CRYPTED()**: Nu există o astfel de funcție în PHP. Este posibil ca această opțiune să fie o confuzie cu `crypt()`, dar `crypted()` nu este definită nativ și nu are funcționalitate în acest context.\n\n- **D. MD6()**: Deși MD6 este un algoritm real de hashing propus ca succesor pentru MD5 și SHA-2, **nu este implementat nativ** în PHP. Prin urmare, nu este o funcție recunoscută în limbajul PHP.\n\n- **E. ENCRYPT()**: De asemenea, nu există o funcție standard numită `ENCRYPT()` în PHP. Criptarea în PHP se face prin extensii precum OpenSSL (`openssl_encrypt()`, `mcrypt_encrypt()` – învechit) sau Sodium (`sodium_crypto_secretbox()` etc.).\n\nAstfel, doar funcțiile `CRYPT()` și `MD5()` sunt valide și recunoscute ca funcții de criptare sau hashing în PHP, motiv pentru care **răspunsurile corecte sunt A și B**."
        },
        {
          "id": 14,
          "text": "Ce efect are urmatoarea linie de cod:\n<marquee>THIS WILL DISAPPEAR</marquee>?",
          "options": {
            "A": "textul disparein fundal",
            "B": "textul se plimba pe ecran de la stanga la dreapta",
            "C": "textul se plimba pe ecran de la dreapta la stanga",
            "D": "afiseaza un dreptunghi cu textul THIS WILL DISAPPER",
            "E": "marcheaza textul THIS WILL DISAPPEAR"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Eticheta HTML `<marquee>` este folosită pentru a crea efecte de text derulant pe o pagină web. În mod implicit, textul din interiorul etichetei `<marquee>` se mișcă de la dreapta la stânga pe ecran. Prin urmare, răspunsul corect este C: \"textul se plimbă pe ecran de la dreapta la stânga,\" ceea ce înseamnă \"textul se mișcă pe ecran de la dreapta la stânga.\" Acest comportament este un efect vizual care atrage atenția asupra textului, făcându-l să pară că se mișcă continuu în direcția specificată. Rețineți că eticheta `<marquee>` este considerată învechită în HTML5, iar utilizarea sa este în general descurajată în favoarea animațiilor CSS."
        },
        {
          "id": 15,
          "text": "Care dintre sintaxele urmatoare este corecta?",
          "options": {
            "A": "body {color: black}",
            "B": "{body;color:black}",
            "C": "body:color=black",
            "D": "{body:color=black(body}",
            "E": "{body=color:black(body)}"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În CSS, sintaxa corectă pentru stilizarea elementelor implică utilizarea unui selector urmat de acolade care închid perechi de proprietăți și valori. Opțiunea A, `body {color: black}`, este corectă deoarece urmează această structură: selectorul `body` este urmat de acolade care conțin proprietatea `color` și valoarea acesteia `black`, separate prin două puncte. Celelalte opțiuni conțin erori de sintaxă, cum ar fi caractere plasate greșit sau utilizarea incorectă a simbolurilor, care nu respectă regulile standard de sintaxă CSS."
        },
        {
          "id": 16,
          "text": "Cum se adauga aceeasi culoare de background pentru toate elementele <h1>?",
          "options": {
            "A": "h1 {background-color:#FFFFFF}",
            "B": "h1.all {background-color:#FFFFFF}",
            "C": "all.h1 {background-color:#FFFFFF}",
            "D": "h1 ={background-color:#FFFFFF}",
            "E": "h1 :{background-color:#FFFFFF"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Pentru a aplica aceeași culoare de fundal tuturor elementelor `<h1>`, trebuie să folosești un selector CSS care vizează toate elementele `<h1>`. Sintaxa corectă pentru aceasta este `h1 {background-color:#FFFFFF;}`. Această regulă aplică culoarea de fundal specificată fiecărui element `<h1>` din document. Opțiunea A este corectă deoarece folosește sintaxa corectă pentru o regulă CSS: selectorul `h1` vizează toate elementele `<h1>`, iar `{background-color:#FFFFFF;}` le aplică culoarea de fundal albă. Alte opțiuni fie folosesc selectori incorecți, nu utilizează sintaxa corectă CSS, fie folosesc greșit două puncte și acolade."
        },
        {
          "id": 17,
          "text": "Care este eticheta corecta HTML pentru a scrie un text cu bold?",
          "options": {
            "A": "<b>",
            "B": "<bold>",
            "C": "<bld>",
            "D": "<bb>",
            "E": "B"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Explicație: În HTML, eticheta `<b>` este folosită pentru a crea text îngroșat. Este eticheta corectă pentru a face textul să apară cu caractere îngroșate, fără a implica vreo importanță sau accentuare suplimentară. Celelalte opțiuni, `<bold>`, `<bld>`, `<bb>` și `B`, nu sunt etichete HTML valide pentru text îngroșat."
        },
        {
          "id": 18,
          "text": "Care este eticheta corecta HTML pentru a scrie un hyperlink?",
          "options": {
            "A": "<a>http://www.w3schools.com</a>",
            "B": "<a url=”http://www.w3schools.com”>W3Schools.com</a>",
            "C": "<a href=\"http://www.w3schools.com\">W3Schools</a>",
            "D": "<a name=”http://www.w3schools.com”>W3Schools.com</a>",
            "E": "<a href=”http://www.w3schools.com”>W3Schools<a>"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "În HTML, un hyperlink este creat folosind eticheta `<a>` (ancoră), care necesită atributul `href` pentru a specifica URL-ul paginii către care duce linkul. Textul linkului, care este partea pe care se poate face clic, este plasat între eticheta de deschidere `<a>` și eticheta de închidere `</a>`. Opțiunea C folosește corect atributul `href` pentru a defini URL-ul și oferă textul linkului între etichete. Prin urmare, `<a href=\"http://www.w3schools.com\">W3Schools</a>` este formatul corect pentru a scrie un hyperlink în HTML. Alte opțiuni fie folosesc atribute incorecte, fie au erori de sintaxă, cum ar fi lipsa etichetei de închidere sau utilizarea unor nume de atribute incorecte."
        },
        {
          "id": 19,
          "text": "Care este eticheta corecta HTML pentru un link e-mail?",
          "options": {
            "A": "<mail>aaa@yyy</mail>",
            "B": "<a href=”aaa@yyy”>",
            "C": "<mail href=”aaa@yyy”>",
            "D": "<a href=\"mailto:aaa@yyy\">",
            "E": "<a href=”mailto:aaa@yyy”></a>"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Eticheta corectă pentru crearea unui link de email în HTML este D: `<a href=\"mailto:aaa@yyy\">`. Această opțiune folosește corect eticheta `<a>`, care este destinată hyperlink-urilor, și atributul `href` cu protocolul `mailto:`, indicând faptul că linkul ar trebui să deschidă clientul de email implicit al utilizatorului pentru a trimite un email la adresa specificată. Opțiunea E este de asemenea corectă din punct de vedere sintactic, deoarece include etichete de închidere, dar D este cel mai concis răspuns corect fără elemente suplimentare."
        },
        {
          "id": 20,
          "text": "Care este eticheta corecta HTML pentru liste numerotate?",
          "options": {
            "A": "<ul>",
            "B": "<dl>",
            "C": "<ol>",
            "D": "<list>",
            "E": "<numl>"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "În HTML, diferite etichete sunt folosite pentru a crea diferite tipuri de liste. Eticheta `<ol>` reprezintă \"ordered list\" (listă ordonată) și este folosită pentru a crea liste în care fiecare element este numerotat. Acesta este motivul pentru care răspunsul corect este C. Eticheta `<ul>` este folosită pentru liste neordonate (cu puncte), `<dl>` este folosită pentru liste de definiții, iar `<list>` și `<numl>` nu sunt etichete standard HTML."
        },
        {
          "id": 21,
          "text": "Care este eticheta corecta HTML pentru inserarea unei imagini?",
          "options": {
            "A": "<img href=”image.gif>",
            "B": "<img>image.gif</img>",
            "C": "<image src=”image.gif”>",
            "D": "<img src=\"image.gif\">",
            "E": "<image src=”image.gif”></image>"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Răspunsul corect este D. În HTML, pentru a insera o imagine, se folosește eticheta `<img>`, iar atributul `src` specifică calea către fișierul imaginii. Sintaxa corectă este `<img src=\"image.gif\">`. Spre deosebire de alte etichete HTML, `<img>` este auto-închidere și nu necesită o etichetă de închidere. Opțiunea A este incorectă deoarece folosește `href` în loc de `src`. Opțiunea B folosește incorect `<img>` ca etichetă container cu etichete de închidere. Opțiunea C folosește incorect eticheta `<image>`, care nu este validă în HTML. Opțiunea E, de asemenea, folosește incorect eticheta `<image>` și include etichete de închidere inutile."
        },
        {
          "id": 22,
          "text": "Ce face urmatorul script JavaScript?\n<body>\n    <script language=”JavaScript”>\n        <!–\n        var myVariable = “Hello there”;\n        var therePlace = myVariable.search(“there”);\n        document.write(therePlace);\n        –>\n    </script>\n</body>",
          "options": {
            "A": "cauta un anumit cuvant intr-un text",
            "B": "cauta cuvantul \"there\" in \"Hello there\"",
            "C": "cauta cuvantul \"there\"",
            "D": "scrie variabila \"therePlace\"",
            "E": "cauta un anumit cuvant in string-ul \"Hello there\""
          },
          "correct_answer": [
            "A",
            "B",
            "C",
            "D",
            "E"
          ],
          "explanation": "Scriptul în cauză efectuează mai multe acțiuni legate de căutarea unui cuvânt specific într-un șir de caractere și afișarea rezultatului. Iată o descriere a ceea ce face:\n\n1. **Inițializare**: Scriptul inițializează o variabilă `myVariable` cu șirul de caractere \"Hello there\".\n\n2. **Căutarea unui cuvânt**: Utilizează metoda `search()` pentru a găsi poziția subșirului \"there\" în cadrul `myVariable`. Metoda returnează indexul primei apariții a subșirului specificat, care este 6 în acest caz (deoarece indexarea începe de la 0).\n\n3. **Stocarea rezultatului**: Rezultatul căutării (numărul 6) este stocat în variabila `therePlace`.\n\n4. **Afișarea rezultatului**: Valoarea variabilei `therePlace` este afișată pe pagină prin `document.write(therePlace)`, ceea ce va scrie `6` în conținutul HTML.\n\n5. **Comentariu incorect**: Scriptul încearcă să comenteze codul JavaScript cu sintaxa HTML `<!-- ... -->`, însă această practică este învechită și nu mai este necesară. De asemenea, ghilimelele din atributul `language=”JavaScript”` sunt ghilimele tipografice (greșite), care ar trebui înlocuite cu ghilimele drepte (`\"`). În ciuda acestor probleme minore, majoritatea browserelor moderne interpretează codul corect.\n\nToate opțiunile A, B, C, D și E reflectă aspecte corecte ale comportamentului scriptului, chiar dacă unele sunt formulate aproximativ sau se suprapun în sens. Prin urmare, toate sunt considerate răspunsuri valide."
        },
        {
          "id": 23,
          "text": "Inauntrul carui element HTML putem scrie un script JavaScript?",
          "options": {
            "A": "<script>",
            "B": "<js>",
            "C": "<javascript>",
            "D": "<scripting>",
            "E": "<jscript>"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Elementul corect de utilizat pentru a include cod JavaScript într-un document HTML este elementul `<script>`. Acesta este eticheta HTML standard și universal recunoscută pentru a încorpora sau referenția cod JavaScript. Opțiunile B (`<js>`), C (`<javascript>`), D (`<scripting>`) și E (`<jscript>`) nu sunt etichete HTML valide pentru a include JavaScript."
        },
        {
          "id": 24,
          "text": "Care este sintaxa corecta Javascript pentru a scrie “Hello World”?",
          "options": {
            "A": "document.write(\"Hello World\")",
            "B": "”Hello World”",
            "C": "”Hello World”",
            "D": "response.write(”Hello World”)",
            "E": "document.write(Hello World”)"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În JavaScript, metoda `document.write()` este folosită pentru a afișa text direct în documentul HTML. Sintaxa corectă pentru a scrie \"Hello World\" folosind această metodă este `document.write(\"Hello World\")`, care este opțiunea A. Opțiunile B și C sunt incorecte deoarece nu folosesc nicio metodă sau funcție JavaScript pentru a afișa textul. Opțiunea D folosește `response.write`, care nu este o metodă standard JavaScript pentru a scrie într-un document HTML. Opțiunea E este incorectă din cauza lipsei ghilimelei de deschidere pentru șirul de caractere \"Hello World\"."
        },
        {
          "id": 25,
          "text": "Cum se scrie “Hello World” intr-o fereastra alert?",
          "options": {
            "A": "alertBox=”Hello World”",
            "B": "alertBox(”Hello World”)",
            "C": "msgBox(”Hello World”)",
            "D": "alert(\"Hello World\")",
            "E": "winalert(“Hello World”)"
          },
          "correct_answer": [
            "D"
          ],
          "explanation": "Întrebarea cere cum să afișezi \"Hello World\" într-o fereastră de alertă folosind JavaScript.\n\nExplicație:\n- Opțiunea D, `alert(\"Hello World\")`, este sintaxa corectă pentru a crea un dialog de alertă pop-up în JavaScript care afișează mesajul \"Hello World\".\n- Opțiunea A, `alertBox=”Hello World”`, este incorectă deoarece `alertBox` nu este o funcție sau metodă folosită pentru alerte în JavaScript; pare a fi o operațiune de atribuire.\n- Opțiunea B, `alertBox(”Hello World”)`, este incorectă deoarece `alertBox` nu este o funcție recunoscută în JavaScript pentru alerte.\n- Opțiunea C, `msgBox(”Hello World”)`, este incorectă deoarece `msgBox` nu este o funcție JavaScript."
        },
        {
          "id": 26,
          "text": "Care sunt delimitatorii pentru script-urile PHP?",
          "options": {
            "A": "<script language=\"php\">...</script>",
            "B": "<?php...?>",
            "C": "<&>...</&>",
            "D": "¡<?php>...</?>",
            "E": "<php>...</php>"
          },
          "correct_answer": [
            "A",
            "B"
          ],
          "explanation": "În PHP, scripturile sunt de obicei integrate în HTML, iar delimitatori specifici sunt folosiți pentru a indica începutul și sfârșitul codului PHP. Delimitatorii corecți sunt:\n\nA. `<script language=\"php\">...</script>`: Deși nu este folosit în mod obișnuit, această sintaxă poate fi validă în anumite configurații în care PHP este interpretat în cadrul etichetelor script, dar este neconvențională.\n\nB. `<?php...?>`: Aceasta este eticheta standard și cea mai utilizată pentru a integra cod PHP într-un document. Ea indică parserului PHP să înceapă interpretarea codului care urmează după `<?php` și să se oprească la `?>`.\n\nCelelalte opțiuni sunt incorecte:\n\nC. `<&>...</&>`: Aceasta nu este o sintaxă PHP validă.\n\nD. `¡<?php>...</?>`: Aceasta nu este o sintaxă PHP validă."
        },
        {
          "id": 27,
          "text": "Cum se scrie “Hello World” in PHP?",
          "options": {
            "A": "Document.Write(”Hello World”);",
            "B": "document.write(”Hello World”);",
            "C": "echo \"Hello World\";",
            "D": "”Hello World”;",
            "E": "System.out.println(“Hello World”);"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "În PHP, instrucțiunea `echo` este folosită pentru a afișa text pe ecran. Dintre opțiunile oferite, opțiunea C, `echo \"Hello World\";`, utilizează corect comanda `echo` pentru a afișa șirul \"Hello World\". Celelalte opțiuni se referă la diferite limbaje de programare: A și B sunt JavaScript, D este o expresie incompletă sau incorectă, iar E este Java, ceea ce face ca C să fie alegerea corectă pentru PHP."
        },
        {
          "id": 28,
          "text": "Variabilele in PHP incep cu:",
          "options": {
            "A": "$",
            "B": "&",
            "C": "!",
            "D": "Nimic",
            "E": "%"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În PHP, toate numele variabilelor trebuie să înceapă cu un semn al dolarului (`$`). Aceasta este o cerință de sintaxă a limbajului, indicând că secvența de caractere care urmează este o variabilă. Utilizarea semnului dolarului ajută PHP să distingă variabilele de alte tipuri de identificatori din cod. Prin urmare, răspunsul corect este A."
        },
        {
          "id": 29,
          "text": "Ce inseamna CSS?",
          "options": {
            "A": "Cascading Style Sheets",
            "B": "Colorful Style Sheets",
            "C": "Creative Style Sheets",
            "D": "Computer Style Sheets",
            "E": "Cascade Style Sheets"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "CSS înseamnă „Cascading Style Sheets” (Foi de Stil în Cascadă), care este un limbaj de stiluri folosit pentru a descrie prezentarea unui document scris în HTML sau XML. Acesta permite dezvoltatorilor web să separe conținutul unei pagini web de designul său, facilitând gestionarea aspectului, culorilor, fonturilor și a aspectului general al site-ului. Termenul „cascading” se referă la modul în care stilurile sunt aplicate și prioritizate, permițând combinarea și aplicarea consecventă a mai multor reguli de stil pe paginile web."
        },
        {
          "id": 30,
          "text": "Care este sintaxa unei reguli CSS?",
          "options": {
            "A": "selector {proprietate : valoare}",
            "B": "selector(proprietate, valoare)",
            "C": "selector.proprietate = valoare",
            "D": "selector(proprietate) = valoare",
            "E": "{selector.proprietate = valoare}"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Răspunsul corect este A: „selector {proprietate : valoare}”. Această sintaxă este utilizată în CSS pentru a defini stilul unui element HTML specific sau al unui grup de elemente, unde „selector” țintește elementul(ele) HTML, „proprietate” specifică proprietatea CSS care urmează să fie stilizată, iar „valoare” definește valoarea pentru acea proprietate. Proprietățile și valorile sunt încadrate între acolade și separate prin două puncte, fiecare pereche proprietate-valoare fiind terminată de un punct și virgulă dacă există mai multe perechi. Acest format îți permite să aplici un stil consistent pe paginile web."
        },
        {
          "id": 31,
          "text": "CSS-ul se foloseste pentru:",
          "options": {
            "A": "poate fi folosit de mai multi agenti (browser, telefon mobil PDA)",
            "B": "separa continutul de prezentare",
            "C": "iti confirma faptul ca ai scris codul corect",
            "D": "a crea programe stand-alone",
            "E": "a face legatura cu o baza de date"
          },
          "correct_answer": [
            "A",
            "B",
            "C"
          ],
          "explanation": "CSS (Cascading Style Sheets) este utilizat în principal pentru stilizarea și formatarea paginilor web. Iată o scurtă explicație pentru fiecare opțiune corectă:\n\nA. **Poate fi folosit de mai mulți agenți (browser, telefon mobil PDA):** CSS este conceput pentru a asigura accesibilitatea și prezentabilitatea conținutului web pe diverse dispozitive și platforme, inclusiv diferite browsere web și dispozitive mobile, cum ar fi telefoanele și PDA-urile. Această adaptabilitate este una dintre punctele forte ale CSS, permițând o experiență de utilizare consistentă în diferite medii.\n\nB. **Separă conținutul de prezentare:** Unul dintre scopurile de bază ale CSS este de a separa conținutul (HTML) de prezentarea sa (stilizarea). Această separare permite un design mai flexibil și o întreținere mai ușoară, deoarece modificările aduse prezentării nu afectează structura conținutului. De asemenea, permite reutilizarea stilurilor pe mai multe pagini.\n\nC. **Îți confirmă faptul că ai scris codul corect:** Deși CSS nu validează direct corectitudinea codului HTML sau CSS, stilurile aplicate corect pot indica faptul că sintaxa este validă. Dacă stilurile nu sunt aplicate conform așteptărilor, poate fi un indiciu că există o eroare în codul CSS. Astfel, funcționează indirect ca o formă de verificare vizuală a corectitudinii."
        },
        {
          "id": 32,
          "text": "Ce efect are urmatoarea regula CSS? {color:green;}",
          "options": {
            "A": "totul o sa fie transformat in verde",
            "B": "* din text sunt transformatein verde",
            "C": "regula este un comentariu",
            "D": "regula este scrisa gresit",
            "E": "nu are niciun efect"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Regula CSS `{color:green;}` este o declarație validă care setează culoarea textului unui element HTML la verde. Totuși, regula este incompletă în forma prezentată, deoarece lipsește selectorul care să indice asupra cărui element se aplică această stilizare. Dacă ar fi folosită, de exemplu, împreună cu selectorul universal (`* { color: green; }`), atunci ar face ca tot textul de pe pagină să fie verde. Având în vedere că în întrebare este oferită doar partea cu `{color:green;}`, iar opțiunea A spune „totul o să fie transformat în verde”, presupunem că este implicat selectorul universal. Astfel, efectul ar fi că tot conținutul textului ar fi afișat în verde, motiv pentru care răspunsul A este considerat corect."
        },
        {
          "id": 33,
          "text": "Ce efect are urmatoarea regula CSS? \nimg [title] {border: 2px solid blue;} <img src=”images/sunset.jpg” alt=”Lahina Sunset” title=”Lahina Sunset”>",
          "options": {
            "A": "imaginea o sa aiba o margine de 2px",
            "B": "imaginea o sa aiba marimea de 2px",
            "C": "nu are niciun efect deoarece imaginea nu este inserata corect",
            "D": "scrie titlul imaginii cu albastru inchis",
            "E": "titlul imaginii esteincadrat de o margine de 2px"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "Regula CSS `img[title] { border: 2px solid blue; }` vizează orice element `<img>` care are un atribut `title` și îi aplică o bordură. În acest caz, imaginea `<img src=\"images/sunset.jpg\" alt=\"Lahina Sunset\" title=\"Lahina Sunset\">` include un atribut `title`, ceea ce înseamnă că regula CSS va aplica o bordură albastră solidă de 2px în jurul imaginii. Prin urmare, răspunsul corect este A, deoarece efectul regulii CSS este de a adăuga o bordură imaginii, nu de a-i schimba dimensiunea, de a afișa titlul într-o culoare diferită sau oricare dintre celelalte opțiuni."
        },
        {
          "id": 34,
          "text": "Cum se trimite in PHP un query MySQL?",
          "options": {
            "A": "mysql_query",
            "B": "mysql.query",
            "C": "query.mysql",
            "D": "query_mysql",
            "E": "mysql_q"
          },
          "correct_answer": [
            "A"
          ],
          "explanation": "În PHP, funcția utilizată pentru a trimite o interogare către o bază de date MySQL este `mysql_query()`. Această funcție este concepută special pentru a executa interogări precum SELECT, INSERT, UPDATE sau DELETE pe o bază de date MySQL. Sintaxa corespunde opțiunii A, `mysql_query`, care este răspunsul corect. Celelalte opțiuni nu reprezintă funcții PHP valide pentru executarea interogărilor MySQL. Totuși, este important de menționat că funcția `mysql_query()` este considerată depășită începând cu PHP 5.5.0 și a fost eliminată în PHP 7.0.0, fiind recomandat să se utilizeze MySQLi sau PDO_MySQL pentru interacțiunile cu baza de date în versiunile mai noi de PHP."
        },
        {
          "id": 35,
          "text": "Ce inseamna PHP?",
          "options": {
            "A": "Personal Hypertext Processor",
            "B": "PHP: Hypertext Preprocessor",
            "C": "Private Home Page",
            "D": "Personal Home Page",
            "E": "PHP: Private Hypertext Processor"
          },
          "correct_answer": [
            "B"
          ],
          "explanation": "PHP a însemnat inițial \"Personal Home Page\" atunci când a fost creat de Rasmus Lerdorf în 1994. Totuși, pe măsură ce limbajul a evoluat și a devenit mai sofisticat, semnificația a fost schimbată în \"PHP: Hypertext Preprocessor.\" Acesta este un exemplu de acronim recursiv, unde \"PHP\" este inclus în propria sa definiție. Termenul reflectă utilizarea principală a limbajului pentru scripting pe partea de server pentru a genera pagini web dinamice și a gestiona conținutul web."
        },
        {
          "id": 36,
          "text": "Care este modul corect de a se conecta la o baza de date MySQL?",
          "options": {
            "A": "mysql_open(”localhost”);",
            "B": "connect_mysql(”localhost”);",
            "C": "mysql_connect(\"localhost\");",
            "D": "dbopen(”localhost”);",
            "E": "dbconnetc(“localhost”);"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Explicație: Modul corect de a te conecta la o bază de date MySQL implică, de obicei, utilizarea unei funcții care stabilește o conexiune la server. În multe limbaje de programare și biblioteci, acest lucru se face folosind o funcție similară cu `mysql_connect(\"localhost\")`. Opțiunea C reprezintă o sintaxă comună utilizată în versiunile mai vechi de PHP, înainte de introducerea MySQLi și PDO, unde `mysql_connect` este funcția folosită pentru a iniția o conexiune la un server de baze de date MySQL la gazda specificată, care în acest caz este \"localhost\". Celelalte opțiuni fie folosesc nume de funcții incorecte, fie sintaxă incorectă."
        },
        {
          "id": 37,
          "text": "Care este modul corect de a adauga 1 la varibila $count?",
          "options": {
            "A": "$count =+1",
            "B": "++count",
            "C": "$count++;",
            "D": "count++;",
            "E": "$count==1"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "La întrebarea cu alegere multiplă dată, scopul este de a găsi modalitatea corectă de a incrementa variabila `$count` cu 1 în mai multe limbaje de programare, cum ar fi PHP, Java și C++.\n\nOpțiunea C, `$count++;`, este răspunsul corect. Acest lucru se datorează faptului că operatorul `++` este folosit pentru a incrementa valoarea unei variabile cu 1. Operatorul de post-incrementare `++` plasat după numele variabilei înseamnă că valoarea curentă a lui `$count` este utilizată în expresii, dacă există, și apoi este incrementată cu 1.\n\nSă analizăm pe scurt de ce celelalte opțiuni sunt incorecte:\n\n- A. `$count =+1`: Aceasta este incorectă deoarece atribuie valoarea `+1` lui `$count`, efectiv setând"
        },
        {
          "id": 38,
          "text": "Unde este corect sa asezam script-uri Javascript?",
          "options": {
            "A": "sectiunea body",
            "B": "sectiunea head",
            "C": "sectiunea body si sectiunea head",
            "D": "sectiunea title",
            "E": "sectiunea title si head"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Răspunsul corect este C, ceea ce înseamnă că scripturile JavaScript pot fi plasate atât în secțiunile de body, cât și în cele de head ale unui document HTML. Plasarea scripturilor în secțiunea de head este obișnuită pentru încărcarea bibliotecilor sau a scripturilor care trebuie să fie disponibile înainte ca conținutul să fie redat, în timp ce plasarea lor la sfârșitul secțiunii de body este adesea folosită pentru a asigura că întregul conținut HTML este încărcat complet înainte ca scriptul să ruleze, îmbunătățind performanța încărcării paginii și experiența utilizatorului. Scripturile nu ar trebui plasate în secțiunea de titlu, așa că opțiunile D și E sunt incorecte."
        },
        {
          "id": 39,
          "text": "Cum se poate introduce un script extern in Javascript?",
          "options": {
            "A": "<script href=”aaa.js”>",
            "B": "<script name=”aaa.js”>",
            "C": "<script src=\"aaa.js\">",
            "D": "<script src = “aaa.java”",
            "E": "<script src = “aaa.javascript>"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "Pentru a include un fișier JavaScript extern într-un document HTML, se folosește eticheta `<script>` cu atributul `src` care specifică calea către fișierul JavaScript. Opțiunea C, `<script src=\"aaa.js\">`, folosește corect atributul `src` pentru a face referire la fișierul extern \"aaa.js\". Opțiunile A și B folosesc atribute incorecte (`href` și `name`), în timp ce D și E fac referire la fișiere cu extensii incorecte (\".java\" și \".javascript\"). Extensia corectă pentru un fișier JavaScript este \".js\"."
        },
        {
          "id": 40,
          "text": "Cum se scriu comentariile in JavaScript?",
          "options": {
            "A": "’Acesta este un comentariu",
            "B": "<!–Acesta este un comentariu –>",
            "C": "//Acesta este un comentariu",
            "D": "Acesta este un comentariu",
            "E": "nu se pot scrie comentarii in JavaScript"
          },
          "correct_answer": [
            "C"
          ],
          "explanation": "În JavaScript, comentariile sunt folosite pentru a include explicații sau adnotări în cod, care sunt ignorate în timpul execuției. Sintaxa corectă pentru a scrie un comentariu pe o singură linie în JavaScript este utilizarea a două slash-uri `//` la începutul liniei de comentariu. Prin urmare, opțiunea C, `//Acesta este un comentariu`, demonstrează corect cum să scrii un comentariu în JavaScript. Alte opțiuni fie reprezintă sintaxa comentariilor din alte limbaje (cum ar fi `<!-- -->` din HTML), fie nu folosesc deloc o sintaxă de comentariu."
        }
      ]
    }
  ]
}